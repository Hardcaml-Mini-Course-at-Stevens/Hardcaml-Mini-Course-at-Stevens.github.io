[{"type":"Page","content":[{"url":"introduction/why","type":"Redirect"}],"lastModifiedTime":0,"tocItem":{"chapterTitle":"","pageTitle":"","pageMeta":{},"dirName":"","fileName":"index","fileExtension":"","viewOnRelativePath":null,"pageSectionIdTitles":[]}},{"type":"Page","content":[{"id":"ways-to-design-hardware","additionalIds":[],"title":"Ways to Design Hardware","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Most commonly, hardware is designed using (System)Verilog or VHDL. Both are called","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"hardware description languages (HDLs) and provide features to both write and test a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"hardware design. Each language exposes a subset which is called 'synthesizable,' i.e.,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"able to be turned into hardware. The full language can only be used for testing.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"A more recent alternative is High Level Synthesis (HLS). Here, hardware designs are","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"expressed in C or C++ (there may be other hosting languages available, but these are by","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"far the most common), and a sophisticated compiler generates an equivalent hardware design.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Notably, the exact cycle-by-cycle timing of the circuit is not specified by the designer","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"and is left up to the compiler. The designer can add various pragmas to guide the compiler's","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"choices in order to come up with a suitable hardware design that meets performance, area,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"or frequency requirements.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Finally, we come to Hardware Construction Languages (HCLs) - the class to which Hardcaml","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"belongs. Chisel, Clash, MyHDL, PyMtl, and SpinalHDL are other examples of HCLs. Here,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"hardware designs are described at a structural level within a standard software","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"programming language. Various tooling is provided to test your designs or convert them to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"an HDL.","type":"SimpleText"}]}]},{"id":"why-use-hardcaml","additionalIds":[],"title":"Why use Hardcaml?","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Hardcaml is an OCaml library. Hardcaml designs are programs written in OCaml. When a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Hardcaml program executes, it builds a data structure representing the hardware design the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"user describes. From there, Hardcaml can convert it to a standard HDL, build a simulation","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"model for testing, among various other capabilities we will discuss in this documentation.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"In terms of expressing our hardware designs, Hardcaml (and other HCLs) are able to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"describe the same circuits as normal HDLs like Verilog. Similarly, if you can express it in","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Hardcaml, then you can also do so in Verilog. Hardware architecture and design knowledge is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"transferable between these worlds.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"When we describe hardware using Hardcaml, we are performing a task called meta-programming.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"This means we are writing a program to generate something - in this case, a special","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"representation of hardware that Hardcaml understands.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"There are a number of advantages to this approach - here are a few:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Reuse standard OCaml tooling (i.e., editor integration, continuous integration).","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Easily create highly parameterized designs. This means we can often write a design once","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"but instantiate it multiple different ways to suit different requirements.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Leverage the powerful OCaml type system to enforce invariants on our types.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Use standard software libraries across our hardware designs and testing frameworks.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Quickcheck for testing is a hugely useful example.","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"There are some downsides, of course:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Generated HDL code (for use with vendor tooling like Vivado or Quartus) is computer","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"generated and nothing like what a human would write.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Hardcaml makes up names in generated code that look like ","type":"SimpleText"},{"code":"_8277","type":"InlinedCode"},{"text":". This isn't very","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"helpful when reading the logs from vendor tools. We have some tricks we can play here to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"make things a bit easier.","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"Of course the above is all a matter of opinion and you should make up your own!","type":"SimpleText"}]}]}],"lastModifiedTime":1750709444367,"tocItem":{"chapterTitle":"Introduction","pageTitle":"1.1 Why Hardcaml","pageMeta":{"parent":["introduction.mdx"],"title":["1.1 Why Hardcaml"],"uuid":["8482bb88-5175-3da2-e519-f3c06f649be2"]},"dirName":"introduction","fileName":"why","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Ways to Design Hardware","id":"ways-to-design-hardware","customAnchorId":"ways-to-design-hardware"},{"title":"Why use Hardcaml?","id":"why-use-hardcaml","customAnchorId":"why-use-hardcaml"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"Hardcaml can be installed with opam. I recommend the following","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"packages to get started","type":"SimpleText"}]},{"lang":"","snippet":"opam install hardcaml hardcaml_waveterm ppx_hardcaml","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"This will install the core Hardcaml library, a waveform viewer which","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"is helpful for building tests, and the hardcaml ppx.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"To access the latest packages or the most up-to-date version you may want","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"to try the Jane Street bleeding edge opam repository.","type":"SimpleText"}]},{"lang":"","snippet":"opam repo add janestreet-bleeding https://github.com/janestreet/opam-repository.git","lineNumber":"","type":"Snippet"},{"id":"basic-usage","additionalIds":[],"title":"Basic Usage","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Hardcaml can be used with utop (or another OCaml top level)","type":"SimpleText"}]},{"lang":"","snippet":"#require \"hardcaml\"\nopen Hardcaml","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"This provides a great environment to learn the ","type":"SimpleText"},{"code":"Bits","type":"InlinedCode"},{"text":" API. The following","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"utop command makes things nicer to play with","type":"SimpleText"}]},{"lang":"","snippet":"#install_printer Bits.pp","lineNumber":"","type":"Snippet"}]},{"id":"dune","additionalIds":[],"title":"Dune","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The following is an example Dune file for linking to Hardcaml","type":"SimpleText"}]},{"lang":"","snippet":"(library\n  (name my_hardcaml_lib)\n  (libraries base hardcaml)\n  (preprocess (pps ppx_jane ppx_hardcaml)))","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709444240,"tocItem":{"chapterTitle":"Introduction","pageTitle":"1.2 Installing the Opensource Release","pageMeta":{"parent":["./introduction.mdx"],"title":["1.2 Installing the Opensource Release"],"uuid":["5fc4ecaa-0279-37a4-f22d-73277649e821"]},"dirName":"introduction","fileName":"installing_with_opam","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Basic Usage","id":"basic-usage","customAnchorId":"basic-usage"},{"title":"Dune","id":"dune","customAnchorId":"dune"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"Hardcaml is a library for designing and simulating Register Transfer Level (RTL) hardware","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"designs. Hardcaml designs can be converted to Verilog or VHDL for use with vendor","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"synthesis and place and route tools.","type":"SimpleText"}]},{"id":"library-overview","additionalIds":[],"title":"Library Overview","type":"Section","content":[{"id":"library-overview-combs-bits-and-signal","additionalIds":["combs-bits-and-signal"],"level":2,"title":"Comb.S, Bits, and Signal","headingContent":[{"code":"Comb.S","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"Bits","type":"InlinedCode"},{"text":", and ","type":"SimpleText"},{"code":"Signal","type":"InlinedCode"}],"type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The module type","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Comb/module-type-S/index.html","isFile":false,"type":"Link","content":[{"code":"Comb.S","type":"InlinedCode"}]},{"type":"SoftLineBreak"},{"text":"defines the ","type":"SimpleText"},{"url":"/hardcaml-docs/designing-circuits/combinational_logic","isFile":false,"type":"Link","content":[{"text":"combinational logic","type":"SimpleText"}]},{"text":" primitives","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"(i.e., logical operations, arithmetic, multiplexers, etc.) for Hardcaml.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"It is implemented by both the ","type":"SimpleText"},{"code":"Bits","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"Signal","type":"InlinedCode"},{"text":" modules. All","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"operations work over vectors with a given bit width. Each operation","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"has rules about allowable argument widths and will raise an exception at","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"run-time if violated.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Bits/index.html","isFile":false,"type":"Link","content":[{"code":"Bits","type":"InlinedCode"}]},{"type":"SoftLineBreak"},{"text":"implements a shallow embedding of the ","type":"SimpleText"},{"code":"Comb.S","type":"InlinedCode"},{"text":" API. This means","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"it is used to compute values directly.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# open Hardcaml.Bits\n# let adder a b = a +: b;;\nval adder : t -> t -> t = <fun>\n# adder (of_string \"01\") (of_string \"10\")\n- : t = 11","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Signal/index.html","isFile":false,"type":"Link","content":[{"code":"Signal","type":"InlinedCode"}]},{"type":"SoftLineBreak"},{"text":"implements a deep embedding. This means it records the structure of a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"computation as a graph.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# open Hardcaml.Signal\n# open Hardcaml.Signal.Unoptimized\n# let adder a b = a +: b;;\nval adder : Type.t -> Type.t -> Type.t = <fun>\n# adder (of_string \"01\") (of_string \"10\")\n- : Type.t = (add (width 2) (arguments (0b01 0b10)))","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Signals also provide functions related to ","type":"SimpleText"},{"url":"/hardcaml-docs/designing-circuits/sequential_logic","isFile":false,"type":"Link","content":[{"text":"sequential logic","type":"SimpleText"}]},{"text":" (registers,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"memories, and state machines).","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"In summary","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"Signal.t","type":"InlinedCode"},{"text":"s are used to construct hardware designs.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"Bits.t","type":"InlinedCode"},{"text":"s can be used to ","type":"SimpleText"},{"type":"Emphasis","content":[{"text":"model","type":"SimpleText"}]},{"text":" combinational hardware circuits conveniently.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"As we shall see, ","type":"SimpleText"},{"code":"Bits.t","type":"InlinedCode"},{"text":"s are also used for input and output ports of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"hardware simulations.","type":"SimpleText"}]}]}]},{"id":"library-overview-circuit","additionalIds":["circuit"],"level":2,"title":"Circuit","headingContent":[{"code":"Circuit","type":"InlinedCode"}],"type":"SubHeading"},{"type":"Paragraph","content":[{"text":"A ","type":"SimpleText"},{"url":"/hardcaml-docs/designing-circuits/circuits","isFile":false,"type":"Link","content":[{"text":"circuit","type":"SimpleText"}]},{"text":" takes the output signals of a Hardcaml design and performs","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"various sanity checks to ensure that it can be converted to hardware. In particular, we","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"must provide input and output port names for our designs.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let c = output \"c\" (adder (input \"a\" 8) (input \"b\" 8))\nval c : Type.t = (wire (names (c)) (width 8) (data_in add))\n# let circuit = Hardcaml.Circuit.create_exn ~name:\"my_adder\" [ c ]\nval circuit : Hardcaml.Circuit.t = <abstr>","lineNumber":"","type":"Snippet"},{"id":"library-overview-hardware-generation-with-rtl","additionalIds":["hardware-generation-with-rtl"],"level":2,"title":"Hardware generation with Rtl","headingContent":[{"text":"Hardware generation with ","type":"SimpleText"},{"code":"Rtl","type":"InlinedCode"}],"type":"SubHeading"},{"type":"Paragraph","content":[{"text":"A circuit can be ","type":"SimpleText"},{"url":"/hardcaml-docs/designing-circuits/rtl_generation","isFile":false,"type":"Link","content":[{"text":"converted to RTL","type":"SimpleText"}]},{"text":" with Verilog or VHDL.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# Hardcaml.Rtl.print Verilog circuit\nmodule my_adder (\n    b,\n    a,\n    c\n);\n\n    input [7:0] b;\n    input [7:0] a;\n    output [7:0] c;\n\n    wire [7:0] _4;\n    assign _4 = a + b;\n    assign c = _4;\n\nendmodule\n- : unit = ()","lineNumber":"","type":"Snippet"},{"id":"library-overview-simulation-with-cyclesim","additionalIds":["simulation-with-cyclesim"],"level":2,"title":"Simulation with Cyclesim","headingContent":[{"text":"Simulation with ","type":"SimpleText"},{"code":"Cyclesim","type":"InlinedCode"}],"type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Circuits can be ","type":"SimpleText"},{"url":"/hardcaml-docs/simulating-circuits/simulation","isFile":false,"type":"Link","content":[{"text":"simulated with the ","type":"SimpleText"},{"code":"Cyclesim","type":"InlinedCode"},{"text":" module","type":"SimpleText"}]},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let sim = Hardcaml.Cyclesim.create circuit;;\nlet a = Hardcaml.Cyclesim.in_port sim \"a\";;\nlet b = Hardcaml.Cyclesim.in_port sim \"b\";;\nlet c = Hardcaml.Cyclesim.out_port sim \"c\";;\na := Hardcaml.Bits.of_unsigned_int ~width:8 10;;\nb := Hardcaml.Bits.of_unsigned_int ~width:8 20;;\nHardcaml.Cyclesim.cycle sim;;","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# Stdio.printf \"c = %i\\n\" (Hardcaml.Bits.to_unsigned_int !c);;\nc = 30\n- : unit = ()","lineNumber":"","type":"Snippet"},{"id":"library-overview-interfaces-with-ppx_hardcaml","additionalIds":["interfaces-with-ppx_hardcaml"],"level":2,"title":"Interfaces with ppx_hardcaml","headingContent":[{"text":"Interfaces with ","type":"SimpleText"},{"code":"ppx_hardcaml","type":"InlinedCode"}],"type":"SubHeading"},{"type":"Paragraph","content":[{"text":"An interface is a grouping of signals with associated names and bit widths.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# type 'a t =\n  { a : 'a[@bits 8]\n  ; b : 'a[@bits 7]\n  }\n  [@@deriving hardcaml];;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"A large set of functions are generated, which make working with interfaces useful for","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"constructing module ports or interacting with a hardware design in simulation.","type":"SimpleText"}]},{"type":"BlockQuote","content":[{"type":"Paragraph","content":[{"text":"📝 The term interface is unfortunately a bit overloaded and commonly used to described","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"mli files in OCaml, a concept in Object Oriented programming and a type representing a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"group of signals in SystemVerilog. Hardcamls use of interface is most similar to that","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"of SystemVerilog.","type":"SimpleText"}]}]},{"id":"library-overview-waveforms","additionalIds":["waveforms"],"level":2,"title":"Waveforms","type":"SubHeading"},{"fit":true,"destination":"/hardcaml-docs/waveterm.png","alt":"image","width":1920,"title":null,"inlined":false,"timestamp":1750709444320,"height":1087,"type":"Image"},{"type":"Paragraph","content":[{"code":"Hardcaml_waveterm","type":"InlinedCode"},{"text":" will output ","type":"SimpleText"},{"url":"/hardcaml-docs/simulating-circuits/waveforms","isFile":false,"type":"Link","content":[{"text":"waveforms","type":"SimpleText"}]},{"text":" of a simulation run as ASCII","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"text. This allows us to integrate them with standard software development style testing","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"workflows. In addition an interactive viewer application is provided for detailed","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"analysis.","type":"SimpleText"}]}]},{"id":"getting-working-hardware","additionalIds":[],"title":"Getting Working Hardware","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Designing hardware in Hardcaml is only part of the complete process of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"getting a fully working design. Let's consider the typical workflow for creating a simple","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Xilinx FPGA design:","type":"SimpleText"}]},{"delimiter":".","startNumber":1,"type":"OrderedList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Design and simulate the circuit with Hardcaml.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Output a Verilog (or VHDL) file using Hardcaml's RTL generation functions.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Create a project in Vivado, the Xilinx FPGA synthesis, place and route tool.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Add board-level constraints (pins, timing, etc.).","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Synthesize, place and route the design in Vivado.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Run static timing analysis.  If this fails, you must correct the Hardcaml design","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"or adjust constraints.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Generate a bitstream to program the FPGA.","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"For steps 1 and 2, we often use a project structure with a ","type":"SimpleText"},{"code":"bin","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"src","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"and ","type":"SimpleText"},{"code":"test","type":"InlinedCode"},{"text":" directory.","type":"SimpleText"}]},{"bulletMarker":"*","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"src","type":"InlinedCode"},{"text":" a library containing the hardware design.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"test","type":"InlinedCode"},{"text":" a test library with testbenches, expect tests etc.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"bin","type":"InlinedCode"},{"text":" an application to generate RTL code for the Vivado toolchain.","type":"SimpleText"}]}]}]}]}],"lastModifiedTime":1750709442926,"tocItem":{"chapterTitle":"Introduction","pageTitle":"1.3 Quick Overview","pageMeta":{"parent":["./introduction.mdx"],"title":["1.3 Quick Overview"],"uuid":["4f2a36a2-7df0-37d4-7695-81a1e2f6ed7a"]},"dirName":"introduction","fileName":"quick_overview","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Library Overview","id":"library-overview","customAnchorId":"library-overview"},{"title":"Getting Working Hardware","id":"getting-working-hardware","customAnchorId":"getting-working-hardware"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"Combinational logic is formed from boolean functions whose outputs are fully","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"determined by their current inputs. This is in contrast to sequential logic,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"where the outputs are a function of their current and previous inputs.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"At the lowest level, combinational circuits are built from simple primitives such","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"as NAND gates (in ASIC designs) or LUTs (in FPGA designs). Building circuits","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"with such low-level primitives is tedious, so instead, we provide a set of higher-level","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"primitives with which to design circuits. The ","type":"SimpleText"},{"code":"Comb.S","type":"InlinedCode"},{"text":" module type","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"provides these primitives.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Combinational circuits can be thought of as graphs with nodes representing logic","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"operations and edges representing ","type":"SimpleText"},{"code":"wires","type":"InlinedCode"},{"text":" (often also referred to as ","type":"SimpleText"},{"code":"signals","type":"InlinedCode"},{"text":"). These","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"graphs are directed and must not contain any cycles.","type":"SimpleText"}]},{"id":"vectors-and-widths","additionalIds":[],"title":"Vectors and Widths","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The fundamental type in Hardcaml is a vector with a specified width. The width","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"can be one or more bits. There exists a special signal called ","type":"SimpleText"},{"code":"empty","type":"InlinedCode"},{"text":" which has","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"zero width but is rarely used and exists for internal use.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"In Hardcaml the types ","type":"SimpleText"},{"code":"Signal.t","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"Bits.t","type":"InlinedCode"},{"text":" are used to represent vectors. For now we","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"will consider ","type":"SimpleText"},{"code":"Bits.t","type":"InlinedCode"},{"text":"s.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The simplest way to create a ","type":"SimpleText"},{"code":"Bits.t","type":"InlinedCode"},{"text":" value is the ","type":"SimpleText"},{"code":"of_string","type":"InlinedCode"},{"text":" function:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# open Hardcaml.Bits;;\n# let x = of_string \"11001\";;\nval x : t = 11001","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Note that in both the specification of the bit vector with ","type":"SimpleText"},{"code":"of_string","type":"InlinedCode"},{"text":" and the printing of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the value ","type":"SimpleText"},{"code":"x","type":"InlinedCode"},{"text":" we treat the left most 1 or 0 as the most significant bit.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"We can now interrogate the width of this value:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# width x\n- : int = 5","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"It is always possible to get the width of a Hardcaml vector.","type":"SimpleText"}]}]},{"id":"binary-constants-and-converting-to-ocaml-ints","additionalIds":[],"title":"Binary Constants and Converting to OCaml Ints","type":"Section","content":[{"type":"Paragraph","content":[{"code":"of_string","type":"InlinedCode"},{"text":" takes a string which consists of ","type":"SimpleText"},{"code":"0","type":"InlinedCode"},{"text":"s and ","type":"SimpleText"},{"code":"1","type":"InlinedCode"},{"text":"s (","type":"SimpleText"},{"code":"_","type":"InlinedCode"},{"text":"s are","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"also allowed, and are ignored). The first character in the string","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"becomes the most significant bit (msb) of the vector. The vector width","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"is the sum of the number of ","type":"SimpleText"},{"code":"0","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"1","type":"InlinedCode"},{"text":" characters in the string.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let x = of_string \"100\"\nval x : t = 100","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"A feature of the ","type":"SimpleText"},{"code":"Bits","type":"InlinedCode"},{"text":" module (but not ","type":"SimpleText"},{"code":"Signal","type":"InlinedCode"},{"text":"s) is the ability to convert","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"back to an OCaml value. We can do so with the ","type":"SimpleText"},{"code":"to_unsigned_int","type":"InlinedCode"},{"text":" function.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# to_unsigned_int x\n- : int = 4","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"code":"to_unsigned_int","type":"InlinedCode"},{"text":" has interpreted ","type":"SimpleText"},{"code":"x","type":"InlinedCode"},{"text":" as an unsigned, three-bit integer value.","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"to_signed_int","type":"InlinedCode"},{"text":" will treat it as a signed, twos-complement integer value.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# to_signed_int x\n- : int = -4","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"If the resulting value cannot fit in an integer then the functions will raise.","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"to_int_trunc","type":"InlinedCode"},{"text":" may be useful in such cases if used carefully.","type":"SimpleText"}]}]},{"id":"richer-constants","additionalIds":[],"title":"Richer Constants","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Probably the most useful constant-generating functions are ","type":"SimpleText"},{"code":"of_unsigned_int","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"of_signed_int","type":"InlinedCode"},{"text":":","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# of_unsigned_int ~width:10 514\n- : t = 1000000010","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"If the given value is negative, it will be sign extended to the appropriate width:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# of_signed_int ~width:10 (-1)\n- : t = 1111111111","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Values too large or too small to be represented in ","type":"SimpleText"},{"code":"width","type":"InlinedCode"},{"text":" bits will raise an exception.","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"of_int_trunc","type":"InlinedCode"},{"text":" will silently truncate the input value. Variants for ","type":"SimpleText"},{"code":"Int32.t","type":"InlinedCode"},{"text":" and","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Int64.t","type":"InlinedCode"},{"text":" are also provided.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The function ","type":"SimpleText"},{"code":"of_string","type":"InlinedCode"},{"text":" is actually more general than just converting","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"binary values. It can also parse a specification string which roughly","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"follows the Verilog constant format: ","type":"SimpleText"},{"code":"<width>'<format><value>","type":"InlinedCode"},{"text":".","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Binary (","type":"SimpleText"},{"code":"b","type":"InlinedCode"},{"text":"), decimal (","type":"SimpleText"},{"code":"d","type":"InlinedCode"},{"text":"), octal (","type":"SimpleText"},{"code":"o","type":"InlinedCode"},{"text":"), and hexadecimal (","type":"SimpleText"},{"code":"h","type":"InlinedCode"},{"text":") notations are","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"supported.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# of_string \"5'b1101\"\n- : t = 01101\n# of_string \"5'hd\"\n- : t = 01101\n# of_string \"5'd13\"\n- : t = 01101","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"If the format specifier is capitalized, the leading bit in the given","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"value will be used for sign extension (only relevant for the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"binary, octal, and hex specifiers).","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# of_string \"5'B1101\"\n- : t = 11101\n# of_string \"5'Hd\"\n- : t = 11101","lineNumber":"","type":"Snippet"}]},{"id":"operators-widths-and-their-names","additionalIds":[],"title":"Operators, Widths, and Their Names","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Hardcaml provides a set of operators providing the usual functions","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"such as logical, arithmetic and comparison operations. A key API","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"design point is Hardcaml does not encode signedness into the type of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"vectors. Instead, the operator suffix indicates how to interpret","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the operands. For example, there are two \"less than\" operators.","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Operators ending with ","type":"SimpleText"},{"code":"+","type":"InlinedCode"},{"text":" treat operands as signed","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Operators ending with ","type":"SimpleText"},{"code":":","type":"InlinedCode"},{"text":" treat operands as unsigned","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"For example, there are two distinct \"less than\" operators:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"(<+)","type":"InlinedCode"},{"text":" for signed less than","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"(<:)","type":"InlinedCode"},{"text":" for unsigned less than","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"Many operators are agnostic to signedness. The addition operator ","type":"SimpleText"},{"code":"(+:)","type":"InlinedCode"},{"text":" is an example of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"this. Addition requires both arguments to have the same bit width (otherwise it raises a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"runtime exception), and the bit-by-bit addition process produces identical results whether","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the values are interpreted as signed or unsigned. The carry behavior is the same; only the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"semantic interpretation of the result differs.","type":"SimpleText"}]}]},{"id":"api-tour","additionalIds":[],"title":"API Tour","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The following describes several key functions. See the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"documentation for","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Comb/module-type-S/index.html","isFile":false,"type":"Link","content":[{"code":"Comb.S","type":"InlinedCode"}]},{"type":"SoftLineBreak"},{"text":"for other useful functions.","type":"SimpleText"}]},{"id":"api-tour-arithmetic","additionalIds":["arithmetic"],"level":2,"title":"Arithmetic","type":"SubHeading"},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"(+:)","type":"InlinedCode"},{"text":" addition","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"(-:)","type":"InlinedCode"},{"text":" subtraction","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"Both arguments must be the same width. The result will be the width of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the arguments.","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"(*:)","type":"InlinedCode"},{"text":" unsigned multiplication","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"(*+)","type":"InlinedCode"},{"text":" signed multiplication","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"The arguments can have arbitrary widths. The result will be the sum","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"of the widths of the arguments.","type":"SimpleText"}]},{"id":"api-tour-logical","additionalIds":["logical"],"level":2,"title":"Logical","type":"SubHeading"},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"(&:)","type":"InlinedCode"},{"text":" logical and","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"(|:)","type":"InlinedCode"},{"text":" logical or","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"(^:)","type":"InlinedCode"},{"text":" logical xor","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"Both arguments must be the same width. The result will be the width of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the arguments.","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"(~:)","type":"InlinedCode"},{"text":" logical not","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"The result will be the width of the argument.","type":"SimpleText"}]},{"id":"api-tour-comparison","additionalIds":["comparison"],"level":2,"title":"Comparison","type":"SubHeading"},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"(==:)","type":"InlinedCode"},{"text":" equals","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"(<>:)","type":"InlinedCode"},{"text":" not equals","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"(<:)","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"(<=:)","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"(>:)","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"(>=:)","type":"InlinedCode"},{"text":" unsigned comparisons","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"(<+)","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"(<=+)","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"(>+)","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"(>=+)","type":"InlinedCode"},{"text":" signed comparisons","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"Both arguments must be the same width. The result will be 1 bit.","type":"SimpleText"}]},{"id":"api-tour-multiplexers","additionalIds":["multiplexers"],"level":2,"title":"Multiplexers","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"mux2 sel t f","type":"InlinedCode"},{"text":" selects ","type":"SimpleText"},{"code":"t","type":"InlinedCode"},{"text":" when ","type":"SimpleText"},{"code":"sel","type":"InlinedCode"},{"text":" is high and ","type":"SimpleText"},{"code":"f","type":"InlinedCode"},{"text":" when ","type":"SimpleText"},{"code":"sel","type":"InlinedCode"},{"text":" is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"low. ","type":"SimpleText"},{"code":"sel","type":"InlinedCode"},{"text":" should be 1 bit wide. ","type":"SimpleText"},{"code":"t","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"f","type":"InlinedCode"},{"text":" must be the same width.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"mux sel lst","type":"InlinedCode"},{"text":" selects the element in ","type":"SimpleText"},{"code":"lst","type":"InlinedCode"},{"text":" at position ","type":"SimpleText"},{"code":"sel","type":"InlinedCode"},{"text":". The range","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"of ","type":"SimpleText"},{"code":"sel","type":"InlinedCode"},{"text":" must not exceed the length of ","type":"SimpleText"},{"code":"lst","type":"InlinedCode"},{"text":". ","type":"SimpleText"},{"code":"lst","type":"InlinedCode"},{"text":" can be shorter,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"however, and the last element in the list is logically repeated as","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"much as needed.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# List.init 4 ~f:(fun sel -> mux (of_unsigned_int ~width:2 sel) [ gnd; vdd ]);;\n- : t list = [0; 1; 1; 1]","lineNumber":"","type":"Snippet"},{"id":"api-tour-cases","additionalIds":["cases"],"level":2,"title":"Cases","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"code":"cases","type":"InlinedCode"},{"text":" function is similar to a multiplexer in that it selects one of its inputs to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"output. It is given a ","type":"SimpleText"},{"code":"select","type":"InlinedCode"},{"text":" signal and each case has a corresponding ","type":"SimpleText"},{"code":"match","type":"InlinedCode"},{"text":" value.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"The first case where ","type":"SimpleText"},{"code":"select = match","type":"InlinedCode"},{"text":" is output.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let cases select =\n    cases\n        ~default:(of_unsigned_int ~width:8 10)\n        (of_unsigned_int ~width:4 select)\n        [ of_unsigned_int ~width:4 2, of_unsigned_int ~width:8 20\n        ; of_unsigned_int ~width:4 3, of_unsigned_int ~width:8 30\n        ; of_unsigned_int ~width:4 6, of_unsigned_int ~width:8 60\n        ]\n    |> to_unsigned_int\nval cases : int -> int = <fun>\n# cases 3\n- : int = 30\n# cases 6\n- : int = 60","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"If no case matches, the ","type":"SimpleText"},{"code":"default","type":"InlinedCode"},{"text":" value is output.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# cases 4\n- : int = 10","lineNumber":"","type":"Snippet"},{"id":"api-tour-select","additionalIds":["select"],"level":2,"title":"Select","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"A range of bits can be extracted from the vector using ","type":"SimpleText"},{"code":"select","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# select (of_string \"0011000\") ~high:4 ~low:3\n- : t = 11","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The upper and lower indexes are inclusive. Selecting outside the range","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"of the input value raises.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The operator ","type":"SimpleText"},{"code":"(.:[,])","type":"InlinedCode"},{"text":" provides a nice syntax for this:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# (of_string \"001100\").:[3,2]\n- : t = 11","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The operator ","type":"SimpleText"},{"code":"(.:+[, Some x])","type":"InlinedCode"},{"text":" can also be used similar to Verilog:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# (of_string \"001100\").:+[3, Some 2]\n- : t = 01","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Other selection functions include ","type":"SimpleText"},{"code":"sel_top","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"sel_bottom","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"drop_top","type":"InlinedCode"},{"text":",","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"drop_bottom","type":"InlinedCode"},{"text":" and a richer set of operators for special circumstances.","type":"SimpleText"}]},{"id":"api-tour-concatenation","additionalIds":["concatenation"],"level":2,"title":"Concatenation","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Vectors can be concatenated using the following functions.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# vdd @: gnd\n- : t = 10\n# concat_msb [ vdd; gnd ]\n- : t = 10\n# concat_lsb [ gnd; vdd ]\n- : t = 10","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The _msb and _lsb suffix in the functions indicates whether the head of the list","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"holds the most significant bit or least significant bit respectively.","type":"SimpleText"}]}]},{"id":"integer-arguments","additionalIds":[],"title":"Integer Arguments","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Various operators can take an integer as their right-hand argument.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# of_string \"011\" +:. 1\n- : t = 100","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The right-hand argument will be converted to a vector by inferring the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"required width from the left-hand argument.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Such operators are suffixed with a ","type":"SimpleText"},{"code":".","type":"InlinedCode"},{"text":".","type":"SimpleText"}]}]},{"id":"richer-operations-on-vectors","additionalIds":[],"title":"Richer Operations on Vectors","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The functions on vectors described so far form a small subset of the full API provided by","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Hardcaml. However, all the other functions are expressed in terms of this subset.","type":"SimpleText"}]},{"id":"richer-operations-on-vectors-splitting","additionalIds":["splitting"],"level":2,"title":"Splitting","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"split_lsb","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"split_msb","type":"InlinedCode"},{"text":" split a vector into multiple parts. ","type":"SimpleText"},{"code":"part_width","type":"InlinedCode"},{"text":" defines the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"width of each part. By default the original vector must be exactly divisible by","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"part_width","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# split_lsb ~part_width:4 (of_string \"16'H4321\")\n- : t list = [0001; 0010; 0011; 0100]","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# split_msb ~part_width:4 ~exact:false (of_string \"15'H4321\")\n- : t list = [1000; 0110; 0100; 001]","lineNumber":"","type":"Snippet"},{"id":"richer-operations-on-vectors-shifting","additionalIds":["shifting"],"level":2,"title":"Shifting","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"sll","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"srl","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"sra","type":"InlinedCode"},{"text":" shift a vector by a constant amount.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"rotr","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"rotl","type":"InlinedCode"},{"text":" rotate by a constant amount.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"log_shift","type":"InlinedCode"},{"text":" builds a variable width shift circuit.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# sra (of_string \"10\") ~by:1\n- : t = 11\n# log_shift (of_string \"0100\") ~f:rotl ~by:(of_string \"10\")\n- : t = 0001","lineNumber":"","type":"Snippet"},{"id":"richer-operations-on-vectors-resizing","additionalIds":["resizing"],"level":2,"title":"Resizing","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"uresize","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"sresize","type":"InlinedCode"},{"text":" resize a vector to the given width which may be larger or smaller.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"When growing larger ","type":"SimpleText"},{"code":"uresize","type":"InlinedCode"},{"text":" adds 0's at the top while ","type":"SimpleText"},{"code":"sresize","type":"InlinedCode"},{"text":" repeats the msb.","type":"SimpleText"}]},{"id":"richer-operations-on-vectors-reductions","additionalIds":["reductions"],"level":2,"title":"Reductions","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"reduce","type":"InlinedCode"},{"text":" takes a list of vectors and an operation to perform between them all.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Or reduction:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# reduce ~f:(|:) (bits_lsb (of_string \"00100\"))\n- : t = 1","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Summation","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# reduce ~f:(+:) (List.map [1;3;5;6] ~f:(of_unsigned_int ~width:6))\n- : t = 001111","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"code":"tree","type":"InlinedCode"},{"text":" does much the same thing as ","type":"SimpleText"},{"code":"reduce","type":"InlinedCode"},{"text":", except it forms the computation in a tree","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"structure. Additional, the operation it performs can take more than 2 arguments as","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"specified by an ","type":"SimpleText"},{"code":"arity","type":"InlinedCode"},{"text":" value.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# tree ~arity:4 (of_string \"111111\" |> bits_lsb)\n    ~f:(function [a] -> a\n               | [a;b] -> a &: b\n               | [a;b;c] -> a &: b &: c\n               | [a;b;c;d] -> a &: b &: c &: d\n               | _ -> failwith \"impossible\")\n- : t = 1","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We commonly use ","type":"SimpleText"},{"code":"tree","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"reduce","type":"InlinedCode"},{"text":" together.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# tree ~arity:4 (of_string \"111111\" |> bits_lsb) ~f:(reduce ~f:(&:))\n- : t = 1","lineNumber":"","type":"Snippet"},{"id":"richer-operations-on-vectors-with_valid","additionalIds":["with_valid"],"level":2,"title":"With_valid","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"With_valid","type":"InlinedCode"},{"text":" is a record type with a 1 bit ","type":"SimpleText"},{"code":"valid","type":"InlinedCode"},{"text":" signal and an arbitrary ","type":"SimpleText"},{"code":"value","type":"InlinedCode"},{"text":" signal.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"It is meant to work a little like an Option type where ","type":"SimpleText"},{"code":"valid=0","type":"InlinedCode"},{"text":" means ","type":"SimpleText"},{"code":"None ","type":"InlinedCode"},{"text":"and","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"valid=1","type":"InlinedCode"},{"text":" means ","type":"SimpleText"},{"code":"Some value","type":"InlinedCode"}]},{"id":"richer-operations-on-vectors-priority-based-selectors","additionalIds":["priority-based-selectors"],"level":2,"title":"Priority based selectors","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"priority_select","type":"InlinedCode"},{"text":" takes a list of ","type":"SimpleText"},{"code":"With_valids","type":"InlinedCode"},{"text":" and returns the first one whose ","type":"SimpleText"},{"code":"valid","type":"InlinedCode"},{"text":" is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"high. It returns a single ","type":"SimpleText"},{"code":"With_valid","type":"InlinedCode"},{"text":" whose valid is low if no case was selected.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"priority_select_with_default","type":"InlinedCode"},{"text":" adds a default value which is output if no case is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"selected.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# priority_select_with_default \n    ~default:(of_string \"1111\") \n    [ { valid = gnd; value = of_string \"0001\" }\n    ; { valid = gnd; value = of_string \"0100\" }\n    ]\n- : t = 1111\n# priority_select_with_default \n    ~default:(of_string \"1111\") \n    [ { valid = vdd; value = of_string \"0001\" }\n    ; { valid = vdd; value = of_string \"0100\" }\n    ]\n- : t = 0001","lineNumber":"","type":"Snippet"},{"id":"richer-operations-on-vectors-counting-bits","additionalIds":["counting-bits"],"level":2,"title":"Counting bits","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"popcount","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"leading_zeros","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"leading_ones","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"trailing_zeros","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"trailing_ones","type":"InlinedCode"},{"text":" all count","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"some number of bits within a vector. Their implementations are tree based and have ","type":"SimpleText"},{"code":"log width","type":"InlinedCode"},{"text":" logic depth.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# popcount (of_string \"1100011\")\n- : t = 100\n# trailing_zeros (of_string \"1110010100\")\n- : t = 0010","lineNumber":"","type":"Snippet"},{"id":"richer-operations-on-vectors-onehot-and-gray","additionalIds":["onehot-and-gray"],"level":2,"title":"Onehot and Gray","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"binary_to_onehot","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"onehot_to_binary","type":"InlinedCode"},{"text":" convert between onehot and binary","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"representations.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Similarly for ","type":"SimpleText"},{"code":"gray_to_binary","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"binary_to_gray","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# binary_to_onehot (of_string \"110\")\n- : t = 01000000\n# onehot_to_binary (of_string \"01000\")\n- : t = 011\n# binary_to_gray (of_string \"110\")\n- : t = 101\n# gray_to_binary (of_string \"01000\")\n- : t = 01111","lineNumber":"","type":"Snippet"},{"id":"richer-operations-on-vectors-random","additionalIds":["random"],"level":2,"title":"Random","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"random","type":"InlinedCode"},{"text":" creates a random constant vector of the given width. Mostly useful for","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"testbenches.","type":"SimpleText"}]},{"id":"richer-operations-on-vectors-bits-set","additionalIds":["bits-set"],"level":2,"title":"Bits set","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"any_bits_set","type":"InlinedCode"},{"text":" is equivalent to ","type":"SimpleText"},{"code":"x <>:. 0","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"all_bits_set","type":"InlinedCode"},{"text":"is equivalent to ","type":"SimpleText"},{"code":"x ==:. (-1)","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"no_bits_set","type":"InlinedCode"},{"text":" is equivalent to ","type":"SimpleText"},{"code":"x ==:. 0","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"id":"richer-operations-on-vectors-with_zero_width","additionalIds":["with_zero_width"],"level":2,"title":"With_zero_width","headingContent":[{"code":"With_zero_width","type":"InlinedCode"}],"type":"SubHeading"},{"type":"Paragraph","content":[{"text":"We disallow zero width vectors in Hardcaml. ","type":"SimpleText"},{"code":"With_zero_width","type":"InlinedCode"},{"text":" allows us to represent them.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"The type is ","type":"SimpleText"},{"code":"Comb.t option","type":"InlinedCode"},{"text":" where ","type":"SimpleText"},{"code":"None","type":"InlinedCode"},{"text":" indicates zero width.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The functions provided try to do sane things with zero width vectors.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# With_zero_width.(concat_msb [ None; ones 2; zero 0; zero 1; Some (of_string \"1101\") ])\n- : With_zero_width.t = Base.Option.Some 1101101","lineNumber":"","type":"Snippet"},{"id":"richer-operations-on-vectors-typedmath","additionalIds":["typedmath"],"level":2,"title":"TypedMath","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"Unsigned","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"Signed","type":"InlinedCode"},{"text":" are modules with signature ","type":"SimpleText"},{"code":"TypedMath","type":"InlinedCode"},{"text":". They provide arithmetic","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"and comparison operators. Since they know the signedness of the type, they can, for","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"example, add or compare vectors of different widths.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Additionally, addition and subtraction grow their result width by one bit to ensure","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"overflow is impossible. This extra bit captures the carry that might result from the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"operation.","type":"SimpleText"}]}]}],"lastModifiedTime":1750709443497,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.1 Combinational Logic","pageMeta":{"parent":["designing_circuits.mdx"],"title":["2.1 Combinational Logic"],"uuid":["c7e1f2e0-5606-347e-65e3-382d91c00c2f"]},"dirName":"designing-circuits","fileName":"combinational_logic","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Vectors and Widths","id":"vectors-and-widths","customAnchorId":"vectors-and-widths"},{"title":"Binary Constants and Converting to OCaml Ints","id":"binary-constants-and-converting-to-ocaml-ints","customAnchorId":"binary-constants-and-converting-to-ocaml-ints"},{"title":"Richer Constants","id":"richer-constants","customAnchorId":"richer-constants"},{"title":"Operators, Widths, and Their Names","id":"operators-widths-and-their-names","customAnchorId":"operators-widths-and-their-names"},{"title":"API Tour","id":"api-tour","customAnchorId":"api-tour"},{"title":"Integer Arguments","id":"integer-arguments","customAnchorId":"integer-arguments"},{"title":"Richer Operations on Vectors","id":"richer-operations-on-vectors","customAnchorId":"richer-operations-on-vectors"}]}},{"type":"Page","content":[{"id":"rom","additionalIds":[],"title":"Rom","type":"Section","content":[{"type":"Paragraph","content":[{"text":"8 entry ROM.  Outputs the address times 10.","type":"SimpleText"}]},{"id":"rom-verilog","additionalIds":["verilog"],"level":2,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module rom (\n  input [2:0] address,\n  output reg [6:0] q\n);\n\n  always @* begin\n    case (address)\n      3'd0: q <= 7'd0;\n      3'd1: q <= 7'd10;\n      3'd2: q <= 7'd20;\n      3'd3: q <= 7'd30;\n      3'd4: q <= 7'd40;\n      3'd5: q <= 7'd50;\n      3'd6: q <= 7'd60;\n      default: q <= 7'd70;\n    endcase\n  end\n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"rom-vhdl","additionalIds":["vhdl"],"level":2,"title":"VHDL","type":"SubHeading"},{"lang":"vhdl","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity rom is\n  port (\n    address : in std_logic_vector(2 downto 0);\n    q : out std_logic_vector(6 downto 0)\n  );\nend entity;\n\narchitecture rtl of rom is\n  type rom_t is array (0 to 7) of integer;\n  constant rom : rom_t := (0,10,20,30,40,50,60,70);\nbegin\n\n  q <= std_logic_vector(to_unsigned(rom(to_integer(unsigned(address))), q'length));\n\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"rom-hardcaml","additionalIds":["hardcaml"],"level":2,"title":"Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"let rom ~address =\n  mux address (List.init 8 ~f:(fun i -> of_unsigned_int ~width:7 (i * 10)))\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709443089,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.1.1 ROM","pageMeta":{"parent":["combinational_logic.mdx"],"title":["2.1.1 ROM"],"uuid":["1314caa7-4615-3549-13c8-6b1397c65c93"]},"dirName":"designing-circuits","fileName":"rom","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Rom","id":"rom","customAnchorId":"rom"}]}},{"type":"Page","content":[{"id":"mux-4-to-1","additionalIds":[],"title":"Mux 4 to 1","type":"Section","content":[{"type":"Paragraph","content":[{"text":"4 input multiplexer.","type":"SimpleText"}]},{"id":"mux-4-to-1-verilog","additionalIds":["verilog"],"level":2,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module mux4 (\n  input [1:0] address,\n  input [7:0] a, b, c, d,\n  output reg [7:0] q\n);\n   always @* begin\n      case (address)\n        3'd0: q <= a;\n        3'd1: q <= b;\n        3'd2: q <= c;\n        default: q <= d;\n      endcase\n   end\n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"mux-4-to-1-vhdl","additionalIds":["vhdl"],"level":2,"title":"VHDL","type":"SubHeading"},{"lang":"vhdl","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity mux4 is\n  port (\n    address : in std_logic_vector(1 downto 0);\n    a, b, c, d : in std_logic_vector(7 downto 0);\n    q : out std_logic_vector(7 downto 0)\n  );\nend entity;\n\narchitecture rtl of mux4 is\n  signal q_int : std_logic_vector(7 downto 0);\nbegin\n\n  q <= q_int;\n\n  process (address, a, b, c, d) is \n  begin\n    case to_integer(unsigned(address)) is\n      when 0 => q_int <= a;\n      when 1 => q_int <= b;\n      when 2 => q_int <= c;\n      when others => q_int <= d;\n    end case;\n  end process;\n\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"mux-4-to-1-hardcaml","additionalIds":["hardcaml"],"level":2,"title":"Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"let mux4 ~address ~a ~b ~c ~d = mux address [ a; b; c; d ]","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709444496,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.1.2 Mux4","pageMeta":{"parent":["combinational_logic.mdx"],"title":["2.1.2 Mux4"],"uuid":["c8aa673f-615d-3ba3-2bf5-b10deabfd403"]},"dirName":"designing-circuits","fileName":"mux4","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Mux 4 to 1","id":"mux-4-to-1","customAnchorId":"mux-4-to-1"}]}},{"type":"Page","content":[{"id":"priority-encoder","additionalIds":[],"title":"Priority Encoder","type":"Section","content":[{"id":"priority-encoder-verilog","additionalIds":["verilog"],"level":2,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module priority_encoder (\n  input [3:0] sel,\n  input [7:0] a, b, c, d,\n  output reg [7:0] q\n);\n\n  always @* begin\n    if (sel[3]) q <= d;\n    else if (sel[2]) q <= c;\n    else if (sel[1]) q <= b;\n    else q <= a;\n  end\n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"priority-encoder-vhdl","additionalIds":["vhdl"],"level":2,"title":"VHDL","type":"SubHeading"},{"lang":"vhdl","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\n\nentity priority_encoder is\n  port (\n    sel : in std_logic_vector(3 downto 0);\n    a, b, c, d : in std_logic_vector(7 downto 0);\n    q : out std_logic_vector(7 downto 0)\n  );\nend entity;\n\narchitecture rtl of priority_encoder is\nbegin\n\n  q <= d when sel(3) = '1' else\n       c when sel(2) = '1' else \n       b when sel(1) = '1' else\n       a;\n\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"priority-encoder-hardcaml","additionalIds":["hardcaml"],"level":2,"title":"Hardcaml","type":"SubHeading"},{"id":"priority-encoder-hardcaml-direct-translation","additionalIds":["direct-translation"],"level":3,"title":"Direct translation","type":"SubHeading"},{"lang":"ocaml","snippet":"let priority_encoder_1 ~sel ~a ~b ~c ~d =\n  let out = Always.Variable.wire ~default:(zero 8) () in\n  Always.(\n    compile\n      [ if_ sel.:(3) [ out <-- d ]\n        @@ elif sel.:(2) [ out <-- c ]\n        @@ elif sel.:(1) [ out <-- b ]\n        @@ [ out <-- a ]\n      ]);\n  out.value\n;;","lineNumber":"","type":"Snippet"},{"id":"priority-encoder-hardcaml-idiomatic-hardcaml","additionalIds":["idiomatic-hardcaml"],"level":3,"title":"Idiomatic Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"let priority_encoder_2 ~sel ~a ~b ~c ~d =\n  priority_select_with_default\n    ~default:a\n    With_valid.\n      [ { valid = sel.:(3); value = d }\n      ; { valid = sel.:(2); value = c }\n      ; { valid = sel.:(1); value = b }\n      ]\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709442906,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.1.3 Priority Encoder","pageMeta":{"parent":["combinational_logic.mdx"],"title":["2.1.3 Priority Encoder"],"uuid":["765a2517-4523-3fe6-662f-1db88cd67471"]},"dirName":"designing-circuits","fileName":"priority_encoder","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Priority Encoder","id":"priority-encoder","customAnchorId":"priority-encoder"}]}},{"type":"Page","content":[{"id":"parity","additionalIds":[],"title":"Parity","type":"Section","content":[{"type":"Paragraph","content":[{"text":"This module calculates odd parity for a 4-bit input. Given a 4-bit input ","type":"SimpleText"},{"code":"d","type":"InlinedCode"},{"text":", it","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"outputs ","type":"SimpleText"},{"code":"1","type":"InlinedCode"},{"text":" if it contains an odd number of ","type":"SimpleText"},{"code":"1","type":"InlinedCode"},{"text":"s, and ","type":"SimpleText"},{"code":"0","type":"InlinedCode"},{"text":" otherwise.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Implemented by XORing all the bits together.","type":"SimpleText"}]},{"id":"parity-verilog","additionalIds":["verilog"],"level":2,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module parity (\n  input [3:0] d,\n  output q\n);\n\n  assign q = ^d;\n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"parity-vhdl","additionalIds":["vhdl"],"level":2,"title":"VHDL","type":"SubHeading"},{"lang":"vhdl","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity parity is\n  port (\n    d : in std_logic_vector(3 downto 0);\n    q : out std_logic\n  );\nend entity;\n\narchitecture rtl of parity is\nbegin\n\n  process (d) is \n    variable parity : std_logic;\n  begin\n    parity := '0';\n    for i in d'range loop\n      parity := parity xor d(i);\n    end loop;\n    q <= parity;\n  end process;\n\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"parity-hardcaml","additionalIds":["hardcaml"],"level":2,"title":"Hardcaml","type":"SubHeading"},{"id":"parity-hardcaml-direct-translation-of-verilog","additionalIds":["direct-translation-of-verilog"],"level":3,"title":"Direct translation of Verilog","type":"SubHeading"},{"lang":"ocaml","snippet":"let parity_1 ~d = reduce (bits_lsb d) ~f:( ^: )","lineNumber":"","type":"Snippet"},{"id":"parity-hardcaml-direct-translation-of-vhdl","additionalIds":["direct-translation-of-vhdl"],"level":3,"title":"Direct translation of Vhdl","type":"SubHeading"},{"lang":"ocaml","snippet":"let parity_2 ~d =\n  let parity = ref gnd in\n  for i = 0 to width d - 1 do\n    parity := !parity ^: d.:(i)\n  done;\n  !parity\n;;","lineNumber":"","type":"Snippet"},{"id":"parity-hardcaml-idiomatic-hardcaml","additionalIds":["idiomatic-hardcaml"],"level":3,"title":"Idiomatic Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"let parity_3 ~d = tree ~arity:2 (bits_lsb d) ~f:(reduce ~f:( ^: ))","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"When performing reductions in Hardcaml, we will often use the tree function. This","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"rearranges the computation from:","type":"SimpleText"}]},{"lang":"","snippet":"(((a ^ b) ^ c) ^ d)","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"into:","type":"SimpleText"}]},{"lang":"","snippet":"((a ^ b) ^ (c ^ d))","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709442889,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.1.4 Parity","pageMeta":{"parent":["combinational_logic.mdx"],"title":["2.1.4 Parity"],"uuid":["d2540449-6e8a-38f5-118e-2abbcf209f9f"]},"dirName":"designing-circuits","fileName":"parity","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Parity","id":"parity","customAnchorId":"parity"}]}},{"type":"Page","content":[{"id":"a-simple-8-bit-alu","additionalIds":[],"title":"A Simple 8-bit ALU","type":"Section","content":[{"type":"Paragraph","content":[{"text":"A simple arithmetic logic unit. It takes two 8-bit operands ","type":"SimpleText"},{"code":"A","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"B","type":"InlinedCode"},{"text":" and computes an","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"8-bit output ","type":"SimpleText"},{"code":"q","type":"InlinedCode"},{"text":" according to the value of the operation select signal ","type":"SimpleText"},{"code":"op","type":"InlinedCode"},{"text":" as described in","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the table below:","type":"SimpleText"}]},{"table":{"columns":[{"title":"op","align":"left"},{"title":"fn","align":"left"}],"data":[[[{"text":"0","type":"SimpleText"}],[{"text":"A AND B","type":"SimpleText"}]],[[{"text":"1","type":"SimpleText"}],[{"text":"A SUB B","type":"SimpleText"}]],[[{"text":"2","type":"SimpleText"}],[{"text":"A MUL B","type":"SimpleText"}]],[[{"text":"3","type":"SimpleText"}],[{"text":"A SHIFTLEFT 1","type":"SimpleText"}]],[[{"text":"4","type":"SimpleText"}],[{"text":"A SHIFTRIGHT 1","type":"SimpleText"}]],[[{"text":"5","type":"SimpleText"}],[{"text":"A AND B","type":"SimpleText"}]],[[{"text":"6","type":"SimpleText"}],[{"text":"A OR B","type":"SimpleText"}]],[[{"text":"7","type":"SimpleText"}],[{"text":"A XOR B","type":"SimpleText"}]],[[{"text":"8","type":"SimpleText"}],[{"text":"NOT A","type":"SimpleText"}]],[[{"text":"9","type":"SimpleText"}],[{"text":"1 if A LESSTHAN B else 0","type":"SimpleText"}]],[[{"text":"10","type":"SimpleText"}],[{"text":"1 if A EQUAL B else 0","type":"SimpleText"}]],[[{"text":"otherwise","type":"SimpleText"}],[{"text":"0","type":"SimpleText"}]]]},"type":"Table"},{"id":"a-simple-8-bit-alu-verilog","additionalIds":["verilog"],"level":2,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module alu (\n  input [3:0] op,\n  input [7:0] a, b,\n  output reg [7:0] q\n);\n\nalways @* begin\n    case (op)\n      0: q <= a + b;\n      1: q <= a - b;\n      2: q <= a * b;\n      3: q <= a << 1;\n      4: q <= a >> 1;\n      5: q <= a & b;\n      6: q <= a | b;\n      7: q <= a ^ b;\n      8: q <= ~a;\n      9: q <= a < b;\n      10: q <= a == b;\n      default: q <= 0;\n    endcase\n  end\n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"a-simple-8-bit-alu-vhdl","additionalIds":["vhdl"],"level":2,"title":"VHDL","type":"SubHeading"},{"lang":"vhdl","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity alu is\n  port (\n    op : in std_logic_vector(3 downto 0);\n    a, b : in std_logic_vector(7 downto 0);\n    q : out std_logic_vector(7 downto 0)\n  );\nend entity;\n\narchitecture rtl of alu is\n  signal q_int : std_logic_vector(7 downto 0);\nbegin\n\n  process (op, a, b) is\n    variable mul : std_logic_vector(15 downto 0);\n  begin\n    case to_integer(unsigned(op)) is\n      when 0 => q_int <= std_logic_vector(unsigned(a) + unsigned(b));\n      when 1 => q_int <= std_logic_vector(unsigned(a) - unsigned(b));\n      when 2 => \n        mul := std_logic_vector(unsigned(a) * unsigned(b));\n        q_int <= mul(7 downto 0);\n      when 3 => q_int <= std_logic_vector(shift_left(unsigned(a), 1));\n      when 4 => q_int <= std_logic_vector(shift_right(unsigned(a), 1));\n      when 5 => q_int <= a and b;\n      when 6 => q_int <= a or b;\n      when 7 => q_int <= a xor b;\n      when 8 => q_int <= not a;\n      when 9 => \n        if unsigned(a) < unsigned(b) then\n          q_int <= \"00000001\";\n        else\n          q_int <= \"00000000\";\n        end if;\n      when 10 =>\n        if a = b then\n          q_int <= \"00000001\";\n        else\n          q_int <= \"00000000\";\n        end if;\n      when others => q_int <= (others => '0');\n    end case;\n  end process;\n\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"a-simple-8-bit-alu-hardcaml","additionalIds":["hardcaml"],"level":2,"title":"Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"let alu ~op ~a ~b =\n  mux\n    op\n    ([ a +: b\n     ; a -: b\n     ; a *: b\n     ; sll a ~by:1\n     ; srl a ~by:1\n     ; a &: b\n     ; a |: b\n     ; a ^: b\n     ; ~:a\n     ; a <: b\n     ; a ==: b\n     ; zero 8\n     ]\n     |> List.map ~f:(uresize ~width:8))\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709442923,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.1.5 ALU","pageMeta":{"parent":["combinational_logic.mdx"],"title":["2.1.5 ALU"],"uuid":["918f1070-0018-3261-d4d6-2bfa014130af"]},"dirName":"designing-circuits","fileName":"alu","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"A Simple 8-bit ALU","id":"a-simple-8-bit-alu","customAnchorId":"a-simple-8-bit-alu"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"Sequential logic is built from primitives such as registers and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"memories.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"A key concept in sequential logic is the ","type":"SimpleText"},{"code":"clock","type":"InlinedCode"},{"text":". Sequential logic","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"updates on the rising (or, less commonly, falling) edge of the clock and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"holds its value throughout the clock cycle.","type":"SimpleText"}]},{"id":"reg_spec","additionalIds":[],"title":"Reg_spec","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The clock and related reset and clear signals are grouped together in","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"a type called a ","type":"SimpleText"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Reg_spec/index.html","isFile":false,"type":"Link","content":[{"code":"Reg_spec.t","type":"InlinedCode"}]},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# open Hardcaml\n# let clock = Signal.input \"clock\" 1\nval clock : Signal.t = (wire (names (clock)) (width 1))\n# let clear = Signal.input \"clear\" 1\nval clear : Signal.t = (wire (names (clear)) (width 1))\n# let spec = Signal.Reg_spec.create ~clock ~clear ()\nval spec : Signal.Reg_spec.t = <abstr>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Multiple sequential elements are then able to refer to the same","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Reg_spec.t","type":"InlinedCode"},{"text":".","type":"SimpleText"}]}]},{"id":"registers-pipelines","additionalIds":[],"title":"Registers, Pipelines","type":"Section","content":[{"type":"Paragraph","content":[{"text":"A simple register takes a signal as input and basically delays it for one cycle.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let d_in = Signal.input \"d_in\" 8\nval d_in : Signal.t = (wire (names (d_in)) (width 8))\n# let q_out = Signal.reg spec ~enable:Signal.vdd d_in\nval q_out : Signal.t =\n  (register (width 8)\n ((clock clock) (clock_edge Rising) (clear clear) (clear_to 0b00000000))\n (data_in d_in))","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The pipeline function will delay its input for multiple cycles.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let q_out_after_3_clocks = Signal.pipeline spec ~enable:Signal.vdd ~n:3 d_in\nval q_out_after_3_clocks : Signal.t =\n  (register (width 8)\n ((clock clock) (clock_edge Rising) (clear clear) (clear_to 0b00000000))\n (data_in register))","lineNumber":"","type":"Snippet"}]},{"id":"registers-with-feedback","additionalIds":[],"title":"Registers with Feedback","type":"Section","content":[{"type":"Paragraph","content":[{"text":"We noted ","type":"SimpleText"},{"url":"/hardcaml-docs/designing-circuits/combinational_logic","isFile":false,"type":"Link","content":[{"text":"previously","type":"SimpleText"}]},{"text":" that combinational","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"logic could not contain cycles.  We can lift this restriction with","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"sequential logic so long as the cycle passes through a register (or memory).","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The function ","type":"SimpleText"},{"code":"reg_fb","type":"InlinedCode"},{"text":" encodes a simple example of this pattern. For","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"example, to build a counter, we need to access the current value to produce","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the next one.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let counter = Signal.reg_fb spec ~enable:Signal.vdd  ~width:8 ~f:(fun d -> Signal.(d +:. 1))\nval counter : Signal.t =\n  (register (width 8)\n ((clock clock) (clock_edge Rising) (clear clear) (clear_to 0b00000000))\n (data_in wire))","lineNumber":"","type":"Snippet"}]},{"id":"wires","additionalIds":[],"title":"Wires","type":"Section","content":[{"type":"Paragraph","content":[{"text":"In Hardcaml a ","type":"SimpleText"},{"code":"wire","type":"InlinedCode"},{"text":" is a signal which can be declared before","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"providing its input driver. Logically, it does nothing - it just","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"passes its input through to its output.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let w = Signal.wire 1;;\nval w : Signal.t = (wire (width 1))","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Wires can later be assigned an input driver.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# Signal.(w <-- vdd);;\n- : unit = ()\n# w;;\n- : Signal.t = (wire (width 1) (data_in 0b1))","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Apart from the fact they logically do nothing, they are really useful!","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"It is how the ","type":"SimpleText"},{"code":"reg_fb","type":"InlinedCode"},{"text":" function is implemented.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let reg_fb spec ~enable ~w f =\n    let d = Signal.wire w in\n    let q = Signal.reg spec ~enable (f d) in\n    Signal.(d <-- q);\n    q\nval reg_fb :\n  Signal.Reg_spec.t ->\n  enable:Signal.t -> w:int -> (Signal.t -> Signal.t) -> Signal.t = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Without wires we cannot express the above function since the input","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"to ","type":"SimpleText"},{"code":"reg","type":"InlinedCode"},{"text":" refers to its own output.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Two words of caution when using wires.","type":"SimpleText"}]},{"delimiter":".","startNumber":1,"type":"OrderedList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Combinational cycles! We can't stop you from creating them, but we can","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"throw an exception when you do. It's worth repeating - cycles must","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"pass through a sequential primitive.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"The hairy unassigned wire exception. Hardcaml will detect when you","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"forget to assign a value to a wire, but the error will not be","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"especially useful in finding out where. You can","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"enable an extra level of debugging information by setting the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"following ","type":"SimpleText"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Caller_id/index.html","isFile":false,"type":"Link","content":[{"text":"value","type":"SimpleText"}]},{"text":",","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"which will help track down where the wire was originally defined.","type":"SimpleText"}]}]}]},{"lang":"","snippet":"Caller_id.set_mode Top_of_stack","lineNumber":"","type":"Snippet"}]},{"id":"state-machines","additionalIds":[],"title":"State Machines","type":"Section","content":[{"type":"Paragraph","content":[{"text":"State machines are just a complex combination of registers and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"multiplexers, so it is possible to build them directly with the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"primitives described here - but not very conveniently. Rather, we","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"recommend using the ","type":"SimpleText"},{"url":"/hardcaml-docs/more-on-circuit-design/always","isFile":false,"type":"Link","content":[{"text":"Always DSL","type":"SimpleText"}]},{"text":".","type":"SimpleText"}]}]},{"id":"memories","additionalIds":[],"title":"Memories","type":"Section","content":[{"id":"memories-core-asynchronous-memory-primitive","additionalIds":["core-asynchronous-memory-primitive"],"level":2,"title":"Core asynchronous memory primitive","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Hardcaml provides the ","type":"SimpleText"},{"code":"multiport_memory","type":"InlinedCode"},{"text":" primitive for describing","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"memory structures.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"They are synchronously written using ","type":"SimpleText"},{"code":"write_ports","type":"InlinedCode"},{"text":". Each write port","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"can have a different clock.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let clock = Signal.input \"clock\" 1;;\nlet address = Signal.input \"address\" 8;;\nlet write_enable = Signal.input \"write_enable\" 1;;\nlet data = Signal.input \"data\" 32;;","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# let write_port =\n    { Write_port.write_clock = clock\n    ; write_address = address\n    ; write_enable = write_enable\n    ; write_data = data }\nval write_port : Signal.t Write_port.t =\n  {Hardcaml.Write_port.write_clock = (wire (names (clock)) (width 1));\n   write_address = (wire (names (address)) (width 8));\n   write_enable = (wire (names (write_enable)) (width 1));\n   write_data = (wire (names (data)) (width 32))}","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The memory is read asynchronously using ","type":"SimpleText"},{"code":"read_addresses","type":"InlinedCode"},{"text":". The read data","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"is returned as an array, one for each read port.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let read_address = address\nval read_address : Signal.t = (wire (names (address)) (width 8))\n# let q =\n    Signal.multiport_memory\n      256\n      ~write_ports:[|write_port|]\n      ~read_addresses:[|read_address|]\nval q : Signal.t array =\n  [|(memory_read_port (width 32)\n ((memory multiport_memory) (read_addresses address)))|]","lineNumber":"","type":"Snippet"},{"id":"memories-rams","additionalIds":["rams"],"level":2,"title":"RAMs","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"On their own, ","type":"SimpleText"},{"code":"multiport_memory","type":"InlinedCode"},{"text":"s are not that useful. Instead, we","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"provide the ","type":"SimpleText"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Ram/index.html","isFile":false,"type":"Link","content":[{"code":"Ram","type":"InlinedCode"}]},{"type":"SoftLineBreak"},{"text":"module, which can target the physical RAM blocks in","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"FPGAs (i.e. BlockRAM or UltraRAM in Xilinx devices).","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"This is done by instantiating a multiport_memory and a register placed","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"on either the read address or output data. Note that this means the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"read ports are now synchronous and read data is returned one cycle","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"later.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let read_port =\n    { Read_port.read_clock = clock\n    ; read_address\n    ; read_enable = Signal.input \"read_enable\" 1 }\nval read_port : Signal.t Read_port.t =\n  {Hardcaml.Read_port.read_clock = (wire (names (clock)) (width 1));\n   read_address = (wire (names (address)) (width 8));\n   read_enable = (wire (names (read_enable)) (width 1))}","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Each read port can have a different clock.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let q =\n    Ram.create\n      ~collision_mode:Read_before_write\n      ~size:256\n      ~write_ports:[|write_port|]\n      ~read_ports:[|read_port|]\n      ()\nval q : Signal.t array =\n  [|(register (width 32) ((clock clock) (clock_edge Rising) (enable read_enable))\n (data_in memory_read_port))|]","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"For this to work we use a feature of FPGA synthesizers called RTL RAM","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"inference. This process is notoriously finicky, so read the tool","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"reports to ensure it is doing what you expect (I'm looking at you,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Vivado!).","type":"SimpleText"}]},{"id":"memories-practical-considerations","additionalIds":["practical-considerations"],"level":2,"title":"Practical considerations","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The RAM structures provided with Hardcaml are very flexible regarding","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the number of read and write ports they can provide. Physically,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"however, FPGAs provide RAMs with 1 or 2 ports. If you specify more","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"than this, you will probably not get the results you intended.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"url":"https://github.com/janestreet/hardcaml_xilinx","isFile":false,"type":"Link","content":[{"code":"hardcaml_xilinx","type":"InlinedCode"}]},{"type":"SoftLineBreak"},{"text":"library offers a more targeted solution for Xilinx FPGAs and may be","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"more suitable for applications where precise control of the Vendor RAM","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"primitive is required.","type":"SimpleText"}]}]}],"lastModifiedTime":1750709443501,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.2 Sequential Logic","pageMeta":{"parent":["designing_circuits.mdx"],"title":["2.2 Sequential Logic"],"uuid":["a7b1145b-f22e-343d-f4df-c564df972017"]},"dirName":"designing-circuits","fileName":"sequential_logic","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Reg_spec","id":"reg_spec","customAnchorId":"reg_spec"},{"title":"Registers, Pipelines","id":"registers-pipelines","customAnchorId":"registers-pipelines"},{"title":"Registers with Feedback","id":"registers-with-feedback","customAnchorId":"registers-with-feedback"},{"title":"Wires","id":"wires","customAnchorId":"wires"},{"title":"State Machines","id":"state-machines","customAnchorId":"state-machines"},{"title":"Memories","id":"memories","customAnchorId":"memories"}]}},{"type":"Page","content":[{"id":"jk-flip-flop","additionalIds":[],"title":"JK Flip Flop","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The JK flip-flop is a basic sequential element with two inputs (","type":"SimpleText"},{"code":"j","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"k","type":"InlinedCode"},{"text":") that control its","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"behavior:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Hold Mode: Maintains the current output value when j=0, k=0","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Set Mode: Sets the output value to 1 when j=1, k=0","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Reset Mode: Sets the output value to 0 when j=0, k=1","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Toggle Mode: Inverts the current output value when j=1, k=1","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"The flip-flop updates its state on the rising edge of the clock.","type":"SimpleText"}]},{"id":"jk-flip-flop-verilog","additionalIds":["verilog"],"level":2,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module jk_flip_flop (\n  input clock, j, k,\n  output reg q\n);\n\n  always @(posedge clock) begin\n    case ({j,k})\n      2'b00: q <= q;\n      2'b01: q <= 1'b0;\n      2'b10: q <= 1'b1;\n      2'b11: q <= ~q;\n    endcase\n  end\n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"jk-flip-flop-vhdl","additionalIds":["vhdl"],"level":2,"title":"VHDL","type":"SubHeading"},{"lang":"vhdl","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\n\nentity jk_flip_flop is\n  port (\n    clock, j, k : in std_logic;\n    q : out std_logic\n  );\nend entity;\n\narchitecture rtl of jk_flip_flop is\n  signal q_int : std_logic;\n  signal jk : std_logic_vector(1 downto 0);\nbegin\n\n  jk <= j & k;\n  q <= q_int;\n\n  process (clock) is\n  begin\n    if rising_edge(clock) then\n      case jk is\n        when \"01\" => q_int <= '0';\n        when \"10\" => q_int <= '1';\n        when \"11\" => q_int <= not q_int;\n        when others => null;\n      end case;\n    end if;\n  end process;\n\n\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"jk-flip-flop-hardcaml","additionalIds":["hardcaml"],"level":2,"title":"Hardcaml","type":"SubHeading"},{"id":"jk-flip-flop-hardcaml-direct-translation","additionalIds":["direct-translation"],"level":3,"title":"Direct translation","type":"SubHeading"},{"lang":"ocaml","snippet":"let jk_flip_flop_1 ~clock ~j ~k =\n  let q = Always.Variable.reg (Reg_spec.create ~clock ()) ~width:1 in\n  Always.(\n    compile\n      [ switch\n          (j @: k)\n          [ of_string \"00\", [ q <-- q.value ]\n          ; of_string \"01\", [ q <-- gnd ]\n          ; of_string \"10\", [ q <-- vdd ]\n          ; of_string \"11\", [ q <-- ~:(q.value) ]\n          ]\n      ]);\n  q.value\n;;","lineNumber":"","type":"Snippet"},{"id":"jk-flip-flop-hardcaml-idiomatic-hardcaml","additionalIds":["idiomatic-hardcaml"],"level":3,"title":"Idiomatic Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"let jk_flip_flop_2 ~clock ~j ~k =\n  reg_fb (Reg_spec.create ~clock ()) ~width:1 ~f:(fun q ->\n    mux (j @: k) [ q; gnd; vdd; ~:q ])\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709444640,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.2.1 JK Flip Flop","pageMeta":{"parent":["sequential_logic.mdx"],"title":["2.2.1 JK Flip Flop"],"uuid":["9ec701d4-e716-3da1-06aa-d86a11bd163c"]},"dirName":"designing-circuits","fileName":"jk_flip_flop","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"JK Flip Flop","id":"jk-flip-flop","customAnchorId":"jk-flip-flop"}]}},{"type":"Page","content":[{"id":"t-flip-flop","additionalIds":[],"title":"T Flip Flop","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The T (Toggle) flip-flop changes state based on a single control input ","type":"SimpleText"},{"code":"t","type":"InlinedCode"},{"text":":","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"When t=0: Maintains current output state","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"When t=1: Toggles (inverts) the current output state","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"The flip-flop updates only on the rising edge of the clock signal. This implementation","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"includes an active low asynchronous reset, which means:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"When reset=0: Output is forced to 0 immediately, regardless of clock","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"When reset=1: Normal operation based on ","type":"SimpleText"},{"code":"t","type":"InlinedCode"},{"text":" input","type":"SimpleText"}]}]}]},{"id":"t-flip-flop-verilog","additionalIds":["verilog"],"level":2,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module t_flip_flop (\n  input clock, reset_n, t,\n  output reg q\n);\n\n  always @(posedge clock, negedge reset_n) begin\n    if (!reset_n)\n      q <= 1'b0;\n    else if (t)\n      q <= ~q;\n  end\n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"t-flip-flop-vhdl","additionalIds":["vhdl"],"level":2,"title":"VHDL","type":"SubHeading"},{"lang":"vhdl","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\n\nentity t_flip_flop is\n  port (\n    clock, reset_n, t : in std_logic;\n    q : out std_logic\n  );\nend entity;\n\narchitecture rtl of t_flip_flop is \n  signal q_int : std_logic;\nbegin\n\n  q <= q_int;\n  \n  process (clock, reset_n) begin\n    if reset_n = '0' then \n      q_int <= '0';\n    elsif rising_edge(clock) then\n      if t = '1' then\n        q_int <= not q_int;\n      end if;\n    end if;\n  end process;\n\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"t-flip-flop-hardcaml","additionalIds":["hardcaml"],"level":2,"title":"Hardcaml","type":"SubHeading"},{"id":"t-flip-flop-hardcaml-direct-translation","additionalIds":["direct-translation"],"level":3,"title":"Direct translation","type":"SubHeading"},{"lang":"ocaml","snippet":"let t_flip_flop_1 ~clock ~reset_n ~t =\n  let q =\n    Always.Variable.reg\n      (Reg_spec.create ~clock ~reset:reset_n ~reset_edge:Falling ())\n      ~width:1\n  in\n  Always.(compile [ if_ t [ q <-- ~:(q.value) ] [ q <-- q.value ] ]);\n  q.value\n;;","lineNumber":"","type":"Snippet"},{"id":"t-flip-flop-hardcaml-idiomatic-hardcaml","additionalIds":["idiomatic-hardcaml"],"level":3,"title":"Idiomatic Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"let t_flip_flop_2 ~clock ~reset_n ~t =\n  reg_fb\n    (Reg_spec.create ~clock ~reset:reset_n ~reset_edge:Falling ())\n    ~width:1\n    ~enable:t\n    ~f:( ~: )\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709443963,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.2.2 T Flip Flop","pageMeta":{"parent":["sequential_logic.mdx"],"title":["2.2.2 T Flip Flop"],"uuid":["50028be6-12e9-3c32-c0a3-0030dab394af"]},"dirName":"designing-circuits","fileName":"t_flip_flop","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"T Flip Flop","id":"t-flip-flop","customAnchorId":"t-flip-flop"}]}},{"type":"Page","content":[{"id":"d-flip-flop","additionalIds":[],"title":"D Flip Flop","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The D (Data) flip-flop loads the input value to the output on the rising edge of the clock:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"When enable=1: Output ","type":"SimpleText"},{"code":"q","type":"InlinedCode"},{"text":" takes the value of input ","type":"SimpleText"},{"code":"d","type":"InlinedCode"},{"text":" on the clock edge","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"When enable=0: Output ","type":"SimpleText"},{"code":"q","type":"InlinedCode"},{"text":" maintains its current value","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"This implementation includes two reset mechanisms:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Active high asynchronous reset: Immediately sets ","type":"SimpleText"},{"code":"q","type":"InlinedCode"},{"text":" to 0 regardless of clock","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Synchronous clear: Sets ","type":"SimpleText"},{"code":"q","type":"InlinedCode"},{"text":" to 0 on the next clock edge when clear is high","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"The enable acts as a clock enable, allowing or preventing state changes on the clock edge.","type":"SimpleText"}]},{"id":"d-flip-flop-verilog","additionalIds":["verilog"],"level":2,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module d_flip_flop (\n  input clock, clear, reset, enable, d,\n  output reg q\n);\n\n  always @(posedge clock, posedge reset) begin\n    if (reset)\n      q <= 1'b1;\n    else if (clear)\n      q <= 1'b0;\n    else if (enable)\n      q <= d;\n  end\n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"d-flip-flop-vhdl","additionalIds":["vhdl"],"level":2,"title":"VHDL","type":"SubHeading"},{"lang":"vhdl","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\n\nentity d_flip_flop is\n  port (\n    clock, reset, clear, enable, d : in std_logic;\n    q : out std_logic\n  );\nend entity;\n\narchitecture rtl of d_flip_flop is \n  signal q_int : std_logic;\nbegin\n\n  q <= q_int;\n  \n  process (clock, reset) begin\n    if reset = '1' then\n      q_int <= '1';\n    elsif rising_edge(clock) then\n      if clear = '1' then \n        q_int <= '0';\n      elsif enable = '1' then\n        q_int <= d;\n      end if;\n    end if;\n  end process;\n\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"d-flip-flop-hardcaml","additionalIds":["hardcaml"],"level":2,"title":"Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"let d_flip_flop ~clock ~reset ~clear ~enable ~d =\n  reg (Reg_spec.create ~clock ~reset ~clear ()) ~enable d\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709443617,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.2.3 D Flip Flop","pageMeta":{"parent":["sequential_logic.mdx"],"title":["2.2.3 D Flip Flop"],"uuid":["095dc8fe-6457-3165-c533-28ae8dbaf764"]},"dirName":"designing-circuits","fileName":"d_flip_flop","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"D Flip Flop","id":"d-flip-flop","customAnchorId":"d-flip-flop"}]}},{"type":"Page","content":[{"id":"ring-counter","additionalIds":[],"title":"Ring Counter","type":"Section","content":[{"type":"Paragraph","content":[{"text":"An N-bit right shift register that circularly shifts one bit through all positions. On","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"each clock cycle, the least significant bit shifts into the most significant bit.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Initialized with a single ","type":"SimpleText"},{"code":"1","type":"InlinedCode"},{"text":" bit (i.e., binary 00...01), which then circulates through","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"all bit positions creating a \"one-hot\" encoding pattern.","type":"SimpleText"}]},{"id":"ring-counter-verilog","additionalIds":["verilog"],"level":3,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module ring_counter #(\n  parameter N = 4\n) (\n  input clock, clear,\n  output reg [N-1:0] q\n);\n\n  always @(posedge clock) begin\n    if (clear)\n      q <= 1;\n    else\n      q <= { q[0], q[N-1:1] };\n  end \n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"ring-counter-vhdl","additionalIds":["vhdl"],"level":3,"title":"VHDL","type":"SubHeading"},{"lang":"vhdl","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity ring_counter is\n  generic (\n    N : integer := 4\n  );\n  port (\n    clock, clear : in std_logic;\n    q : out std_logic_vector(N-1 downto 0)\n  );\nend entity;\n\narchitecture rtl of ring_counter is\n    signal q_int : std_logic_vector(N-1 downto 0);\nbegin\n\n  q <= q_int;\n\n  process (clock) is\n  begin\n    if rising_edge(clock) then\n      if clear = '1' then\n        q_int <= std_logic_vector(to_unsigned(1, q_int'length));\n      else\n        q_int <= q_int(0) & q_int(N-1 downto 1);\n      end if;\n    end if;\n  end process;\n\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"ring-counter-hardcaml","additionalIds":["hardcaml"],"level":3,"title":"Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"let ring_counter ~n ~clock ~clear =\n  reg_fb (Reg_spec.create ~clock ~clear ()) ~width:n ~clear_to:(one n) ~f:(rotr ~by:1)\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709443058,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.2.4 Ring Counter","pageMeta":{"parent":["sequential_logic.mdx"],"title":["2.2.4 Ring Counter"],"uuid":["ffc7545c-613b-3811-fed2-6e8995deac66"]},"dirName":"designing-circuits","fileName":"ring_counter","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Ring Counter","id":"ring-counter","customAnchorId":"ring-counter"}]}},{"type":"Page","content":[{"id":"mobius-counter","additionalIds":[],"title":"Mobius Counter","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Mobius counter is a really cool name for this, but it's probably more commonly known as a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Johnson counter. It is similar to a ring counter except the least significant bit is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"inverted before being placed into the most significant bit.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"This inversion creates a 2N-state counter from an N-bit register, as the counter cycles","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"through both normal and complemented patterns before repeating.","type":"SimpleText"}]},{"id":"mobius-counter-verilog","additionalIds":["verilog"],"level":3,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module mobius_counter #(\n  parameter N = 4\n) (\n  input clock, clear,\n  output reg [N-1:0] q\n);\n\n  always @(posedge clock) begin\n    if (clear)\n      q <= 0;\n    else\n      q <= { ~q[0], q[N-1:1] };\n  end \n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"mobius-counter-vhdl","additionalIds":["vhdl"],"level":3,"title":"VHDL","type":"SubHeading"},{"lang":"vhdl","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\n\nentity mobius_counter is\n  generic (\n    N : integer := 4\n  );\n  port (\n    clock, clear : in std_logic;\n    q : out std_logic_vector(N-1 downto 0)\n  );\nend entity;\n\narchitecture rtl of mobius_counter is\n    signal q_int : std_logic_vector(N-1 downto 0);\nbegin\n\n  q <= q_int;\n\n  process (clock) is\n  begin\n    if rising_edge(clock) then\n      if clear = '1' then\n        q_int <= (others => '0');\n      else\n        q_int <= (not q_int(0)) & q_int(N-1 downto 1);\n      end if;\n    end if;\n  end process;\n\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"mobius-counter-hardcaml","additionalIds":["hardcaml"],"level":3,"title":"Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"let mobius_counter ~n ~clock ~clear =\n  reg_fb (Reg_spec.create ~clock ~clear ()) ~width:n ~f:(fun d -> ~:(lsb d) @: msbs d)\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709444318,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.2.5 Mobius Counter","pageMeta":{"parent":["sequential_logic.mdx"],"title":["2.2.5 Mobius Counter"],"uuid":["d1a19840-1b9d-3a48-04ea-78581500c658"]},"dirName":"designing-circuits","fileName":"mobius_counter","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Mobius Counter","id":"mobius-counter","customAnchorId":"mobius-counter"}]}},{"type":"Page","content":[{"id":"modulo-n-counter","additionalIds":[],"title":"Modulo N Counter","type":"Section","content":[{"type":"Paragraph","content":[{"text":"On each clock cycle, this counter adds ","type":"SimpleText"},{"code":"1","type":"InlinedCode"},{"text":" to the current value if the ","type":"SimpleText"},{"code":"increment","type":"InlinedCode"},{"text":" signal","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"is high. If the current value equals ","type":"SimpleText"},{"code":"n-1","type":"InlinedCode"},{"text":", it wraps around to ","type":"SimpleText"},{"code":"0","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"id":"modulo-n-counter-verilog","additionalIds":["verilog"],"level":2,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module modulo_n_counter #(\n  parameter width = 4,\n  parameter n = 12\n) (\n  input clock, clear, increment,\n  output reg [width-1:0] q\n);\n\n  always @(posedge clock)\n  begin\n    if (clear) \n      q <= 0;\n    else if (increment)\n      if (q == (n-1)) q <= 0;\n      else q <= q + 1;\n  end\n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"modulo-n-counter-vhdl","additionalIds":["vhdl"],"level":2,"title":"VHDL","type":"SubHeading"},{"lang":"vhdl","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity modulo_n_counter is\n  generic (\n    width : integer := 4;\n    n : integer := 12\n  );\n  port (\n    clock, clear, increment : in std_logic;\n    q : out std_logic_vector(width-1 downto 0)\n  );\nend entity;\n\narchitecture rtl of modulo_n_counter is\n    signal q_int : std_logic_vector(width-1 downto 0);\nbegin\n\n  q <= q_int;\n\n  process (clock) is \n  begin\n    if rising_edge(clock) then\n      if clear = '1' then\n        q_int <= (others => '0');\n      elsif increment = '1' then\n       if (q_int = std_logic_vector(to_unsigned(n-1, q'length))) then\n          q_int <= (others => '0');\n        else\n          q_int <= std_logic_vector(unsigned(q_int) +  1);\n        end if;\n      end if;\n    end if;\n  end process;\n\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"modulo-n-counter-hardcaml","additionalIds":["hardcaml"],"level":2,"title":"Hardcaml","type":"SubHeading"},{"id":"modulo-n-counter-hardcaml-direct-translation","additionalIds":["direct-translation"],"level":3,"title":"Direct translation","type":"SubHeading"},{"lang":"ocaml","snippet":"let modulo_n_counter_1 ~config:{ width; n } ~clock ~clear ~increment =\n  let spec = Reg_spec.create ~clock ~clear () in\n  let out = Always.Variable.reg spec ~width in\n  Always.(\n    compile\n      [ when_\n          increment\n          [ if_ (out.value ==:. n - 1) [ out <--. 0 ] [ out <-- out.value +:. 1 ] ]\n      ]);\n  out.value\n;;","lineNumber":"","type":"Snippet"},{"id":"modulo-n-counter-hardcaml-idiomatic-hardcaml","additionalIds":["idiomatic-hardcaml"],"level":3,"title":"Idiomatic Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"let modulo_n_counter_2 ~config:{ width; n } ~clock ~clear ~increment =\n  reg_fb\n    (Reg_spec.create ~clock ~clear ())\n    ~enable:increment\n    ~width\n    ~f:(mod_counter ~max:(n - 1))\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"In this implementation the function ","type":"SimpleText"},{"code":"mod_counter","type":"InlinedCode"},{"text":", provided by ","type":"SimpleText"},{"code":"Comb.S","type":"InlinedCode"},{"text":", performs the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"increment function. It is a little smarter than the other versions in that it will detect","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"if ","type":"SimpleText"},{"code":"2**width = n","type":"InlinedCode"},{"text":" and rely on natural binary overflow to wrap to ","type":"SimpleText"},{"code":"0","type":"InlinedCode"},{"text":", eliding the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"comparison.","type":"SimpleText"}]}]}],"lastModifiedTime":1750709444495,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.2.6 Modulo N Counter","pageMeta":{"parent":["sequential_logic.mdx"],"title":["2.2.6 Modulo N Counter"],"uuid":["3356eed6-1cb0-3bb1-f6e5-d1f462605ac9"]},"dirName":"designing-circuits","fileName":"modulo_n_counter","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Modulo N Counter","id":"modulo-n-counter","customAnchorId":"modulo-n-counter"}]}},{"type":"Page","content":[{"id":"gray-counter","additionalIds":[],"title":"Gray Counter","type":"Section","content":[{"type":"Paragraph","content":[{"text":"A Gray code is a binary number system in which each successive code differs by a single","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"bit. This property makes Gray codes useful for reducing switching noise, error detection,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"and rotary encoders. Although sequential examples in this section focus on examples with a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"single clock domain, Gray codes are also fundamental for safely transferring counters","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"across multiple clock domains.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Here we implement a Gray code counter. It is done by using a binary counter and converting","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the value to a gray code.","type":"SimpleText"}]},{"id":"gray-counter-binary-to-gray-code-conversion","additionalIds":["binary-to-gray-code-conversion"],"level":2,"title":"Binary to Gray code conversion","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"To convert a binary number to Gray code:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"The most significant bit remains unchanged","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Each remaining bit is XORed with the bit to its left","type":"SimpleText"}]}]}]},{"id":"gray-counter-verilog","additionalIds":["verilog"],"level":2,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module gray_counter #(\n  parameter N = 4\n) (\n  input clock, clear,\n  output reg [N-1:0] q\n);\n  reg [N-1:0] count;\n\n   always @(posedge clock) begin\n     if (clear) begin\n        count <= 0;\n        q <= 0;\n      end else begin\n        count <= count + 1;\n        q <= { count[N-1], count[N-1:1] ^ count[N-2:0] };\n      end\n   end\n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"gray-counter-vhdl","additionalIds":["vhdl"],"level":2,"title":"VHDL","type":"SubHeading"},{"lang":"vhdl","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity gray_counter is\n  generic (\n    N : integer := 4\n  );\n  port (\n    clock, clear : in std_logic;\n    q : out std_logic_vector(N-1 downto 0)\n  );\nend entity;\n\narchitecture rtl of gray_counter is \n  signal count : std_logic_vector(N-1 downto 0);\n  signal q_int : std_logic_vector(N-1 downto 0);\nbegin\n\n  q <= q_int;\n\n  process (clock) begin\n    if rising_edge(clock) then\n      if clear = '1' then \n        count <= (others => '0');\n        q_int <= (others => '0');\n      else \n        count <= std_logic_vector(unsigned(count) + 1);\n        q_int <= count(N-1) & (count(N-1 downto 1) xor count(N-2 downto 0));\n      end if;\n    end if;\n  end process;\n\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"gray-counter-hardcaml","additionalIds":["hardcaml"],"level":2,"title":"Hardcaml","type":"SubHeading"},{"id":"gray-counter-hardcaml-direct-translation","additionalIds":["direct-translation"],"level":3,"title":"Direct translation","type":"SubHeading"},{"lang":"ocaml","snippet":"let gray_counter_1 ~n ~clock ~clear =\n  let spec = Reg_spec.create ~clock ~clear () in\n  let q = Always.Variable.reg spec ~width:n in\n  let out = Always.Variable.reg spec ~width:n in\n  Always.(\n    compile\n      [ q <-- q.value +:. 1\n      ; out <-- q.value.:(n - 1) @: q.value.:[n - 1, 1] ^: q.value.:[n - 2, 0]\n      ]);\n  out.value\n;;","lineNumber":"","type":"Snippet"},{"id":"gray-counter-hardcaml-idiomatic-hardcaml","additionalIds":["idiomatic-hardcaml"],"level":3,"title":"Idiomatic Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"let gray_counter_2 ~n ~clock ~clear =\n  let spec = Reg_spec.create ~clock ~clear () in\n  let q = reg_fb spec ~width:n ~f:(fun q -> q +:. 1) in\n  reg spec (msb q @: msbs q ^: lsbs q)\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709444024,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.2.7 Gray Counter","pageMeta":{"parent":["sequential_logic.mdx"],"title":["2.2.7 Gray Counter"],"uuid":["26e3d25f-3f3a-3cdc-bb0d-a4c300a0b5d4"]},"dirName":"designing-circuits","fileName":"gray_counter","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Gray Counter","id":"gray-counter","customAnchorId":"gray-counter"}]}},{"type":"Page","content":[{"id":"bidirectional-shift-register","additionalIds":[],"title":"Bidirectional Shift Register","type":"Section","content":[{"type":"Paragraph","content":[{"text":"A shift register that can move data in either direction based on a control signal.","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"If ","type":"SimpleText"},{"code":"dir=0","type":"InlinedCode"},{"text":" shift the register left and add ","type":"SimpleText"},{"code":"d","type":"InlinedCode"},{"text":" at the least significant bit","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"If ","type":"SimpleText"},{"code":"dir=1","type":"InlinedCode"},{"text":" shift the register right and add ","type":"SimpleText"},{"code":"d","type":"InlinedCode"},{"text":" at the most significant bit","type":"SimpleText"}]}]}]},{"id":"bidirectional-shift-register-verilog","additionalIds":["verilog"],"level":2,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module bidirectional_shift_reg #(\n  parameter N = 4\n) (\n  input clock, clear, enable, dir, d,\n  output reg [N-1:0] q\n);\n\n  always @(posedge clock) begin\n    if (clear)\n      q <= 0;\n    else\n      if (enable) \n        if (dir)\n          q <= { d, q[N-1:1] };\n        else\n          q <= { q[N-2:0], d };\n  end \n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"bidirectional-shift-register-vhdl","additionalIds":["vhdl"],"level":2,"title":"VHDL","type":"SubHeading"},{"lang":"vhdl","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\n\nentity bidirectional_shift_reg is\n  generic (\n    N : integer := 4\n  );\n  port (\n    clock, clear, enable, dir, d : in std_logic;\n    q : out std_logic_vector(N-1 downto 0)\n  );\nend entity;\n\narchitecture rtl of bidirectional_shift_reg is\n  signal q_int : std_logic_vector(N-1 downto 0);\nbegin\n\n  q <= q_int;\n\n  process (clock) is \n  begin\n    if rising_edge(clock) then\n      if clear = '1' then\n        q_int <= (others => '0');\n      else\n        if enable = '1' then\n          if dir = '1' then\n            q_int <= d & q_int(N-1 downto 1);\n          else\n            q_int <= q_int(N-2 downto 0) & d;\n          end if;\n        end if;\n      end if;\n    end if;\n  end process;\n\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"bidirectional-shift-register-hardcaml","additionalIds":["hardcaml"],"level":2,"title":"Hardcaml","type":"SubHeading"},{"id":"bidirectional-shift-register-hardcaml-direct-translation","additionalIds":["direct-translation"],"level":3,"title":"Direct translation","type":"SubHeading"},{"lang":"ocaml","snippet":"let bidirectional_shift_reg_1 ~n ~clock ~clear ~enable ~dir ~d =\n  let out = Always.Variable.reg (Reg_spec.create ~clock ~clear ()) ~width:n in\n  Always.(\n    compile\n      [ when_\n          enable\n          [ if_\n              dir\n              [ out <-- d @: out.value.:[n - 1, 1] ]\n              [ out <-- out.value.:[n - 2, 0] @: d ]\n          ]\n      ]);\n  out.value\n;;","lineNumber":"","type":"Snippet"},{"id":"bidirectional-shift-register-hardcaml-idiomatic-hardcaml","additionalIds":["idiomatic-hardcaml"],"level":3,"title":"Idiomatic Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"let bidirectional_shift_reg_2 ~n ~clock ~clear ~enable ~dir ~d =\n  reg_fb (Reg_spec.create ~clock ~clear ()) ~width:n ~enable ~f:(fun out ->\n    mux2 dir (d @: msbs out) (lsbs out @: d))\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709443056,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.2.8 Bidirectional Shift Register","pageMeta":{"parent":["sequential_logic.mdx"],"title":["2.2.8 Bidirectional Shift Register"],"uuid":["8ea9e441-f98b-3e2a-ed3e-c8b3f9e6d07c"]},"dirName":"designing-circuits","fileName":"bidirectional_shift_reg","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Bidirectional Shift Register","id":"bidirectional-shift-register","customAnchorId":"bidirectional-shift-register"}]}},{"type":"Page","content":[{"id":"single-port-ram","additionalIds":[],"title":"Single Port RAM","type":"Section","content":[{"type":"Paragraph","content":[{"text":"This is a synchronous single-port RAM with the following specifications:","type":"SimpleText"}]},{"bulletMarker":"-","tight":false,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"type":"StrongEmphasis","content":[{"text":"Memory Size","type":"SimpleText"}]},{"text":": 8 words × 8 bits (64 bits total)","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Address width: 3 bits (2^3^ = 8 addresses)","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Data width: 8 bits (each memory location stores a byte)","type":"SimpleText"}]}]}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"type":"StrongEmphasis","content":[{"text":"Port Configuration","type":"SimpleText"}]},{"text":": Single-port design","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"One shared address bus for both reads and writes","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"One data input bus","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"One data output bus","type":"SimpleText"}]}]}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"type":"StrongEmphasis","content":[{"text":"Timing Behavior","type":"SimpleText"}]},{"text":": Synchronous operation","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"All operations occur on the rising edge of the clock","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Write operations happen when ","type":"SimpleText"},{"code":"write_enable","type":"InlinedCode"},{"text":" is active","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Read operations happen on every clock cycle regardless of ","type":"SimpleText"},{"code":"write_enable","type":"InlinedCode"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Read behavior during simultaneous write is consistent (reads the previous value, not the new one)","type":"SimpleText"}]}]}]}]}]},{"id":"single-port-ram-verilog","additionalIds":["verilog"],"level":2,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module single_port_ram (\n  input clock, write_enable,\n  input [2:0] address,\n  input [7:0] write_data,\n  output reg [7:0] read_data\n);\n\n  reg [7:0] mem[0:7];\n\n  always @(posedge clock) begin\n    if (write_enable)\n      mem[address] <= write_data;\n    read_data <= mem[address];\n  end\n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"single-port-ram-vhdl","additionalIds":["vhdl"],"level":2,"title":"VHDL","type":"SubHeading"},{"lang":"vhdl","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity single_port_ram is\n  port (\n    clock, write_enable : in std_logic;\n    address : in std_logic_vector(2 downto 0);\n    write_data : in std_logic_vector(7 downto 0);\n    read_data : out std_logic_vector(7 downto 0)\n  );\nend entity;\n\narchitecture rtl of single_port_ram is \n\n  type mem_t is array (0 to 7) of std_logic_vector(7 downto 0);\n  signal mem : mem_t;\n  signal read_data_int : std_logic_vector(7 downto 0);\n\nbegin\n\n  read_data <= read_data_int;\n\n  process (clock) is\n  begin\n      if rising_edge(clock) then\n        if write_enable = '1' then\n          mem(to_integer(unsigned(address))) <= write_data;\n        end if;\n        read_data_int <= mem(to_integer(unsigned(address)));\n      end if;\n  end process;\n\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"single-port-ram-hardcaml","additionalIds":["hardcaml"],"level":2,"title":"Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"let single_port_ram ~clock ~address ~write_enable ~write_data =\n  let spec = Reg_spec.create ~clock () in\n  (multiport_memory\n     (Int.pow 2 (width address))\n     ~write_ports:\n       [| { write_clock = clock; write_enable; write_address = address; write_data } |]\n     ~read_addresses:[| address |]).(0)\n  |> reg spec\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709443871,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.2.9 Single Port RAM","pageMeta":{"parent":["sequential_logic.mdx"],"title":["2.2.9 Single Port RAM"],"uuid":["b6122f4f-c9e4-3a44-0820-71e365fe12a9"]},"dirName":"designing-circuits","fileName":"single_port_ram","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Single Port RAM","id":"single-port-ram","customAnchorId":"single-port-ram"}]}},{"type":"Page","content":[{"id":"synchronous-fifo","additionalIds":[],"title":"Synchronous FIFO","type":"Section","content":[{"type":"Paragraph","content":[{"text":"A synchronous FIFO (First-In First-Out) buffer provides temporary storage between circuits","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"that process data at different rates but share the same clock domain. It allows a producer","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"to write data when ready and a consumer to read it later, while maintaining the original","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"order of the data.","type":"SimpleText"}]},{"id":"synchronous-fifo-verilog","additionalIds":["verilog"],"level":2,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module sync_fifo (\n  input clock, clear, write, read,\n  input [15:0] data_in,\n  output reg [15:0] data_out,\n  output full, empty\n);\n\n  reg [2:0] wptr, rptr;\n  reg [15:0] mem[0:7];\n\n  assign full = (wptr + 1) == rptr;\n  assign empty = wptr == rptr;\n\n  wire write_incr = write & !full;\n  wire read_incr = read & !empty;\n\n  always @(posedge clock) begin\n    if (clear) begin\n      rptr <= 0;\n      wptr <= 0;\n    end else begin\n      if (write_incr) wptr <= wptr + 1;\n      if (read_incr) rptr <= rptr + 1;\n    end\n    if (write_incr) mem[wptr] <= data_in;\n    if (read_incr) data_out <= mem[rptr];\n  end\n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"synchronous-fifo-vhdl","additionalIds":["vhdl"],"level":2,"title":"VHDL","type":"SubHeading"},{"lang":"","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity sync_fifo is\n  port (\n    clock, clear, write, read : in std_logic;\n    data_in : in std_logic_vector(15 downto 0);\n    data_out : out std_logic_vector(15 downto 0);\n    full, empty : out std_logic\n  );\nend entity;\n\narchitecture rtl of sync_fifo is\n  type mem_t is array (0 to 7) of std_logic_vector(15 downto 0);\n  signal mem : mem_t;\n\n  signal wptr, rptr : unsigned(2 downto 0);\n  signal write_incr : std_logic;\n  signal read_incr : std_logic;\n  signal full_int : std_logic;\n  signal empty_int : std_logic;\nbegin\n\n  full_int <= '1' when (wptr + 1) = rptr else '0';\n  empty_int <= '1' when wptr = rptr else '0';\n  full <= full_int;\n  empty <= empty_int;\n\n  write_incr <= write and (not full_int);\n  read_incr <= read and (not full_int);\n\n  process (clock) begin\n    if rising_edge(clock) then\n      if clear = '1' then\n        rptr <= (others => '0');\n        wptr <= (others => '0');\n      else\n        if write_incr = '1' then \n          wptr <= wptr + 1;\n        end if;\n        if read_incr = '1' then \n          rptr <= rptr + 1;\n        end if;\n      end if;\n\n      if write_incr = '1' then\n        mem(to_integer(wptr)) <= data_in;\n      end if;\n      if read_incr = '1' then\n        data_out <= mem(to_integer(rptr));\n      end if;\n    end if;\n  end process;\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"synchronous-fifo-hardcaml","additionalIds":["hardcaml"],"level":2,"title":"Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"type t =\n  { data_out : Signal.t\n  ; full : Signal.t\n  ; empty : Signal.t\n  }\n\nlet sync_fifo ~clock ~clear ~write ~read ~data_in =\n  let spec = Reg_spec.create ~clock ~clear () in\n  let wptr = wire log_depth in\n  let wptr_next = wptr +:. 1 in\n  let rptr = wire log_depth in\n  let full = wptr_next ==: rptr in\n  let empty = wptr ==: rptr in\n  let write_enable = write &: ~:full in\n  let read_enable = read &: ~:empty in\n  let mem =\n    Ram.create\n      ~collision_mode:Write_before_read\n      ~size:depth\n      ~write_ports:\n        [| { write_clock = clock\n           ; write_data = data_in\n           ; write_enable\n           ; write_address = wptr\n           }\n        |]\n      ~read_ports:[| { read_clock = clock; read_enable; read_address = rptr } |]\n      ()\n  in\n  wptr <-- reg spec ~enable:write_enable wptr_next;\n  rptr <-- reg spec ~enable:read_enable (rptr +:. 1);\n  { data_out = mem.(0); full; empty }\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709444037,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.2.10 Synchronous FIFO","pageMeta":{"parent":["sequential_logic.mdx"],"title":["2.2.10 Synchronous FIFO"],"uuid":["34b3ffff-d244-3b60-7a99-3cfb1e70a769"]},"dirName":"designing-circuits","fileName":"sync_fifo","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Synchronous FIFO","id":"synchronous-fifo","customAnchorId":"synchronous-fifo"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"A Hardcaml","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Circuit/index.html","isFile":false,"type":"Link","content":[{"code":"Circuit.t","type":"InlinedCode"}]},{"text":" encodes","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"both the RTL logic for a hardware design along with named input and output ports. Circuits","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"can be converted into various different forms:","type":"SimpleText"}]},{"bulletMarker":"*","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Verilog or VHDL","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Simulation models","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Verification models","type":"SimpleText"}]}]}]},{"id":"creating-a-circuit","additionalIds":[],"title":"Creating a Circuit","headingContent":[{"text":"Creating a ","type":"SimpleText"},{"code":"Circuit","type":"InlinedCode"}],"type":"Section","content":[{"type":"Paragraph","content":[{"text":"Circuits are created from a list of outputs and a module name.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let circuit =\n    let foo = input \"foo\" 8 in\n    let bar = input \"bar\" 8 in\n    let baz = output \"baz\" (foo +: bar) in\n    Circuit.create_exn ~name:\"adder\" [ baz ]\nval circuit : Circuit.t = <abstr>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"When generating Verilog or VHDL ","type":"SimpleText"},{"code":"name","type":"InlinedCode"},{"text":" will be used as the module or entity name in the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"RTL design.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"When generating a circuit, combinational loops are by default detected and will cause an","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"exception.","type":"SimpleText"}]},{"id":"creating-a-circuit-inputs-and-outputs","additionalIds":["inputs-and-outputs"],"level":2,"title":"Inputs and outputs","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"To create a circuit we must label the inputs and outputs.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Inputs are specified by giving a name and the required bit-width.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let input_a = Signal.input \"a\" width","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Outputs are specified by giving a name and a signal.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let output_b = Signal.output \"b\" (some_logic input_a)","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"When generating Verilog or VHDL, inputs and outputs correspond to module (or entity)","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"ports.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"For simulation, inputs are set by a testbench, and outputs are calculated by the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"simulation models and read by a testbench.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The names given for inputs and outputs are special in that Hardcaml will never try to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"change them. If it decides they are not valid for some reason an error is raised.","type":"SimpleText"}]},{"id":"creating-a-circuit-what-gets-included","additionalIds":["what-gets-included"],"level":2,"title":"What gets included","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Circuits are defined by their output ports. Hardcaml traverses the design from the outputs","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"and discovers all internal nodes and input ports which are connected to the outputs.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"This can sometimes be confusing - why is some part of my design not getting included? The","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"answer almost always is that it is not connected to an output.","type":"SimpleText"}]},{"id":"creating-a-circuit-config","additionalIds":["config"],"level":2,"title":"Config","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"There are a few configuration options used when generating circuits.","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"detect_combinational_loops","type":"InlinedCode"},{"text":" automatically check the circuit for combinational loops and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"raise if found.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"normalize_uids","type":"InlinedCode"},{"text":" rewrite internal unique identifiers - helps to make the output rtl more","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"stable to changes.","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"Both are true by default and generally should be kept as is.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"There are a few other options but they are mainly used internally by Hardcaml.","type":"SimpleText"}]}]}],"lastModifiedTime":1750709443382,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.3 Circuits","pageMeta":{"parent":["designing_circuits.mdx"],"title":["2.3 Circuits"],"uuid":["dc9bad60-93b1-3e00-aed8-139dbc2da9cd"]},"dirName":"designing-circuits","fileName":"circuits","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Creating a Circuit","id":"creating-a-circuit","customAnchorId":"creating-a-circuit"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"You can ","type":"SimpleText"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Rtl/index.html","isFile":false,"type":"Link","content":[{"text":"convert","type":"SimpleText"}]},{"text":" a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Hardcaml ","type":"SimpleText"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Circuit/index.html","isFile":false,"type":"Link","content":[{"code":"Circuit","type":"InlinedCode"}]},{"type":"SoftLineBreak"},{"text":"to either Verilog or VHDL.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The following is a trivial example.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let circuit = Circuit.create_exn ~name:\"test\" [ output \"b\" (input \"a\" 1) ]","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# let () = Rtl.print Verilog circuit\nmodule test (\n    a,\n    b\n);\n\n    input a;\n    output b;\n\n    assign b = a;\n\nendmodule","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# let () = Rtl.print Vhdl circuit\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity test is\n    port (\n        a : in std_logic;\n        b : out std_logic\n    );\nend entity;\n\narchitecture rtl of test is\n\n\nbegin\n\n    b <= a;\n\nend architecture;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We also provide basic Systemverilog support - the generated RTL is basically the same as","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Verilog mode except we use the Systemverilog reserved words to correctly perform name","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"mangling.","type":"SimpleText"}]},{"id":"instantiations","additionalIds":[],"title":"Instantiations","type":"Section","content":[{"type":"Paragraph","content":[{"text":"In Hardcaml, a ","type":"SimpleText"},{"code":"Circuit","type":"InlinedCode"},{"text":" corresponds to a single module in Verilog or entity in","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"VHDL. ","type":"SimpleText"},{"code":"Circuit","type":"InlinedCode"},{"text":"s can contain ","type":"SimpleText"},{"code":"Instantiation","type":"InlinedCode"},{"text":"s, which reference some other module or entity","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"within a hierarchical design.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The Hardcaml RTL generator is aware of the ","type":"SimpleText"},{"code":"Instantiation","type":"InlinedCode"},{"text":"s and can recursively generate","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the RTL for them, if they are provided in a ","type":"SimpleText"},{"code":"Circuit_database","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"A ","type":"SimpleText"},{"code":"Circuit_database","type":"InlinedCode"},{"text":" stores the implementation of ","type":"SimpleText"},{"code":"Circuit","type":"InlinedCode"},{"text":"s that can be instantiated. It","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"is essentially a mapping between circuit names and their implementations.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"If a circuit implementation is not found in the ","type":"SimpleText"},{"code":"Circuit_database","type":"InlinedCode"},{"text":", Hardcaml will still","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"generate the appropriate instantiation in the RTL output. This allows for integration with","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"external modules (such as vendor IP) that will be added later in the design flow or for","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"/hardcaml-docs/using-interfaces/module_hierarchies","isFile":false,"type":"Link","content":[{"text":"module hierarchy","type":"SimpleText"}]},{"text":" to be described in Hardcaml.","type":"SimpleText"}]}]},{"id":"printing-circuits","additionalIds":[],"title":"Printing Circuits","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"code":"Rtl.print","type":"InlinedCode"},{"text":" function will output the RTL for a design (and optionally any","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"instantiations defined through a ","type":"SimpleText"},{"code":"Circuit_database","type":"InlinedCode"},{"text":") to ","type":"SimpleText"},{"code":"stdout","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"It is simple and usable in most cases.","type":"SimpleText"}]}]},{"id":"low-level-control","additionalIds":[],"title":"Low Level Control","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The RTL API provides a way for the Hardcaml to discover the full design hierarchy and for","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the user to decide how to write it out.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"It starts with the ","type":"SimpleText"},{"code":"create","type":"InlinedCode"},{"text":" function.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# Rtl.create\n- : ?database:Circuit_database.t ->\n    ?config:Rtl.Config.t ->\n    Rtl.Language.t -> Circuit.t list -> Rtl.Hierarchical_circuits.t list\n= <fun>","lineNumber":"","type":"Snippet"},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"database","type":"InlinedCode"},{"text":" - the ","type":"SimpleText"},{"code":"Circuit_database","type":"InlinedCode"},{"text":" which contains implementations of ","type":"SimpleText"},{"code":"Instantiations","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"found within the hierarchy of ","type":"SimpleText"},{"code":"Circuit","type":"InlinedCode"},{"text":"s.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"config","type":"InlinedCode"},{"text":" - Some configuration options for how to generate the RTL.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"Rtl.Langauge.t","type":"InlinedCode"},{"text":" - either Verilog or VHDL.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"Circuit.t list","type":"InlinedCode"},{"text":" - a list of top-level circuits to generate.","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"code":"create","type":"InlinedCode"},{"text":" returns a list ","type":"SimpleText"},{"code":"Hierarchical_circuits","type":"InlinedCode"},{"text":" which represent the design hierarchy.","type":"SimpleText"}]},{"id":"low-level-control-hierarchical-circuits","additionalIds":["hierarchical-circuits"],"level":2,"title":"Hierarchical circuits","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"code":"Hierarchical_circuits","type":"InlinedCode"},{"text":" returned by ","type":"SimpleText"},{"code":"create","type":"InlinedCode"},{"text":" can be factored into the full design","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"hierarchy using ","type":"SimpleText"},{"code":"subcircuits","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"top_level_circuits","type":"InlinedCode"},{"text":". These both return a list of","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Circuit_instance","type":"InlinedCode"},{"text":"s which contain functions to output a module implementation.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"It should be noted that if a module is instantiated in multiple places it will still only","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"be represented once within the ","type":"SimpleText"},{"code":"Hierarchical_circuits","type":"InlinedCode"},{"text":" design hierarchy.","type":"SimpleText"}]},{"id":"low-level-control-blackboxes","additionalIds":["blackboxes"],"level":2,"title":"Blackboxes","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"A blackbox is a module or entity which describes just its interface and does not include","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"its implementation. The RTL generator can create black boxes if required.","type":"SimpleText"}]},{"id":"low-level-control-outputting-rtl","additionalIds":["outputting-rtl"],"level":2,"title":"Outputting RTL","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Hardcaml predefines 4 ways to output the hierarchy of modules.","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"full_hierarchy","type":"InlinedCode"},{"text":" - generate full rtl for everything, recursively. This is the most common","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"option and what ","type":"SimpleText"},{"code":"Rtl.print","type":"InlinedCode"},{"text":" uses.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"top_levels_only","type":"InlinedCode"},{"text":" - only generate the given top levels and do not recuse into the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"hierarchy.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"top_levels_and_blackboxes","type":"InlinedCode"},{"text":" - the top levels will be generated along with blackboxes for","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"all modules in the hierarchy.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"top_levels_as_blackboxes","type":"InlinedCode"},{"text":" - the top levels will be generated as blackboxes.","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"Each of these functions returns a ","type":"SimpleText"},{"code":"Rope.t","type":"InlinedCode"}]},{"id":"low-level-control-outputting-rtl-ropes","additionalIds":["ropes"],"level":3,"title":"Ropes","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Ropes are used by Hardcaml to generate code and are a fancy type of string. All you need","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"to know is they can be converted to a standard string with ","type":"SimpleText"},{"code":"Rope.to_string","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"id":"low-level-control-example","additionalIds":["example"],"level":2,"title":"Example","type":"SubHeading"},{"lang":"ocaml","snippet":"let inner1 () = Circuit.create_exn ~name:\"inner1\" [output \"b\" (input \"a\" 1)]\nlet inner2 () =\n    let x = input \"x\" 1 in\n    let inst = Instantiation.create ~name:\"inner1\" ~inputs:[\"a\", x] ~outputs:[\"b\", 1] () in\n    Circuit.create_exn ~name:\"inner2\" [output \"y\" (Instantiation.output inst \"b\")]\nlet top () =\n    let s = input \"s\" 1 in\n    let inst = Instantiation.create ~name:\"inner2\" ~inputs:[\"x\", s] ~outputs:[\"y\", 1] () in\n    Circuit.create_exn ~name:\"top\" [output \"t\" (Instantiation.output inst \"y\")]","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"This creates a hierarchy where ","type":"SimpleText"},{"code":"top","type":"InlinedCode"},{"text":" instantiates ","type":"SimpleText"},{"code":"inner1","type":"InlinedCode"},{"text":" which in turn instantiates","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"inner2","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"We now need to create a ","type":"SimpleText"},{"code":"Circuit_database","type":"InlinedCode"},{"text":" containing the inner circuits.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let database = Circuit_database.create ();;\nCircuit_database.insert database (inner1 ());;\nCircuit_database.insert database (inner2 ());;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Now we can print the RTL for ","type":"SimpleText"},{"code":"top","type":"InlinedCode"},{"text":" in various ways","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let rtl = Rtl.create ~database Verilog [ top() ]","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# Rtl.top_levels_and_blackboxes rtl |> Rope.to_string |> Stdio.print_endline;;\nmodule inner1 (\n    a,\n    b\n);\n\n    input a;\n    output b;\n\n\nendmodule\nmodule inner2 (\n    x,\n    y\n);\n\n    input x;\n    output y;\n\n\nendmodule\nmodule top (\n    s,\n    t\n);\n\n    input s;\n    output t;\n\n    wire _4;\n    wire _2;\n    inner2\n        the_inner2\n        ( .x(s),\n          .y(_4) );\n    assign _2 = _4;\n    assign t = _2;\n\nendmodule\n\n- : unit = ()","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# Rtl.top_levels_as_blackboxes rtl |> Rope.to_string |> Stdio.print_endline;;\nmodule top (\n    s,\n    t\n);\n\n    input s;\n    output t;\n\n\nendmodule\n\n- : unit = ()","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Find ","type":"SimpleText"},{"code":"inner2","type":"InlinedCode"},{"text":" within the hierarchy and print that directly.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let inner2 = \n    Rtl.Hierarchical_circuits.subcircuits rtl\n    |> List.find_exn ~f:(fun sub -> String.equal (Rtl.Circuit_instance.module_name sub) \"inner2\") \n    |> Rtl.Circuit_instance.rtl \n    |> Rope.to_string \n    |> Stdio.print_endline\nmodule inner2 (\n    x,\n    y\n);\n\n    input x;\n    output y;\n\n    wire _4;\n    wire _2;\n    inner1\n        the_inner1\n        ( .a(x),\n          .b(_4) );\n    assign _2 = _4;\n    assign y = _2;\n\nendmodule\n\nval inner2 : unit = ()","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709443064,"tocItem":{"chapterTitle":"Designing Circuits","pageTitle":"2.4 RTL Generation","pageMeta":{"parent":["designing_circuits.mdx"],"title":["2.4 RTL Generation"],"uuid":["95751f4c-28dc-38d4-445e-c07c27e160bd"]},"dirName":"designing-circuits","fileName":"rtl_generation","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Instantiations","id":"instantiations","customAnchorId":"instantiations"},{"title":"Printing Circuits","id":"printing-circuits","customAnchorId":"printing-circuits"},{"title":"Low Level Control","id":"low-level-control","customAnchorId":"low-level-control"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"The simplest way to simulate a Hardcaml circuit is to use the","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Cyclesim/index.html","isFile":false,"type":"Link","content":[{"code":"Cyclesim","type":"InlinedCode"}]},{"type":"SoftLineBreak"},{"text":"module.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"This will take a ","type":"SimpleText"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Circuit/index.html","isFile":false,"type":"Link","content":[{"code":"Circuit.t","type":"InlinedCode"}]},{"type":"SoftLineBreak"},{"text":"and perform various transformations in","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"order to produce an executable model of the design.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"A testbench is used to control the design by:","type":"SimpleText"}]},{"delimiter":".","startNumber":1,"type":"OrderedList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Performing a reset","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Stepping the simulation forward by 1 cycle","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Setting inputs ports","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Reading output ports","type":"SimpleText"}]}]}]},{"id":"working-with-simulators","additionalIds":[],"title":"Working with Simulators","type":"Section","content":[{"type":"Paragraph","content":[{"text":"A simulation is built from a circuit as follows. First, we will create","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"a trivial circuit.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# open Base\n# open Hardcaml\n# let circuit = Circuit.create_exn ~name:\"test\" Signal.[ output \"y\" ~:(input \"x\" 1)]\nval circuit : Circuit.t = <abstr>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Now we can build a simulator for this circuit.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let (simulator : _ Cyclesim.t) = Cyclesim.create circuit\nval simulator : (Cyclesim.Port_list.t, Cyclesim.Port_list.t) Cyclesim.t =\n  <abstr>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Once we have the simulator we can query its input and output ports.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"These functions use the input and output port names given when we","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"constructed the circuit.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let x = Cyclesim.in_port simulator \"x\"\nval x : Bits.t ref = {Base.Ref.contents = 0}\n# let y = Cyclesim.out_port simulator \"y\"\nval y : Bits.t ref = {Base.Ref.contents = 0}","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Note that looking up a non-existent port will produce an exception","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let foo = Cyclesim.in_port simulator \"foo\"\nException: (\"Couldn't find input port\" foo)","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The functions ","type":"SimpleText"},{"code":"reset","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"cycle","type":"InlinedCode"},{"text":" control the simulator. ","type":"SimpleText"},{"code":"reset","type":"InlinedCode"},{"text":" sets","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"all registers to their default (initial) value. ","type":"SimpleText"},{"code":"cycle","type":"InlinedCode"},{"text":" reads the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"values on the current input ports, updates the internal combinational","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"and sequential logic, and calculates the new values of the circuit","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"outputs.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# Cyclesim.reset simulator\n- : unit = ()\n# Cyclesim.cycle simulator\n- : unit = ()","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Input and output ports are of type","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Bits/index.html","isFile":false,"type":"Link","content":[{"code":"Bits.t ref","type":"InlinedCode"}]},{"text":".","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"We set an input as follows:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# x := Bits.vdd\n- : unit = ()","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"and read an output like so:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# !y\n- : Bits.t = 1\n# Bits.width !y\n- : int = 1\n# Bits.to_unsigned_int !y\n- : int = 1\n# Cyclesim.cycle simulator\n- : unit = ()\n# Bits.to_unsigned_int !y\n- : int = 0","lineNumber":"","type":"Snippet"},{"id":"working-with-simulators-the-simulation-algorithm","additionalIds":["the-simulation-algorithm"],"level":2,"title":"The simulation algorithm","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Cyclesim performs the following steps when ","type":"SimpleText"},{"code":"cycle","type":"InlinedCode"},{"text":" is called.","type":"SimpleText"}]},{"delimiter":".","startNumber":1,"type":"OrderedList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Based on the current value of the inputs, update (in the correct order) all the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"combinational nodes in the circuit. Nodes which read a register or memory read port use","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"their current value.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Update all registers and memory writes. The previous step will have defined the new","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"values to load.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Perform a final update of the (subset of) combinational nodes that depend on the new","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"register/memory values.","type":"SimpleText"}]}]}]},{"id":"working-with-simulators-the-simulation-algorithm-before-and-after-outputs","additionalIds":["before-and-after-outputs"],"level":3,"title":"Before and After outputs","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"When we look up an output port there is an optional argument ","type":"SimpleText"},{"code":"clock_edge","type":"InlinedCode"},{"text":". It defaults to","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"After","type":"InlinedCode"},{"text":" which means the output value after all 3 steps of the simulation algorithm have","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"run. ","type":"SimpleText"},{"code":"Before","type":"InlinedCode"},{"text":" samples the values after step 1 - that is before the sequential nodes update.","type":"SimpleText"}]}]},{"id":"limitations","additionalIds":[],"title":"Limitations","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Cyclesim implements a cycle-accurate simulation algorithm. This is in contrast to the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"more complex event-driven simulators often used for RTL design.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Verilator is an example of a popular cycle-accurate simulator, while Icarus Verilog and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Modelsim are examples of event-driven simulators.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"While event-driven simulators are more powerful, for testing standard synchronous designs","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"cycle accurate simulators are generally good enough, simpler to write testbenches for and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"easier to make run reasonably fast.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The Hardcaml Cyclesim simulator also add some further restrictions:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"We only support 1 clock. In designs with more that 1 clock, they are all assumed to be","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the same.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"We don't model different clock edges - we assume everything is rising edge triggered.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"We only support 2 state logic.","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"The Hardcaml toolset provides an event driver simulator framework with the","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Hardcaml_event_driven_sim","type":"InlinedCode"},{"text":" library. This is rather more complex to use but provides more","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"accurate modeling possibilities.","type":"SimpleText"}]}]}],"lastModifiedTime":1750709443619,"tocItem":{"chapterTitle":"Simulating Circuits","pageTitle":"3.1 Simulating with Cyclesim","pageMeta":{"parent":["simulating_circuits.mdx"],"title":["3.1 Simulating with Cyclesim"],"uuid":["70fe5fd2-1da7-36c5-a0af-2a50d1b08f42"]},"dirName":"simulating-circuits","fileName":"simulation","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Working with Simulators","id":"working-with-simulators","customAnchorId":"working-with-simulators"},{"title":"Limitations","id":"limitations","customAnchorId":"limitations"}]}},{"type":"Page","content":[{"id":"hardcaml-waveterm","additionalIds":[],"title":"Hardcaml Waveterm","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"url":"https://github.com/janestreet/hardcaml_waveterm","isFile":false,"type":"Link","content":[{"code":"hardcaml_waveterm","type":"InlinedCode"}]},{"text":" library can","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"capture and print waveforms from Hardcaml simulations.","type":"SimpleText"}]},{"id":"hardcaml-waveterm-printing-results-as-waveforms","additionalIds":["printing-results-as-waveforms"],"level":2,"title":"Printing results as waveforms","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"We can make a waveform with","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://ocaml.org/p/hardcaml_waveterm/latest/doc/Hardcaml_waveterm/index.html","isFile":false,"type":"Link","content":[{"code":"Waveform.create","type":"InlinedCode"}]},{"text":".","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"It takes as an argument a simulator and returns a waveform and modified simulator that","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"captures the input and output port values.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The waveform can be displayed with ","type":"SimpleText"},{"code":"Waveform.print","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let test () =\n    let sim = Simulator.create create in\n    let waves, sim = Waveform.create sim in\n    testbench sim;\n    waves\nval test : unit -> Waveform.t = <fun>\n\n# let waves = test ()\nval waves : Waveform.t = <abstr>\n# Waveform.print waves\n┌Signals────────┐┌Waves──────────────────────────────────────────────┐\n│clock          ││┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌──│\n│               ││    └───┘   └───┘   └───┘   └───┘   └───┘   └───┘  │\n│clear          ││                        ┌───────┐                  │\n│               ││────────────────────────┘       └───────────────   │\n│incr           ││        ┌───────────────┐                          │\n│               ││────────┘               └───────────────────────   │\n│               ││────────────────┬───────┬───────┬───────────────   │\n│dout           ││ 00             │01     │02     │00                │\n│               ││────────────────┴───────┴───────┴───────────────   │\n└───────────────┘└───────────────────────────────────────────────────┘\n- : unit = ()","lineNumber":"","type":"Snippet"},{"id":"hardcaml-waveterm-capturing-in-expect-tests","additionalIds":["capturing-in-expect-tests"],"level":2,"title":"Capturing in expect tests","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Waveforms can be captured as expect test output.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let%expect_test \"counter\" =\n  let waves = test ()\n  Waveform.print waves\n  [%expect {|\n┌Signals────────┐┌Waves──────────────────────────────────────────────┐\n│clock          ││┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌──│\n│               ││    └───┘   └───┘   └───┘   └───┘   └───┘   └───┘  │\n│clear          ││                        ┌───────┐                  │\n│               ││────────────────────────┘       └───────────────   │\n│incr           ││        ┌───────────────┐                          │\n│               ││────────┘               └───────────────────────   │\n│               ││────────────────┬───────┬───────┬───────────────   │\n│dout           ││ 00             │01     │02     │00                │\n│               ││────────────────┴───────┴───────┴───────────────   │\n│               ││                                                   │\n└───────────────┘└───────────────────────────────────────────────────┘\n  |}]","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"code":"expect tests","type":"InlinedCode"},{"text":" are a form of automated testing where the expected output of a function or","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"component is directly embedded in the test file and automatically compared against actual","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"results. With waveforms we get presented with a diff as we develop or change code.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Alongside good editor integration using expect tests can be a surprisingly convenient way","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"to iterate on a hardware implementation.","type":"SimpleText"}]},{"id":"hardcaml-waveterm-configuration-options","additionalIds":["configuration-options"],"level":2,"title":"Configuration options","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"code":"Waveform.print","type":"InlinedCode"},{"text":" function takes optional arguments which control the rendering of the waveform.","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"start_cycle","type":"InlinedCode"},{"text":" first cycle to display.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"display_width","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"display_height","type":"InlinedCode"},{"text":" width and height of the waveform. The height is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"inferred if not specified.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"wave_width","type":"InlinedCode"},{"text":" scale at which the waveform is shown (negative values allowed).","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"display_rules","type":"InlinedCode"},{"text":" configuration of the signals to show.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"signals_alignment","type":"InlinedCode"},{"text":" left or right align the name in the signal pane.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"signals_width","type":"InlinedCode"},{"text":" width of signal pane.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"display_rules","type":"InlinedCode"},{"text":" configure what signals to show, and in what format.","type":"SimpleText"}]}]}]},{"id":"hardcaml-waveterm-display-rules","additionalIds":["display-rules"],"level":2,"title":"Display rules","type":"SubHeading"},{"lang":"ocaml","snippet":"# Waveform.print\n    ~display_height:10\n    ~display_rules:\n      Display_rule.[ port_name_is \"dout\" ~wave_format:Unsigned_int\n                   ; port_name_matches Re.Posix.(compile (re \"cl.*\")) ~wave_format:Bit ]\n    waves\n┌Signals────────┐┌Waves──────────────────────────────────────────────┐\n│               ││────────────────┬───────┬───────┬───────────────   │\n│dout           ││ 0              │1      │2      │0                 │\n│               ││────────────────┴───────┴───────┴───────────────   │\n│clear          ││                        ┌───────┐                  │\n│               ││────────────────────────┘       └───────────────   │\n│clock          ││┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌──│\n│               ││    └───┘   └───┘   └───┘   └───┘   └───┘   └───┘  │\n│               ││                                                   │\n└───────────────┘└───────────────────────────────────────────────────┘\n- : unit = ()","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The signals are shown in the order of the first matching ","type":"SimpleText"},{"code":"Display_rule.t","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"A display rule matches one or more signal names.","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"port_name_is","type":"InlinedCode"},{"text":" matches the given name.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"port_name_is_one_of","type":"InlinedCode"},{"text":" matches any name in the given list.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"port_name_matches","type":"InlinedCode"},{"text":" matches the signal name against a regular expression (defined using the OCaml RE library).","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"The way the value is shown is configured by a ","type":"SimpleText"},{"code":"wave_format","type":"InlinedCode"},{"text":". Standard formatting includes","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Binary","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"Hex","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"Unsigned_int","type":"InlinedCode"},{"text":", and ","type":"SimpleText"},{"code":"Int","type":"InlinedCode"},{"text":". ","type":"SimpleText"},{"code":"Bit","type":"InlinedCode"},{"text":" is like binary but renders a single bit","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"value like the clear signal in the previous example.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"Bit_or X","type":"InlinedCode"},{"text":" will render as a bit if the width is 1 or X (which may be Hex, or Int for","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"example) otherwise.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"Index","type":"InlinedCode"},{"text":" takes a list of strings and looks it up based on the runtime value of the signal.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"Custom","type":"InlinedCode"},{"text":" passes the runtime value to a function which returns the string to display.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"Map","type":"InlinedCode"},{"text":" is like index but looks up the the runtime value in a map.","type":"SimpleText"}]},{"id":"hardcaml-waveterm-saving-a-waveform","additionalIds":["saving-a-waveform"],"level":2,"title":"Saving a waveform","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Hardcaml waveforms can be saved to file using ","type":"SimpleText"},{"code":"Serialize.marshall","type":"InlinedCode"},{"text":". It takes a waveform","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"and file name and saves it. Note that it also compresses the waveform data using ","type":"SimpleText"},{"code":"gzip","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"which must be available.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"Serialize.unmarshall","type":"InlinedCode"},{"text":" will load the waveform.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The hardcaml waveterm library includes an executable which runs an ","type":"SimpleText"},{"url":"/hardcaml-docs/simulating-circuits/waveterm_interactive_viewer","isFile":false,"type":"Link","content":[{"text":"interactive waveform","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"viewer on saved waveform files","type":"SimpleText"}]},{"text":".","type":"SimpleText"}]}]},{"id":"generating-vcds","additionalIds":[],"title":"Generating VCDs","type":"Section","content":[{"type":"Paragraph","content":[{"text":"VCDs are a common hardware design file format for storing waveforms. They can be used with","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"standard waveform viewers like Gtkwave.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"To generate a VCD call the ","type":"SimpleText"},{"code":"Vcd.wrap","type":"InlinedCode"},{"text":" function. It takes an ","type":"SimpleText"},{"code":"Out_channel","type":"InlinedCode"},{"text":" to write to and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"a simulator and returns a modified simulator to use during simulation.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The VCD will be generated as the simulation runs. The ","type":"SimpleText"},{"code":"Out_channel","type":"InlinedCode"},{"text":" being written to may","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"need to be flushed.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let test () =\n  let sim = Simulator.create create in\n  let filename = \"/tmp/waves.vcd\" in\n  let oc = Out_channel.open_text filename in\n  let sim = Vcd.wrap oc sim in\n  testbench sim;\n  (* Closing the out channel will ensure the file is flushed to disk *)\n  Out_channel.close oc;\n  Stdio.print_endline (\"Saved waves to \" ^ filename)\n;;\n\nlet%expect_test \"vcd generation\" =\n  test ();\n  [%expect {| Saved waves to /tmp/waves.vcd |}]\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"This VCD file can subsequently be opened with a GUI based waveform viewer tool such as","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://surfer-project.org/","isFile":false,"type":"Link","content":[{"text":"Surfer","type":"SimpleText"}]},{"text":" or ","type":"SimpleText"},{"url":"https://github.com/gtkwave/gtkwave","isFile":false,"type":"Link","content":[{"text":"GTKWave","type":"SimpleText"}]},{"text":".","type":"SimpleText"}]},{"fit":true,"destination":"/hardcaml-docs/surfer-simple-example.png","alt":"image","width":1590,"title":null,"inlined":false,"timestamp":1750709443993,"height":1014,"type":"Image"}]}],"lastModifiedTime":1750709444243,"tocItem":{"chapterTitle":"Simulating Circuits","pageTitle":"3.2 Waveforms","pageMeta":{"parent":["simulating_circuits.mdx"],"title":["3.2 Waveforms"],"uuid":["37d1dde1-693e-36a9-1a6a-09548678c014"]},"dirName":"simulating-circuits","fileName":"waveforms","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Hardcaml Waveterm","id":"hardcaml-waveterm","customAnchorId":"hardcaml-waveterm"},{"title":"Generating VCDs","id":"generating-vcds","customAnchorId":"generating-vcds"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"Writing waveforms in expect tests can be very useful, but does come with it's","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"limitations. In particular it is not really possible to print very long traces, and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"designs with lots and lots of signals can become unwieldy.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"As an alternative we can use the terminal based interactive waveform viewer.","type":"SimpleText"}]},{"id":"building-a-simulation-application","additionalIds":[],"title":"Building a Simulation Application","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The interactive waveform viewer should be built as a top level application. It should be","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"linked with the","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://github.com/janestreet/hardcaml_waveterm/tree/master/interactive","isFile":false,"type":"Link","content":[{"code":"hardcaml_waveterm_interactive","type":"InlinedCode"}]},{"type":"SoftLineBreak"},{"text":"library.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Waveforms are created in the normal way by wrapping a simulator with","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Hardcaml_waveterm.Wavform.create","type":"InlinedCode"},{"text":" and then running a testbench.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The following function is used to run the viewer.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# Hardcaml_waveterm_interactive.run waves","lineNumber":"","type":"Snippet"}]},{"id":"using-the-waveform-viewer","additionalIds":[],"title":"Using the Waveform Viewer","type":"Section","content":[{"bulletMarker":"*","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"q/escape","type":"InlinedCode"},{"text":" quits","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"left/right","type":"InlinedCode"},{"text":" or ","type":"SimpleText"},{"code":"ctrl+mouse-wheel","type":"InlinedCode"},{"text":" scroll waveform horizontally","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"up/down","type":"InlinedCode"},{"text":" or ","type":"SimpleText"},{"code":"mouse-wheel","type":"InlinedCode"},{"text":" scroll waveform vertically","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"-/=","type":"InlinedCode"},{"text":" decrease/increase waveform scale","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"e/b","type":"InlinedCode"},{"text":" will find the next/prev transition on the highlighted signal","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"s/S","type":"InlinedCode"},{"text":" save or load the current waveform configuration","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"h/j/k/l","type":"InlinedCode"},{"text":" move the cursor","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"9/(","type":"InlinedCode"},{"text":" - increase/decrease the signals pane size","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"0/)","type":"InlinedCode"},{"text":" - increase/decrease the values pane size","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"_/+","type":"InlinedCode"},{"text":" - increase/decrease the waves pane size","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"Left clicking on the waveform will position a cursor and show the value of signals at that","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"cycle in the values window.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"All windows also have scroll bars that can be clicked on.","type":"SimpleText"}]}]},{"id":"interactive-waveforms-from-expect-tests","additionalIds":[],"title":"Interactive Waveforms from Expect Tests","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Waveform-based expect tests are very information limited. We often either run very small","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"simulations, show a small portion of a larger simulation, or zoom far out to capture","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"general behavior. Often we can see the behavior of control signals but not the detailed","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"values on data buses.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"To help with this, the ","type":"SimpleText"},{"code":"Hardcaml_waveterm","type":"InlinedCode"},{"text":" library can optionally serialize a waveform to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"disk. It provides an ","type":"SimpleText"},{"code":"expect","type":"InlinedCode"},{"text":" function which is very similar to","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Hardcaml_waveterm.Waveform.print","type":"InlinedCode"}]},{"lang":"ocaml","snippet":"Hardcaml_waveterm.Waveform.expect ~serialize_to:\"filename\" waves","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"This provides an optional argument called ","type":"SimpleText"},{"code":"serialize_to","type":"InlinedCode"},{"text":" which specifies the filename to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"which the waveform will be saved. The suffix ","type":"SimpleText"},{"code":".hardcamlwaveform","type":"InlinedCode"},{"text":" will be added.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"By default, waveforms are not saved. To do so execute the tests with the following","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"environment variable set.","type":"SimpleText"}]},{"lang":"","snippet":"EXPECT_TEST_WAVEFORM=1","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Which will output a file in the same directory called ","type":"SimpleText"},{"code":"filename.hardcamlwaveform","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"To view the waveform, a tool called ","type":"SimpleText"},{"code":"waveform_viewer","type":"InlinedCode"},{"text":" is provided with ","type":"SimpleText"},{"code":"hardcaml_waveterm","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"in the ","type":"SimpleText"},{"code":"bin","type":"InlinedCode"},{"text":" directory.","type":"SimpleText"}]},{"lang":"","snippet":"waveform_viewer.exe show filename.hardcamlwaveform","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709444242,"tocItem":{"chapterTitle":"Simulating Circuits","pageTitle":"3.3 Interactive Viewer","pageMeta":{"parent":["simulating_circuits.mdx"],"title":["3.3 Interactive Viewer"],"uuid":["1f38c61f-c790-3c87-737e-c7f38b3fd27f"]},"dirName":"simulating-circuits","fileName":"waveterm_interactive_viewer","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Building a Simulation Application","id":"building-a-simulation-application","customAnchorId":"building-a-simulation-application"},{"title":"Using the Waveform Viewer","id":"using-the-waveform-viewer","customAnchorId":"using-the-waveform-viewer"},{"title":"Interactive Waveforms from Expect Tests","id":"interactive-waveforms-from-expect-tests","customAnchorId":"interactive-waveforms-from-expect-tests"}]}},{"type":"Page","content":[{"id":"naming-signals","additionalIds":[],"title":"Naming Signals","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Names pop up in a couple of places. First, a circuit's input and output ports must have","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"properly defined names. Internal nodes within a circuit also need a name which Hardcaml","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"will automatically create unless provided.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Judicious use of names becomes very important for debugging simulations or understanding","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"reports from vendor tools like Vivado.","type":"SimpleText"}]},{"id":"naming-signals-port-names","additionalIds":["port-names"],"level":2,"title":"Port names","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Port names are specified with the ","type":"SimpleText"},{"code":"input","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"output","type":"InlinedCode"},{"text":" functions. Hardcaml checks the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"following rules:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Port names must be unique.  No input or output may share a name.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"The names must be legal for the RTL language you use. For","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Hardcaml simulation, this doesn't matter, but if we write the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"design to Verilog, the names must not clash with a Verilog reserved","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"word.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Hardcaml will never try to alter a port name. Instead, it will raise","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"an exception if it deems it illegal.","type":"SimpleText"}]}]}]},{"id":"naming-signals-internal-names","additionalIds":["internal-names"],"level":2,"title":"Internal names","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"When we create vectors in Hardcaml, they are labeled with a unique ID. Without further","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"information, hardcaml will implicitly name the vector as ","type":"SimpleText"},{"code":"_<uid>","type":"InlinedCode"},{"text":". It is possible to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"manually label any vector with a new name using the ","type":"SimpleText"},{"code":"(--)","type":"InlinedCode"},{"text":" operator.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let foo = Hardcaml.Signal.(of_unsigned_int ~width:8 7 -- \"foo\")\nval foo : Hardcaml.Signal.t =\n  (const (names (foo)) (width 8) (value 0b00000111))","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"There are no rules on what internal names are OK to use. Hardcaml will legalize them for","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"you when generating RTL. The rules for Verilog generation are:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Any non-alphanumeric character (except '$') is rewritten with an ","type":"SimpleText"},{"code":"_","type":"InlinedCode"},{"text":".","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Internal names cannot start with a number - a prefix is added.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Internal names cannot be reserved words - the name gets mangled.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Internal names need to be unique - the name gets mangled if not.","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"Mangling means adding a numeric suffix and checking against the rules again.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The VHDL rules are ","type":"SimpleText"},{"type":"Emphasis","content":[{"text":"somewhat","type":"SimpleText"}]},{"text":" similar and Hardcaml will make them legal and perform","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"mangling as appropriate.","type":"SimpleText"}]},{"id":"naming-signals-auto-names","additionalIds":["auto-names"],"level":2,"title":"Auto names","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"ppx_hardcaml","type":"InlinedCode"},{"text":" provides a shortcut syntax for specifying names.","type":"SimpleText"}]},{"lang":"","snippet":"let%hw c = a + b","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"How this works will be explained later after introducing ","type":"SimpleText"},{"code":"Interfaces","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"Hierarchy","type":"InlinedCode"},{"text":".","type":"SimpleText"}]}]}],"lastModifiedTime":1750709444640,"tocItem":{"chapterTitle":"More On Circuit Design","pageTitle":"4.1 Naming","pageMeta":{"parent":["more_design.mdx"],"title":["4.1 Naming"],"uuid":["c43f95bd-310f-32a6-19c6-3158c4441f9e"]},"dirName":"more-on-circuit-design","fileName":"naming","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Naming Signals","id":"naming-signals","customAnchorId":"naming-signals"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Always/index.html","isFile":false,"type":"Link","content":[{"code":"Always","type":"InlinedCode"},{"text":" DSL","type":"SimpleText"}]},{"type":"SoftLineBreak"},{"text":"in Hardcaml lets one describe circuits","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"in a similar style to a Verilog ","type":"SimpleText"},{"code":"always","type":"InlinedCode"},{"text":" block. Always blocks allow","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"hardware multiplexer structures to be described in a somewhat","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"imperative manner using variable assignments, if-else conditions,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"switches and a simple procedural macro construct.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"This programming model often makes complicated logic (such as","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"state machines) easier to reason about.","type":"SimpleText"}]},{"id":"the-always-dsl","additionalIds":[],"title":"The Always DSL","type":"Section","content":[{"lang":"ocaml","snippet":"open Base\nopen Hardcaml","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"There are two key components when using the Always DSL:","type":"SimpleText"}]},{"id":"the-always-dsl-1-variable-declarations","additionalIds":["1-variable-declarations"],"level":2,"title":"1. Variable Declarations","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"There are two kinds of variable declarations, namely wires and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"registers.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"A ","type":"SimpleText"},{"code":"reg","type":"InlinedCode"},{"text":" is one whose value is sequentially updated on the edge of the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"clock signal provided within a ","type":"SimpleText"},{"code":"Reg_spec.t","type":"InlinedCode"},{"text":" type.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# (* Creates a register variable. *)\n  Always.Variable.reg\n- : (width:int -> Always.Variable.t) Signal.with_register_spec = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"A ","type":"SimpleText"},{"code":"wire","type":"InlinedCode"},{"text":" is one whose value is updated combinationally, meaning that","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the new value is visible at the same clock cycle as when it is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"assigned. The new value ","type":"SimpleText"},{"type":"Emphasis","content":[{"text":"will not","type":"SimpleText"}]},{"text":" persist to the next cycle. If no","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"such assignment exists, the variable will possess the ","type":"SimpleText"},{"code":"default","type":"InlinedCode"},{"text":" value.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# (* Creates a wire register, that is, the value of the wire. *)\n  Always.Variable.wire\n- : default:Signal.t -> unit -> Always.Variable.t = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Both kinds of variable will return the same type, namely an ","type":"SimpleText"},{"code":"Always.Variable.t","type":"InlinedCode"}]},{"lang":"ocaml","snippet":"# let foo = Always.Variable.wire ~default:Signal.gnd () ;;\nval foo : Always.Variable.t =\n  {Hardcaml.Always.Variable.value = (wire (width 1)); internal = <abstr>}","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Variables may be assigned within an Always block. To read the value","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"of a variable, access the ","type":"SimpleText"},{"code":"value","type":"InlinedCode"},{"text":" field, which provides a ","type":"SimpleText"},{"code":"Signal.t","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"that can be used to form expressions.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# foo.value;;\n- : Signal.t = (wire (width 1))","lineNumber":"","type":"Snippet"},{"id":"the-always-dsl-2-writing-an-always-program","additionalIds":["2-writing-an-always-program"],"level":2,"title":"2. Writing an Always Program","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Having declared the variables, we can now write the actual","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"'procedural' blocks.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"An ","type":"SimpleText"},{"code":"Always","type":"InlinedCode"},{"text":" program comprises assignments to variables optionally","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"guarded by ","type":"SimpleText"},{"code":"if_","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"when","type":"InlinedCode"},{"text":" or ","type":"SimpleText"},{"code":"switch","type":"InlinedCode"},{"text":" conditional statements. For example:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let something =\n  let open Signal in\n  let a = input \"a\" 1 in\n  let b = input \"b\" 1 in\n  let c = Always.Variable.wire ~default:gnd () in\n  let d = Always.Variable.wire ~default:gnd () in\n  let e = Always.Variable.wire ~default:gnd () in\n  Always.(compile [\n    (* Assignments. *)\n    c <-- (a ^: b );\n\n    (* [if_] statements. *)\n    if_ (a ==: b) [\n      d <-- vdd;\n    ] [\n      d <-- gnd;\n    ];\n\n    (* [when_] is like [if_], with an empty [else]. *)\n    when_ c.value [\n      e <--. 1;\n    ];\n  ]);\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Notice the call to the ","type":"SimpleText"},{"code":"compile","type":"InlinedCode"},{"text":" function surrounding the procedural","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"block.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# Always.compile\n- : Always.t list -> unit = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Two things going on here:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Notice that ","type":"SimpleText"},{"code":"compile","type":"InlinedCode"},{"text":" returns a unit. This is because variable","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"declarations create unassigned wires, and the compile function assigns them","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"to the appropriate multiplexers.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Notice that the Always DSL is just a list of ","type":"SimpleText"},{"code":"Always.t","type":"InlinedCode"},{"text":". This","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"means we can play with various meta-programming and abstraction","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"tricks within these program blocks.","type":"SimpleText"}]}]}]},{"id":"the-always-dsl-example","additionalIds":["example"],"level":2,"title":"Example","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The following is an example of these pieces put together.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let clock = Signal.input \"clock\" 1\nlet clear = Signal.input \"clear\" 1\nlet a = Signal.input \"a\" 8\nlet b = Signal.input \"b\" 8\nlet r_sync = Signal.Reg_spec.create ~clock ~clear ()\n\nlet create =\n  let open Signal in\n  (* [wire] and [register] variable declarations. *)\n  let c_wire = Always.Variable.wire ~default:(Signal.zero 8) () in\n  let c_reg = Always.Variable.reg ~enable:Signal.vdd r_sync ~width:8 in\n  (* The program block with a call to [compile]. *)\n  Always.(compile [\n    if_ (a ==: b) [\n      c_wire <-- (sll a ~by:1);\n      c_reg  <-- (sll a ~by:1)\n    ] [\n      c_wire <-- (a +: b);\n      c_reg  <-- (a +: b);\n    ]\n  ]);\n  (* The [c_wire.value] are assigned appropriately by the Always\n  compiler. *)\n  output \"c_wire\" c_wire.value, output \"c_reg\" c_reg.value\n;;","lineNumber":"","type":"Snippet"},{"id":"the-always-dsl-differences-to-verilog-always-blocks","additionalIds":["differences-to-verilog-always-blocks"],"level":2,"title":"Differences to Verilog Always blocks","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The semantics are similar to Verilog, with a few caveats:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Assignments are non-blocking. Hardcaml does not support blocking assignments.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"In Verilog, an Always block can describe either registers or combinational logic, but","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"not both. With the Always DSL, both can be defined in a single block.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Hardcaml Always blocks do not require a sensitivity list - the clocks driving the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"registers are bound to the register variable themselves.","type":"SimpleText"}]}]}]},{"id":"the-always-dsl-how-values-update","additionalIds":["how-values-update"],"level":2,"title":"How values update","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The reader might be surprised by the following example.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let counter_thing enable =\n  let open Signal in\n  let a = Always.Variable.reg ~enable:vdd r_sync ~width:8 in\n  Always.(compile [\n    (* Here we might expect [a] to take the values [10] or [11], depending on\n       [enable].  But that is not the case.  While [enable] is high, [a] will\n       increment by one every clock cycle.  When [enable] is low [a] is set to\n       10.  *)\n    a <--. 10;\n    when_ (enable) [\n      a <-- a.value +:. 1;\n    ]\n  ]);\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The rule is: the last assignment executed will set the next value.","type":"SimpleText"}]}]}],"lastModifiedTime":1750709442977,"tocItem":{"chapterTitle":"More On Circuit Design","pageTitle":"4.2 Always DSL","pageMeta":{"parent":["more_design.mdx"],"title":["4.2 Always DSL"],"uuid":["77a88612-8b18-3290-41a2-84f75434e824"]},"dirName":"more-on-circuit-design","fileName":"always","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"The Always DSL","id":"the-always-dsl","customAnchorId":"the-always-dsl"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"In the Binary Coded Decimal (BCD) system we represent decimal numbers in a binary format.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"The format uses 4 bits per decimal digit to encode the numbers 0 through 9. For example,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the number 971 would be represented in BCD as:","type":"SimpleText"}]},{"lang":"","snippet":"  9    7    1\n|1001|0111|0001|","lineNumber":"","type":"Snippet"},{"id":"converting-to-binary","additionalIds":[],"title":"Converting to Binary","type":"Section","content":[{"type":"Paragraph","content":[{"text":"To convert a BCD number to a binary number we need to do some multiplications by powers","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"of 10. First we split the input vector into parts of width 4 then compute ","type":"SimpleText"},{"code":"9*100 + 7*10 + 1","type":"InlinedCode"}]},{"type":"Paragraph","content":[{"text":"We can do something a little more efficient by starting with the top most digit and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"computing ","type":"SimpleText"},{"code":"(((9*10) + 7) * 10) + 1","type":"InlinedCode"}]}]},{"id":"implementing-in-hardware","additionalIds":[],"title":"Implementing in Hardware","type":"Section","content":[{"lang":"ocaml","snippet":"let create ~clock ~start ~bcd =\n  let spec = Reg_spec.create ~clock () in\n  (* Find the number of digits to convert and create a counter. *)\n  let digits = split_msb ~part_width:4 bcd in\n  let num_digits = List.length digits in\n  (* We only support multiple digits - for a single digit the output equals the input\n     anyway. *)\n  assert (num_digits > 1);\n  let count = Always.Variable.reg spec ~width:(Int.ceil_log2 num_digits) in\n  (* Create an accumulator large enough to hold the final result. *)\n  let max_result = Int.pow 10 num_digits - 1 in\n  let acc = Always.Variable.reg spec ~width:(num_bits_to_represent max_result) in\n  (* Select the current digit being processed. Note that when we split [bcd] into [digits]\n     we did so from the top most digit. *)\n  let digit = mux count.value digits |> uresize ~width:(width acc.value) in\n  Always.(\n    compile\n      [ if_\n          (count.value ==:. 0)\n          [ (* Wait for start. When applied set the accumulator with the top most digit.\n            *)\n            when_ start [ count <-- count.value +:. 1; acc <-- digit ]\n          ]\n          [ (* Add each succesive digit to the accumulator times 10. *)\n            count <-- count.value +:. 1\n          ; acc <-- drop_top (acc.value *: of_unsigned_int ~width:4 10) ~width:4 +: digit\n          ; (* Finished processing digits. *)\n            when_ (count.value ==:. num_digits - 1) [ count <--. 0 ]\n          ]\n      ]);\n  acc.value, count.value ==:. 0\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We start by figuring out how many digits we need to process and a counter from","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"0..num_digits-1","type":"InlinedCode"},{"text":" is created. An accumulator is also created wide enough to hold the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"largest result value.","type":"SimpleText"}]},{"type":"BlockQuote","content":[{"type":"Paragraph","content":[{"text":"📝 An assertion is raised if num_digits is equal to 1. This is because the ","type":"SimpleText"},{"code":"count","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"register has width ","type":"SimpleText"},{"code":"Int.ceil_log2 num_digits = 0","type":"InlinedCode"},{"text":" which you aren't allowed to do. It is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"not unusual for otherwise generic hardcaml circuit generators to fall down on the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"smallest example in this way, though it often tends to be a trivial case (here, the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"circuit literally does nothing if there is only 1 digit) and can often be worked around.","type":"SimpleText"}]}]},{"type":"Paragraph","content":[{"text":"While ","type":"SimpleText"},{"code":"count","type":"InlinedCode"},{"text":" is 0 we are waiting for ","type":"SimpleText"},{"code":"start","type":"InlinedCode"},{"text":" to be raised. Then, for ","type":"SimpleText"},{"code":"num_digits","type":"InlinedCode"},{"text":" cycles","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"we will add each digit (starting from the top most) to ","type":"SimpleText"},{"code":"acc * 10","type":"InlinedCode"},{"text":". When ","type":"SimpleText"},{"code":"count ==:. num_digits-1","type":"InlinedCode"},{"text":" we have computed the result and set ","type":"SimpleText"},{"code":"count","type":"InlinedCode"},{"text":" back to 0.","type":"SimpleText"}]}]},{"id":"testbench","additionalIds":[],"title":"Testbench","type":"Section","content":[{"lang":"ocaml","snippet":"let bcd_of_string v =\n  String.to_list v\n  |> List.map ~f:(fun c ->\n    Char.to_int c - Char.to_int '0' |> Bits.of_unsigned_int ~width:4)\n  |> Bits.concat_msb\n;;\n\nlet test num_digits =\n  (* Create the simulator. *)\n  let sim =\n    let result, done_ =\n      create\n        ~clock:(input \"clock\" 1)\n        ~start:(input \"start\" 1)\n        ~bcd:(input \"bcd\" (num_digits * 4))\n    in\n    Circuit.create_exn ~name:\"bcd\" [ output \"result\" result; output \"done\" done_ ]\n    |> Cyclesim.create\n  in\n  (* Query the input and output ports. *)\n  let start = Cyclesim.in_port sim \"start\" in\n  let bcd = Cyclesim.in_port sim \"bcd\" in\n  let done_ = Cyclesim.out_port sim \"done\" in\n  let result = Cyclesim.out_port sim \"result\" in\n  (* Start the circuit running and wait for it to be done. Return the computed result. *)\n  let run v =\n    start := Bits.vdd;\n    bcd := bcd_of_string v;\n    Cyclesim.cycle sim;\n    start := Bits.gnd;\n    Cyclesim.cycle sim;\n    while not (Bits.to_bool !done_) do\n      Cyclesim.cycle sim\n    done;\n    Bits.to_unsigned_int !result\n  in\n  run\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The following steps are performed","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Create the BCD design.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Create a ","type":"SimpleText"},{"code":"Circuit","type":"InlinedCode"},{"text":".","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Create a ","type":"SimpleText"},{"code":"Cyclesim","type":"InlinedCode"},{"text":" simulator.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Get the simulator ports.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Return a function which performs a single test - start the circuit with a BCD value,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"wait for it to complete and return the result.","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"code":"test","type":"InlinedCode"},{"text":" function doesn't actually compute a BCD, but it does do all the setup stuff","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"(which can be time consuming for larger designs). It returns a function that allows us to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"run multiple conversions one after the other.","type":"SimpleText"}]}]},{"id":"tests","additionalIds":[],"title":"Tests","type":"Section","content":[{"lang":"ocaml","snippet":"let%expect_test \"\" =\n  let run = test 5 in\n  Stdio.print_s [%message (run \"00000\" : int)];\n  Stdio.print_s [%message (run \"12345\" : int)];\n  Stdio.print_s [%message (run \"99999\" : int)];\n  [%expect\n    {|\n    (\"run \\\"00000\\\"\" 0)\n    (\"run \\\"12345\\\"\" 12345)\n    (\"run \\\"99999\\\"\" 99999)\n    |}];\n  let run = test 2 in\n  Stdio.print_s [%message (run \"00\" : int)];\n  Stdio.print_s [%message (run \"21\" : int)];\n  Stdio.print_s [%message (run \"55\" : int)];\n  Stdio.print_s [%message (run \"99\" : int)];\n  [%expect\n    {|\n    (\"run \\\"00\\\"\" 0)\n    (\"run \\\"21\\\"\" 21)\n    (\"run \\\"55\\\"\" 55)\n    (\"run \\\"99\\\"\" 99)\n    |}]\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709443086,"tocItem":{"chapterTitle":"More On Circuit Design","pageTitle":"4.2.1 BCD Conversion","pageMeta":{"parent":["always.mdx"],"title":["4.2.1 BCD Conversion"],"uuid":["19f5e4b4-0c6a-3ef8-69f6-9f84cea5ca55"]},"dirName":"more-on-circuit-design","fileName":"binary_coded_decimal","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Converting to Binary","id":"converting-to-binary","customAnchorId":"converting-to-binary"},{"title":"Implementing in Hardware","id":"implementing-in-hardware","customAnchorId":"implementing-in-hardware"},{"title":"Testbench","id":"testbench","customAnchorId":"testbench"},{"title":"Tests","id":"tests","customAnchorId":"tests"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"In this example we will simulate the scanning effect of a Cylons eye as seen in Battlestar","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Galactica.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"We will assume we have an array of 16 LEDs that we can drive with a 3 bit intensity value","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"where 0 is off and 7 is full brightness.","type":"SimpleText"}]},{"id":"implementation","additionalIds":[],"title":"Implementation","type":"Section","content":[{"lang":"ocaml","snippet":"let cylon_eye ~clock ~enable =\n  let spec = Reg_spec.create ~clock () in\n  let eye_pos = Always.Variable.reg spec ~enable ~width:4 in\n  let eye_dir = Always.Variable.reg spec ~enable ~width:1 in\n  let eye_bar = List.init 16 ~f:(fun _ -> Always.Variable.reg spec ~enable ~width:3) in\n  Always.(\n    compile\n      [ (* Decrease intensity. *)\n        proc\n          (List.map eye_bar ~f:(fun eye ->\n             proc [ eye <-- eye.value -:. 1; when_ (eye.value ==:. 0) [ eye <--. 0 ] ]))\n      ; (* Set current eye to max intensity. *)\n        proc\n          (List.mapi eye_bar ~f:(fun idx eye ->\n             when_ (eye_pos.value ==:. idx) [ eye <--. 7 ]))\n      ; (* Scan left and right. *)\n        if_\n          eye_dir.value\n          [ eye_pos <-- eye_pos.value -:. 1\n          ; when_ (eye_pos.value ==:. 1) [ eye_dir <-- gnd ]\n          ]\n          [ eye_pos <-- eye_pos.value +:. 1\n          ; when_ (eye_pos.value ==:. 14) [ eye_dir <-- vdd ]\n          ]\n      ]);\n  List.map eye_bar ~f:(fun eye -> eye.value)\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The circuit takes 2 inputs - the clock and an enable. The enable is wired into every","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"register. We will see why later.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The implementation has 3 parts. First, we go through every ","type":"SimpleText"},{"code":"eye","type":"InlinedCode"},{"text":" and decrease it's intensity","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"by one to a minimum of 0.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"We then find the current eye located at ","type":"SimpleText"},{"code":"eye_pos","type":"InlinedCode"},{"text":" and set it to maximum intensity. Together","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"these processes create a eye with a tail.  Because it looks cooler.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Finally we have some logic which updates the eye position. When ","type":"SimpleText"},{"code":"eye_dir","type":"InlinedCode"},{"text":" is zero we move","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"left and when it is one we move right. At the boundaries we switch direction.","type":"SimpleText"}]}]},{"id":"testing","additionalIds":[],"title":"Testing","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Testing is pretty trivial. The only input is ","type":"SimpleText"},{"code":"enable","type":"InlinedCode"},{"text":" which we set to 1, and otherwise all","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"we have to do is print the outputs.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let test () =\n  let sim =\n    Circuit.create_exn\n      ~name:\"cylon_eye\"\n      (cylon_eye ~clock:(input \"clock\" 1) ~enable:(input \"enable\" 1)\n       |> List.mapi ~f:(fun i -> output [%string \"eye%{i#Int}\"]))\n    |> Cyclesim.create\n  in\n  let eyes = List.init 16 ~f:(fun i -> Cyclesim.out_port sim [%string \"eye%{i#Int}\"]) in\n  Cyclesim.in_port sim \"enable\" := Bits.vdd;\n  for _ = 1 to 40 do\n    Cyclesim.cycle sim;\n    List.iter eyes ~f:(fun e -> printf \"%i\" (Bits.to_unsigned_int !e));\n    printf \"\\n\"\n  done\n;;\n\nlet%expect_test \"\" =\n  test ();\n  [%expect\n    {|\n    7000000000000000\n    6700000000000000\n    5670000000000000\n    4567000000000000\n    3456700000000000\n    2345670000000000\n    1234567000000000\n    0123456700000000\n    0012345670000000\n    0001234567000000\n    0000123456700000\n    0000012345670000\n    0000001234567000\n    0000000123456700\n    0000000012345670\n    0000000001234567\n    0000000000123476\n    0000000000012765\n    0000000000007654\n    0000000000076543\n    0000000000765432\n    0000000007654321\n    0000000076543210\n    0000000765432100\n    0000007654321000\n    0000076543210000\n    0000765432100000\n    0007654321000000\n    0076543210000000\n    0765432100000000\n    7654321000000000\n    6743210000000000\n    5672100000000000\n    4567000000000000\n    3456700000000000\n    2345670000000000\n    1234567000000000\n    0123456700000000\n    0012345670000000\n    0001234567000000\n    |}]\n;;","lineNumber":"","type":"Snippet"}]},{"id":"real-world-considerations","additionalIds":[],"title":"Real World Considerations","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Lets say we clock this circuit at 100Mhz. It takes 30 cycles to scan left to right and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"back again, so that means we will do something like 3.33 million scans per second. That's","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"obviously not something we could actually see.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"This is why we included the enable signal. We can use it to slow down the scanning process","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"by only enabling it every so often.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The simplest way to do this is to define another counter and only enable the scan when the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"counter equals some value. If we want the scan to take 1 second we want to count to 3.33","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"million so we will need a 22 bit counter.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The second issue is that LEDs are driven by a single on/off value. So how do we show","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"intensity? For this we need to use a technique called Pulse Width Modulation (PWM). The","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"idea is that we will turn the LED on and off much faster than we can perceive and in","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"proportion to the intensity we want to show.  Here is our final design.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let cylon_eye_top ~scope ~enable_rate ~clock =\n  let spec = Reg_spec.create ~clock () in\n  let%hw_var enable = Always.Variable.reg spec ~width:1 in\n  let eyes = cylon_eye ~clock ~enable:enable.value in\n  let%hw_var count = Always.Variable.reg spec ~width:22 in\n  let leds =\n    List.init (List.length eyes) ~f:(fun _ -> Always.Variable.reg spec ~width:1)\n  in\n  Always.(\n    compile\n      [ (* Control the enable. *)\n        enable <-- gnd\n      ; count <-- count.value +:. 1\n      ; when_ (count.value ==:. enable_rate - 1) [ count <--. 0; enable <-- vdd ]\n      ; (* PWM for each LED. *)\n        proc\n          (List.map2_exn leds eyes ~f:(fun led eye ->\n             led <-- (eye >=: count.value.:[2, 0])))\n      ]);\n  List.map leds ~f:(fun led -> led.value)\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We made the rate at which the enable toggles a parameter called ","type":"SimpleText"},{"code":"enable_rate","type":"InlinedCode"},{"text":". We would","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"want to set this to ","type":"SimpleText"},{"code":"3_333_333","type":"InlinedCode"},{"text":" when generating hardware. For testing, we set it to ","type":"SimpleText"},{"code":"8","type":"InlinedCode"},{"text":" so","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"that we can see the PWM happening.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let test () =\n  let sim =\n    let scope = Scope.create ~flatten_design:true () in\n    let leds = cylon_eye_top ~scope ~enable_rate:8 ~clock:(input \"clock\" 1) in\n    Circuit.create_exn\n      ~name:\"cylon_eye\"\n      (List.mapi leds ~f:(fun i -> output (Printf.sprintf \"led%.2i\" i)))\n    |> Cyclesim.create ~config:Cyclesim.Config.trace_all\n  in\n  let waves, sim = Waveform.create sim in\n  for _ = 1 to 120 do\n    Cyclesim.cycle sim\n  done;\n  Waveform.expect_exact waves ~wave_width:(-2)\n;;\n\nlet%expect_test \"\" =\n  test ();\n  [%expect_exact\n    {|\n┌Signals───────────┐┌Waves───────────────────────────────────────────────────────────────┐\n│clock             ││╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥│\n│                  ││╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨│\n│enable            ││    ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥           │\n│                  ││────╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───        │\n│led00             ││╥   ╥───────╥──╥╥──┐╥─╥ ╥─┐ ╥╥  ╥   ╥   ╥   ╥   ╥   ╥   ╥           │\n│                  ││╨───╨       ╨  ╨╨  └╨ ╨─╨ └─╨╨──╨───╨───╨───╨───╨───╨───╨───        │\n│led01             ││╥   ╥   ╥───────╥──╥╥──┐╥─╥ ╥─┐ ╥╥  ╥   ╥   ╥   ╥   ╥   ╥           │\n│                  ││╨───╨───╨       ╨  ╨╨  └╨ ╨─╨ └─╨╨──╨───╨───╨───╨───╨───╨───        │\n│led02             ││╥   ╥   ╥   ╥───────╥──╥╥──┐╥─╥ ╥─┐ ╥╥  ╥   ╥   ╥   ╥   ╥           │\n│                  ││╨───╨───╨───╨       ╨  ╨╨  └╨ ╨─╨ └─╨╨──╨───╨───╨───╨───╨───        │\n│led03             ││╥   ╥   ╥   ╥   ╥───────╥──╥╥──┐╥─╥ ╥─┐ ╥╥  ╥   ╥   ╥   ╥           │\n│                  ││╨───╨───╨───╨───╨       ╨  ╨╨  └╨ ╨─╨ └─╨╨──╨───╨───╨───╨───        │\n│led04             ││╥   ╥   ╥   ╥   ╥   ╥───────╥──╥╥──┐╥─╥ ╥─┐ ╥╥  ╥   ╥   ╥           │\n│                  ││╨───╨───╨───╨───╨───╨       ╨  ╨╨  └╨ ╨─╨ └─╨╨──╨───╨───╨───        │\n│led05             ││╥   ╥   ╥   ╥   ╥   ╥   ╥───────╥──╥╥──┐╥─╥ ╥─┐ ╥╥  ╥   ╥           │\n│                  ││╨───╨───╨───╨───╨───╨───╨       ╨  ╨╨  └╨ ╨─╨ └─╨╨──╨───╨───        │\n│led06             ││╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥───────╥──╥╥──┐╥─╥ ╥─┐ ╥╥  ╥           │\n│                  ││╨───╨───╨───╨───╨───╨───╨───╨       ╨  ╨╨  └╨ ╨─╨ └─╨╨──╨───        │\n│led07             ││╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥───────╥──╥╥──┐╥─╥ ╥─┐ ╥╥          │\n│                  ││╨───╨───╨───╨───╨───╨───╨───╨───╨       ╨  ╨╨  └╨ ╨─╨ └─╨╨──        │\n│led08             ││╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥───────╥──╥╥──┐╥─╥ ╥─┐         │\n│                  ││╨───╨───╨───╨───╨───╨───╨───╨───╨───╨       ╨  ╨╨  └╨ ╨─╨ └─        │\n│led09             ││╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥───────╥──╥╥──┐╥─╥         │\n│                  ││╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨       ╨  ╨╨  └╨ ╨─        │\n│led10             ││╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥───────╥──╥╥──┐        │\n│                  ││╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨       ╨  ╨╨  └        │\n│led11             ││╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥───────╥──╥        │\n│                  ││╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨       ╨  ╨        │\n│led12             ││╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥───────        │\n│                  ││╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨               │\n│led13             ││╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥───        │\n│                  ││╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨           │\n│led14             ││╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥           │\n│                  ││╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───        │\n│led15             ││╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥   ╥           │\n│                  ││╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───        │\n│                  ││╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥╥        │\n│count             ││║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║║        │\n│                  ││╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨╨        │\n│gnd               ││                                                                    │\n│                  ││────────────────────────────────────────────────────────────        │\n│vdd               ││────────────────────────────────────────────────────────────        │\n│                  ││                                                                    │\n└──────────────────┘└────────────────────────────────────────────────────────────────────┘\n23a1bb8cebaa916241e49f8dd3880407\n|}]\n;;","lineNumber":"","type":"Snippet"},{"type":"BlockQuote","content":[{"type":"Paragraph","content":[{"text":"📝 There is sometimes a maximum rate at which we should drive a PWM signal. I am not","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"sure it applies to LEDs but it is easily adjustable by changing the PWM code as follows","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"led <-- (eye >=: count.value.:[12, 10])","type":"InlinedCode"},{"text":". This will slow down the toggling but will","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"still drive the same average power.","type":"SimpleText"}]}]}]}],"lastModifiedTime":1750709443632,"tocItem":{"chapterTitle":"More On Circuit Design","pageTitle":"4.2.2 Cylon Eye","pageMeta":{"parent":["always.mdx"],"title":["4.2.2 Cylon Eye"],"uuid":["e4a336f2-0962-3b32-0066-8b93b3e7dd70"]},"dirName":"more-on-circuit-design","fileName":"cylon_eye","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Implementation","id":"implementation","customAnchorId":"implementation"},{"title":"Testing","id":"testing","customAnchorId":"testing"},{"title":"Real World Considerations","id":"real-world-considerations","customAnchorId":"real-world-considerations"}]}},{"type":"Page","content":[{"id":"writing-state-machines","additionalIds":[],"title":"Writing State Machines","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Always/index.html","isFile":false,"type":"Link","content":[{"text":"Always DSL","type":"SimpleText"}]},{"type":"SoftLineBreak"},{"text":"is most commonly used to construct state machines or","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"non-trivial sequential logic. Hardcaml is shipped with an","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Always/State_machine/index.html","isFile":false,"type":"Link","content":[{"code":"Always.State_machine","type":"InlinedCode"}]},{"type":"SoftLineBreak"},{"text":"module to help create state machines.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"A state machine is constructed with the following function:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# open Base\n# open Hardcaml\n# open Signal\n# Always.State_machine.create\n- : ?encoding:Always.State_machine.Encoding.t ->\n    ?auto_wave_format:bool ->\n    ?attributes:Hardcaml.Rtl_attribute.t list ->\n    ?enable:t ->\n    ?unreachable:'a list ->\n    (module Hardcaml.Always.State_machine.State with type t = 'a) ->\n    Reg_spec.t -> 'a Always.State_machine.t\n= <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The value returned can be used within an ","type":"SimpleText"},{"type":"Emphasis","content":[{"text":"Always block","type":"SimpleText"}]},{"text":".","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Let's look at an example.","type":"SimpleText"}]},{"id":"writing-state-machines-defining-the-state-type","additionalIds":["defining-the-state-type"],"level":2,"title":"Defining the state type","type":"SubHeading"},{"lang":"ocaml","snippet":"module States = struct\n  type t =\n    | Wait_for_start\n    | Process_something\n    | Process_something_else\n  [@@deriving sexp_of, compare, enumerate]\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"code":"States","type":"InlinedCode"},{"text":" type must use the ","type":"SimpleText"},{"code":"sexp_of","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"compare","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"enumerate","type":"InlinedCode"},{"text":" derivers","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"when defining a state machine.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"This state machine will begin in the state ","type":"SimpleText"},{"code":"Wait_for_start","type":"InlinedCode"},{"text":" and wait","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"for an external ","type":"SimpleText"},{"code":"start","type":"InlinedCode"},{"text":" signal. It will then transition to","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Process_something","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"Process_something_else","type":"InlinedCode"},{"text":" and back to","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Wait_for_start","type":"InlinedCode"},{"text":". Just before transitioning back to ","type":"SimpleText"},{"code":"Wait_for_start","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"it will pulse a done signal.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Although nothing useful is actually implemented here, we could imagine","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the processing states were waiting for network data, accessing a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"RAM, or performing some multi-step computation.","type":"SimpleText"}]},{"id":"writing-state-machines-implementing-the-state-machine","additionalIds":["implementing-the-state-machine"],"level":2,"title":"Implementing the state machine","type":"SubHeading"},{"lang":"ocaml","snippet":"let clock = Signal.input \"clock\" 1\nlet clear = Signal.input \"clear\" 1\nlet r_sync = Reg_spec.create ~clock ~clear ()\nlet start = Signal.input \"start\" 1\n\nlet outputs =\n  let open Signal in\n  let sm =\n    Always.State_machine.create (module States) ~enable:vdd r_sync\n  in\n  let done_ = Always.Variable.wire ~default:gnd () in\n  Always.(compile [\n    sm.switch [\n      Wait_for_start, [\n        when_ start [\n          sm.set_next Process_something;\n        ]\n      ];\n\n      Process_something, [\n        sm.set_next Process_something_else\n      ];\n\n      Process_something_else, [\n        done_ <--. 1;\n        sm.set_next Wait_for_start;\n      ]\n    ]\n  ]);\n  [ Signal.output \"done\" done_.value\n  ; (* We output the [state] to help with visualizing in the\n        simulation examples that follows. *)\n    Signal.output \"state\" sm.current\n  ]\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Notice the ","type":"SimpleText"},{"code":"Always.compile","type":"InlinedCode"},{"text":" function call surrounding the Always","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"DSL. Let's look at its type signature:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# Always.compile\n- : Always.t list -> unit = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"What? It returns a unit type, so how do we retrieve the variable's","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"values? Under the hood, the always DSL creates regular Hardcaml wires","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"with an empty assignment. The call to ","type":"SimpleText"},{"code":"Always.compile","type":"InlinedCode"},{"text":" will assign","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"these wires with the appropriate signals according to the conditions","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"specified in the always block. For more information about wires, see","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the ","type":"SimpleText"},{"url":"/hardcaml-docs/designing-circuits/sequential_logic","isFile":false,"type":"Link","content":[{"text":"Sequential Logic","type":"SimpleText"}]},{"text":" section. In particular,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"unassigned wires are fairly common if you miss a variable","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"assignment.","type":"SimpleText"}]},{"id":"writing-state-machines-simulation","additionalIds":["simulation"],"level":2,"title":"Simulation","type":"SubHeading"},{"type":"Paragraph","content":[{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Cyclesim/index.html","isFile":false,"type":"Link","content":[{"text":"Simulating","type":"SimpleText"}]},{"type":"SoftLineBreak"},{"text":"a state machine is no different from simulating any other","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Hardcaml circuit. Let's walk through an example to see the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Always DSL in action.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let () =\n    let circuit = Circuit.create_exn ~name:\"test_statemachine\" outputs in\n    let sim = Cyclesim.create circuit in\n    let print_state_and_outputs () =\n      let state =\n        List.nth_exn States.all (Bits.to_unsigned_int !(Cyclesim.out_port sim \"state\"))\n      in\n      let done_ = Bits.to_bool !(Cyclesim.out_port sim \"done\") in\n      Stdio.print_s [%message\n        (state : States.t) (done_ : bool)\n      ]\n    in\n\n    Cyclesim.reset sim;\n    Cyclesim.in_port sim \"clear\" := Bits.vdd;\n    Cyclesim.cycle sim;\n    print_state_and_outputs ();\n    Cyclesim.in_port sim \"clear\" := Bits.gnd;\n\n    Cyclesim.in_port sim \"start\" := Bits.vdd;\n    Cyclesim.cycle sim;\n    print_state_and_outputs ();\n    Cyclesim.in_port sim \"start\" := Bits.gnd;\n\n    Cyclesim.cycle sim;\n    print_state_and_outputs ();\n\n    Cyclesim.cycle sim;\n    print_state_and_outputs ()\n  ;;\n((state Wait_for_start) (done_ false))\n((state Process_something) (done_ false))\n((state Process_something_else) (done_ true))\n((state Wait_for_start) (done_ false))","lineNumber":"","type":"Snippet"}]},{"id":"metaprogramming-with-the-always-dsl","additionalIds":[],"title":"Metaprogramming with the Always DSL","type":"Section","content":[{"type":"Paragraph","content":[{"text":"As mentioned above, the","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Always/index.html","isFile":false,"type":"Link","content":[{"text":"Always DSL","type":"SimpleText"}]},{"type":"SoftLineBreak"},{"text":"is simply an ","type":"SimpleText"},{"code":"Always.t list","type":"InlinedCode"},{"text":". The gives room for several creative behaviors.","type":"SimpleText"}]},{"id":"metaprogramming-with-the-always-dsl-function-abstractions","additionalIds":["function-abstractions"],"level":2,"title":"Function abstractions","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Since we are really just generating ","type":"SimpleText"},{"code":"Always.t","type":"InlinedCode"},{"text":" lists from OCaml code,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"we can simply split out some parts of the DSL into different","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"functions. For example:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"(* A useful mental model above is to treat `foo_branch` as a \"C void\n   function\" that takes a pointer to write its output value to.\n*)\nlet foo_branch (o_value : Hardcaml.Always.Variable.t) =\n  let open Signal in\n  let foo = Always.Variable.reg ~enable:vdd  ~width:32 r_sync in\n  Always.[\n    foo <-- (foo.value +:. 1);\n    o_value <-- foo.value;\n  ]\n;;\n\nlet main : Always.t list =\n  let cond = Signal.input \"cond\" 1 in\n  let o_value = Always.Variable.wire ~default:(Signal.zero 32) () in\n  Always.[\n    if_ cond [\n      (* [proc] turns a [Always.t list] to an [Always.t], without\n         changing any semantic meaning of the program.\n      *)\n      proc (foo_branch o_value);\n    ] [\n      o_value <--. 0;\n    ]\n  ]\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"A few interesting things are happening here:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"We can call ","type":"SimpleText"},{"code":"foo_branch","type":"InlinedCode"},{"text":" as many times as we want.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Every call to ","type":"SimpleText"},{"code":"foo_branch","type":"InlinedCode"},{"text":" creates a new instance of an accumulator","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"register.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"The caller doesn't know (and doesn't care) that ","type":"SimpleText"},{"code":"foo_branch","type":"InlinedCode"},{"text":" created","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"a new variable under the hood. This is akin to function closures in","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"functional programming, a powerful concept made possible in the Always DSL.","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"Bearing in mind that we are still generating hardware (so all","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"variables in functions are really more like \"static variables\" in C), this","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"\"function abstraction\" is a powerful way of making repetitive /","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"complicated state machines much more comprehensible.","type":"SimpleText"}]},{"id":"metaprogramming-with-the-always-dsl-advanced-high-order-blocks","additionalIds":["advanced-high-order-blocks"],"level":2,"title":"(Advanced) \"High-order\" blocks","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"What if we want to create functional blocks that are only executed","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"under a set of non-trivial preconditions?","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"For example - processing data received from some hand-shaking","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"protocol. In this example, we consider a trivial case where only an","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"accept","type":"InlinedCode"},{"text":" signal is required.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"type stream =\n  { valid : Signal.t\n  ; data : Signal.t\n  ; accept : Always.Variable.t\n  }\n\nlet handshake stream callback =\n  Always.(proc [\n    when_ stream.valid [\n      stream.accept <--. 1;\n      proc (callback stream.data);\n    ]\n  ])\n;;\n\nlet main (stream_a : stream) (stream_b : stream) =\n  let foo = Always.Variable.wire ~default:Signal.gnd () in\n  let bar = Always.Variable.wire ~default:Signal.gnd () in\n  Always.compile [\n    handshake stream_a (fun data ->\n      Always.[\n        foo <-- data\n      ]\n    );\n\n    handshake stream_b (fun data ->\n      Always.[\n        foo <--. 0;\n        bar <-- ~:(data)\n      ]\n    );\n  ]\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The beauty in this approach is that the repetitive","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"hand-shaking code is replaced with a high order function call. On top","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"of that if the handshaking protocol is modified, we can simply update","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the ","type":"SimpleText"},{"code":"handshake","type":"InlinedCode"},{"text":" function without having to rewrite it everywhere it is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"used.","type":"SimpleText"}]}]}],"lastModifiedTime":1750709443727,"tocItem":{"chapterTitle":"More On Circuit Design","pageTitle":"4.3 Designing State Machines","pageMeta":{"parent":["more_design.mdx"],"title":["4.3 Designing State Machines"],"uuid":["16db66d0-f5cb-3457-82c3-07088c26797c"]},"dirName":"more-on-circuit-design","fileName":"state_machine_always_api","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Writing State Machines","id":"writing-state-machines","customAnchorId":"writing-state-machines"},{"title":"Metaprogramming with the Always DSL","id":"metaprogramming-with-the-always-dsl","customAnchorId":"metaprogramming-with-the-always-dsl"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"In this example we will explore the implementation of a sequence detector. The hardware","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"will take in one bit per cycle and raise a ","type":"SimpleText"},{"code":"detect","type":"InlinedCode"},{"text":" signal when it sees a specific","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"sequence of bits.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Below we have implemented an example in Verilog, VHDL and Hardcaml for comparison. The","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"sequence detected is ","type":"SimpleText"},{"code":"101","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"id":"verilog","additionalIds":[],"level":3,"title":"Verilog","type":"SubHeading"},{"lang":"verilog","snippet":"module sequence_detector (\n  input clock, clear, d,\n  output reg detect\n);\n\n  localparam \n    S1 = 0, \n    S10 = 1, \n    S101 = 2;\n\n  reg [1:0] state;\n\n  always @(posedge clock) \n    if (clear) begin \n      state <= S1;\n      detect <= 0;\n    end else begin\n      case (state)\n        S1: \n          if (d) state <= S10;\n          else state <= S1;\n        S10: \n          if (d) state <= S1;\n          else state <= S101;\n        S101: \n          state <= S1;\n      endcase\n\n      detect <= (state == S101) & d;\n    end\n\nendmodule","lineNumber":"","type":"Snippet"},{"id":"vhdl","additionalIds":[],"level":3,"title":"VHDL","type":"SubHeading"},{"lang":"vhdl","snippet":"library ieee;\nuse ieee.std_logic_1164.all;\n\nentity sequence_detector_vhdl is\n  port (\n    clock, clear, d : in std_logic;\n    detect : out std_logic\n  );\nend entity;\n\narchitecture rtl of sequence_detector_vhdl is\n\n  type state_t is (S1, S10, S101);\n  signal state : state_t;\n\nbegin\n\n  process (clock) begin\n    if rising_edge(clock) then \n      if clear = '1' then \n        state <= S1;\n        detect <= '0';\n      else\n        case (state) is\n          when S1 => \n            if d = '1' then state <= S10;\n            else state <= S1;\n            end if;\n          when S10 => \n            if d = '1' then state <= S1;\n            else state <= S101;\n            end if;\n          when S101 => \n            state <= S1;\n        end case;\n\n        if state = S101 and d = '1' then\n          detect <= '1';\n        else\n          detect <= '0';\n        end if;\n      end if;\n    end if;\n  end process;\n\nend architecture;","lineNumber":"","type":"Snippet"},{"id":"hardcaml","additionalIds":[],"level":3,"title":"Hardcaml","type":"SubHeading"},{"lang":"ocaml","snippet":"module State = struct\n  type t =\n    | S1\n    | S10\n    | S101\n  [@@deriving sexp_of, compare ~localize, enumerate]\nend\n\nlet create ~clock ~clear ~d =\n  let spec = Reg_spec.create ~clock ~clear () in\n  let sm = Always.State_machine.create (module State) spec in\n  Always.(\n    compile\n      [ sm.switch\n          [ S1, [ if_ d [ sm.set_next S10 ] [ sm.set_next S1 ] ]\n          ; S10, [ if_ d [ sm.set_next S1 ] [ sm.set_next S101 ] ]\n          ; S101, [ sm.set_next S1 ]\n          ]\n      ]);\n  reg spec (sm.is S101 &: d)\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"In each state we transition to the next matching state if the input data is expected or","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"return to ","type":"SimpleText"},{"code":"S1","type":"InlinedCode"},{"text":" if not. When we are in the final state ","type":"SimpleText"},{"code":"S101","type":"InlinedCode"},{"text":" we check the input is correct","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"and set the ","type":"SimpleText"},{"code":"detect","type":"InlinedCode"},{"text":" output.","type":"SimpleText"}]},{"id":"testing","additionalIds":[],"title":"Testing","type":"Section","content":[{"lang":"ocaml","snippet":"# let test bits = \n    let sim = create_sequence_detector_sim () in\n    let waves, sim = Waveform.create sim in\n    let d = Cyclesim.in_port sim \"d\" in\n    List.iter (Bits.bits_lsb bits) ~f:(fun bit ->\n      d := bit;\n      Cyclesim.cycle sim); \n    Cyclesim.cycle sim;\n    Waveform.print waves ~wave_width:1 ~display_width:40\nval test : Bits.t -> unit = <fun>\n# test (Bits.of_string \"101\")\n┌Signals─┐┌Waves───────────────────────┐\n│clock   ││┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ │\n│        ││  └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─│\n│clear   ││                            │\n│        ││────────────────            │\n│d       ││────┐   ┌───────            │\n│        ││    └───┘                   │\n│detect  ││            ┌───            │\n│        ││────────────┘               │\n└────────┘└────────────────────────────┘\n- : unit = ()\n# test (Bits.of_string \"1010\")\n┌Signals─┐┌Waves───────────────────────┐\n│clock   ││┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ │\n│        ││  └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─│\n│clear   ││                            │\n│        ││────────────────────        │\n│d       ││    ┌───┐   ┌───────        │\n│        ││────┘   └───┘               │\n│detect  ││                ┌───        │\n│        ││────────────────┘           │\n└────────┘└────────────────────────────┘\n- : unit = ()\n# test (Bits.of_string \"1011\")\n┌Signals─┐┌Waves───────────────────────┐\n│clock   ││┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ │\n│        ││  └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─│\n│clear   ││                            │\n│        ││────────────────────        │\n│d       ││────────┐   ┌───────        │\n│        ││        └───┘               │\n│detect  ││                            │\n│        ││────────────────────        │\n└────────┘└────────────────────────────┘\n- : unit = ()","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"As we see the first two test sequences are correctly detected. However, the third one is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"not.  Can you see why?","type":"SimpleText"}]}]},{"id":"parameterizing-over-the-sequence","additionalIds":[],"title":"Parameterizing over the Sequence","type":"Section","content":[{"type":"Paragraph","content":[{"text":"In the following code we make the circuit parameterized over the sequence we wish to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"detect. The code is pretty similar to before - the interesting bit is that the number","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"states required is determined by the sequence length we need to match against.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let next_states sequence cur_state =\n  let sequence_length = Bits.width sequence in\n  (cur_state + 1) % sequence_length, 0\n;;\n\nlet create ~sequence ~clock ~clear ~d =\n  let sequence_length = Bits.width sequence in\n  let module State = struct\n    type t = int [@@deriving compare ~localize, sexp_of]\n\n    (* Valid states are integers in the range [0..sequence_length-1]. *)\n    let all = List.init sequence_length ~f:Fn.id\n  end\n  in\n  let spec = Reg_spec.create ~clock ~clear () in\n  let sm = Always.State_machine.create (module State) spec in\n  Always.(\n    compile\n      [ sm.switch\n          (List.init sequence_length ~f:(fun cur_state ->\n             ( cur_state\n             , let t, f = next_states sequence cur_state in\n               let t, f =\n                 (* Swap the states if the match bit is [0]. *)\n                 if Bits.to_bool sequence.Bits.:(cur_state) then t, f else f, t\n               in\n               [ if_ d [ sm.set_next t ] [ sm.set_next f ] ] )))\n      ]);\n  (* Decode the [detect] result - we are in the final state and the last bit matches. *)\n  reg\n    spec\n    (sm.is (sequence_length - 1)\n     &: if Bits.to_bool sequence.Bits.:(sequence_length - 1) then d else ~:d)\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"code":"State","type":"InlinedCode"},{"text":" module specifies a number of states equal to the length of ","type":"SimpleText"},{"code":"sequence","type":"InlinedCode"},{"text":". This is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"done in the definition of the ","type":"SimpleText"},{"code":"all","type":"InlinedCode"},{"text":" value.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The implementation of each state is built dynamically. They are all of the form","type":"SimpleText"}]},{"lang":"","snippet":"[ if_ d [ sm.set_next t] [sm.set_next f] ]","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The function ","type":"SimpleText"},{"code":"next_states","type":"InlinedCode"},{"text":" returns the states to transition to if the input is valid or","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"invalid. Note we swap them depending on if we expect to match a ","type":"SimpleText"},{"code":"0","type":"InlinedCode"},{"text":" or a ","type":"SimpleText"},{"code":"1","type":"InlinedCode"},{"text":".","type":"SimpleText"}]}]},{"id":"fixing-the-matching-problem","additionalIds":[],"title":"Fixing the Matching Problem","type":"Section","content":[{"type":"Paragraph","content":[{"text":"We noted a problem that we don't match all sequences properly. The problem is caused by","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the state machine always returning to the initial state if the current input bit doesn't","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"match. It is possible, however, that we should return to some earlier state which","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"partially matches the input sequence.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"In the previous example we input the sequence ","type":"SimpleText"},{"code":"1->1->0->1","type":"InlinedCode"},{"text":" and it didn't match.  Consider what happens:","type":"SimpleText"}]},{"delimiter":".","startNumber":1,"type":"OrderedList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"We get the first ","type":"SimpleText"},{"code":"1","type":"InlinedCode"},{"text":" and transition to ","type":"SimpleText"},{"code":"S10","type":"InlinedCode"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"We get a ","type":"SimpleText"},{"code":"1","type":"InlinedCode"},{"text":" and transition to ","type":"SimpleText"},{"code":"S1","type":"InlinedCode"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"We get a ","type":"SimpleText"},{"code":"0","type":"InlinedCode"},{"text":" and stay in ","type":"SimpleText"},{"code":"S1","type":"InlinedCode"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"We get a ","type":"SimpleText"},{"code":"1","type":"InlinedCode"},{"text":" and transition to ","type":"SimpleText"},{"code":"S10","type":"InlinedCode"}]}]}]},{"type":"Paragraph","content":[{"text":"We didn't match.  What we should do is","type":"SimpleText"}]},{"delimiter":".","startNumber":1,"type":"OrderedList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"We get the first ","type":"SimpleText"},{"code":"1","type":"InlinedCode"},{"text":" and transition to ","type":"SimpleText"},{"code":"S10","type":"InlinedCode"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"We get a ","type":"SimpleText"},{"code":"1","type":"InlinedCode"},{"text":" and stay in ","type":"SimpleText"},{"code":"S10","type":"InlinedCode"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"We get a ","type":"SimpleText"},{"code":"0","type":"InlinedCode"},{"text":" and transition to ","type":"SimpleText"},{"code":"S101","type":"InlinedCode"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"We get a ","type":"SimpleText"},{"code":"1","type":"InlinedCode"},{"text":" and set ","type":"SimpleText"},{"code":"detect","type":"InlinedCode"}]}]}]},{"type":"Paragraph","content":[{"text":"To this fix we need to find the state which matches the longest prefix of our sequence","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"when the input bit does not match. We can do this by modifying our ","type":"SimpleText"},{"code":"next_states","type":"InlinedCode"},{"text":" function.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"There is actually a further problem - when we get a sequence match that may actually form","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"a prefix for the next match i.e. consider matching ","type":"SimpleText"},{"code":"111","type":"InlinedCode"},{"text":" against ","type":"SimpleText"},{"code":"1111","type":"InlinedCode"},{"text":" there are two","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"matches adjacent to each other.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"So, there are two cases in which we must find the longest partial match and move to the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"state that represents it.","type":"SimpleText"}]},{"delimiter":".","startNumber":1,"type":"OrderedList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"If the current input bit doesn't match the sequence","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"or if we are in the last state and the bit does match","type":"SimpleText"}]}]}]},{"lang":"ocaml","snippet":"let find_prev_match match_bit sequence cur_state =\n  let open Bits in\n  if cur_state = 0\n  then 0\n  else (\n    let sequence = sequence.:[cur_state - 1, 0] in\n    let rec find cur_state sequence match_ =\n      if cur_state = 0\n      then 0\n      else if Bits.equal sequence match_\n      then cur_state\n      else if cur_state = 1\n      then 0\n      else find (cur_state - 1) (lsbs sequence) (msbs match_)\n    in\n    find cur_state sequence (msbs (match_bit @: sequence)))\n;;\n\nlet next_states sequence cur_state =\n  let open Bits in\n  let sequence_length = width sequence in\n  let on_match =\n    if cur_state = sequence_length - 1\n    then find_prev_match sequence.:(cur_state) sequence cur_state\n    else (cur_state + 1) % sequence_length\n  in\n  let no_match = find_prev_match ~:sequence.:(cur_state) sequence cur_state in\n  on_match, no_match\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"It is important to note that we are not actually generating any hardware here - we are","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"performing calculations to define what hardware we should generate.","type":"SimpleText"}]}]},{"id":"building-a-test-harness","additionalIds":[],"title":"Building a Test Harness","type":"Section","content":[{"type":"Paragraph","content":[{"text":"We now want to show that the fixes we made have actually worked. To do this we will create","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"a self checking testbench.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The idea is we will run a sequence of bits through the detector module and record every","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"place it finds a match. We will compare this against a software reference model and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"compare the two results. We can then run a bunch of random tests and make sure everything","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"is correct.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Lets start off by creating the software reference model.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let software_reference sequence bits =\n  let open Bits in\n  List.init\n    (width bits - width sequence + 1)\n    ~f:(fun pos ->\n      if to_bool (bits.:[width sequence + pos - 1, pos] ==: sequence)\n      then Some pos\n      else None)\n  |> List.filter_opt\n  (* We find the first bit of the match, but the hardware will find the last bit so offset\n     it by the length of the sequence. *)\n  |> List.map ~f:(fun d -> d + width sequence - 1)\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We can now write a testbench that runs the sequence detector and collects all the matches","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"it sees.  It compares against the software model and raises if they do not agree.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let test ~sequence ~data_in =\n  let sim = create_sequence_detector_sim ~sequence in\n  let d = Cyclesim.in_port sim \"d\" in\n  let detect = Cyclesim.out_port sim \"detect\" in\n  let open Bits in\n  let cycles = width data_in in\n  let results = ref [] in\n  for i = 0 to cycles - 1 do\n    d := data_in.:(i);\n    Cyclesim.cycle sim;\n    if Bits.to_bool !detect then results := i :: !results\n  done;\n  let results = List.rev !results in\n  let expected = software_reference sequence data_in in\n  if not (List.equal Int.equal results expected)\n  then\n    raise_s\n      [%message\n        (sequence : Bits.t) (data_in : Bits.t) (results : int list) (expected : int list)]\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Now we can run some random tests across different sequences.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let%expect_test \"check random sequences\" =\n  for _ = 0 to 10 do\n    let sequence = Bits.random ~width:(1 + Random.int 5) in\n    for _ = 0 to 100 do\n      let data_in = Bits.random ~width:(Bits.width sequence + Random.int 100) in\n      test ~sequence ~data_in\n    done\n  done\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709443387,"tocItem":{"chapterTitle":"More On Circuit Design","pageTitle":"4.3.1 Sequence Detector","pageMeta":{"parent":["state_machine_always_api.mdx"],"title":["4.3.1 Sequence Detector"],"uuid":["7916e3b7-e702-3832-4328-5f135816945f"]},"dirName":"more-on-circuit-design","fileName":"sequence_detector","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Testing","id":"testing","customAnchorId":"testing"},{"title":"Parameterizing over the Sequence","id":"parameterizing-over-the-sequence","customAnchorId":"parameterizing-over-the-sequence"},{"title":"Fixing the Matching Problem","id":"fixing-the-matching-problem","customAnchorId":"fixing-the-matching-problem"},{"title":"Building a Test Harness","id":"building-a-test-harness","customAnchorId":"building-a-test-harness"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"We previously saw how to convert a BCD value to binary using a simple multiply by 10","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"scheme. We'd now like to convert the other way - from binary to BCD.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Conceptually this is a bit harder to achieve - we could do division by 10 with remainder","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"to calculate the result, but we tend to shy away from dividers where possible in hardware","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"(to be fair an iterative divider would probably work). It turns out there is a clever way","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"of doing this called the Double Dabble algorithm (no, really!).","type":"SimpleText"}]},{"id":"double-then-dabble","additionalIds":[],"title":"Double, then Dabble","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The idea is we form a large shift register with the BCD values at the MSB and the binary value at the LSB.","type":"SimpleText"}]},{"lang":"","snippet":"[BCDN]...[BCD1][BCD0][...BINARY..]","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We shift the whole thing left by one bit (this is the double part), then run through each","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"of the 4 bit BCD values and if it is greater then 4, add 3. Repeat for all the bits in the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"input binary value.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"One way to think of this is we are bypassing the carry logic of a normal binary number and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"adding a special value which, upon doubling, will correctly overflow into the next BCD","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"digit.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The algorithm is shown below - while the idea is not complicated there is a bunch of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"annoying bit fiddling going on in order to pack and then extract the appropriate bits from","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"an int value.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let double_dabble value =\n  let digits = String.length (Int.to_string value) in\n  let num_bits = Int.ceil_log2 (value + 1) in\n  let value = ref value in\n  for _ = 0 to num_bits - 1 do\n    for j = 0 to digits - 1 do\n      let digit = (!value lsr (num_bits + (j * 4))) land 0xf in\n      if digit >= 5 then value := !value + (3 lsl (num_bits + (j * 4)))\n    done;\n    value := !value lsl 1\n  done;\n  let bcd = !value lsr num_bits in\n  List.init digits ~f:(fun i -> (bcd lsr (i * 4)) land 0xf)\n  |> List.rev\n  |> List.map ~f:(fun i -> Char.of_int_exn (i + Char.to_int '0'))\n  |> String.of_char_list\n;;\n\nlet%expect_test \"Test algorithm\" =\n  for i = 0 to 1000 do\n    assert (String.equal (Int.to_string i) (double_dabble i))\n  done;\n  [%expect {| |}]\n;;","lineNumber":"","type":"Snippet"}]},{"id":"implementing-the-hardware","additionalIds":[],"title":"Implementing the Hardware","type":"Section","content":[{"type":"Paragraph","content":[{"text":"A state machine will implement the algorithm.  There are 3 states","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"Start","type":"InlinedCode"},{"text":" - wait for a ","type":"SimpleText"},{"code":"start","type":"InlinedCode"},{"text":" signal to be valid along with the binary value to convert.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"Double","type":"InlinedCode"},{"text":" - shift the binary value and all the BCD digits up by 1 bits. Go to ","type":"SimpleText"},{"code":"Start","type":"InlinedCode"},{"text":" if","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"all the input bits are processed, otherwise go to ","type":"SimpleText"},{"code":"Dabble","type":"InlinedCode"},{"text":".","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"Dabble","type":"InlinedCode"},{"text":" - iterate through the BCD digits - if the value is greater than 4 then add 3.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Go back to ","type":"SimpleText"},{"code":"Double","type":"InlinedCode"},{"text":".","type":"SimpleText"}]}]}]},{"lang":"ocaml","snippet":"module Make (Digits : sig\n    val num_digits : int\n  end) =\nstruct\n  open Digits\n\n  (* Bits required to represent [999...999]. *)\n  let binary_bits = num_bits_to_represent (Int.pow 10 num_digits - 1)\n\n  module State = struct\n    type t =\n      | Start\n      | Double\n      | Dabble\n    [@@deriving sexp_of, compare ~localize, enumerate]\n  end\n\n  let create ~clock ~start ~binary_in =\n    let spec = Reg_spec.create ~clock () in\n    (* Registers to latch the input binary value and count through it's bits. *)\n    let binary = Always.Variable.reg spec ~width:binary_bits in\n    let bit_count = Always.Variable.reg spec ~width:(Int.ceil_log2 binary_bits) in\n    (* Register to count through digits while dabbling. *)\n    let digit_count = Always.Variable.reg spec ~width:(Int.ceil_log2 num_digits) in\n    (* One digit count to use as a register write enable for the BCD digits. *)\n    let digit_count_one_hot = binary_to_onehot digit_count.value in\n    (* Registers for the BCD digit. *)\n    let bcd = Array.init num_digits ~f:(fun _ -> Always.Variable.reg spec ~width:4) in\n    (* Dabbling logic - look up the current BCD digit and perform dabble operation if\n       greater than 4. *)\n    let bcd_dabbled =\n      let digit =\n        mux digit_count.value (List.map (Array.to_list bcd) ~f:(fun bcd -> bcd.value))\n      in\n      mux2 (digit >:. 4) (digit +:. 3) digit\n    in\n    (* Statemachine *)\n    let sm = Always.State_machine.create (module State) spec in\n    Always.(\n      compile\n        [ sm.switch\n            [ ( Start\n              , [ (* Wait for start. *)\n                  bit_count <--. 0\n                ; binary <-- binary_in\n                ; proc (List.init num_digits ~f:(fun digit -> bcd.(digit) <--. 0))\n                ; when_ start [ sm.set_next Double ]\n                ] )\n            ; ( Double\n              , [ (* Shift in the next binary bit through all the BCD registers. *)\n                  binary <-- sll binary.value ~by:1\n                ; proc\n                    (List.init num_digits ~f:(fun digit ->\n                       bcd.(digit)\n                       <-- lsbs bcd.(digit).value\n                           @:\n                           if digit = 0\n                           then msb binary.value\n                           else msb bcd.(digit - 1).value))\n                ; digit_count <--. 0\n                ; bit_count <-- bit_count.value +:. 1\n                ; (* Count through all the input binary bits. *)\n                  if_\n                    (bit_count.value ==:. binary_bits - 1)\n                    [ sm.set_next Start ]\n                    [ sm.set_next Dabble ]\n                ] )\n            ; ( Dabble\n              , [ (* Iterate through each digit and perform the dabble operation. *)\n                  digit_count <-- digit_count.value +:. 1\n                ; proc\n                    (List.init num_digits ~f:(fun digit ->\n                       when_ digit_count_one_hot.:(digit) [ bcd.(digit) <-- bcd_dabbled ]))\n                ; when_ (digit_count.value ==:. num_digits - 1) [ sm.set_next Double ]\n                ] )\n            ]\n        ]);\n    sm.is Start, Array.map bcd ~f:(fun bcd -> bcd.value)\n  ;;\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"In ","type":"SimpleText"},{"code":"Double","type":"InlinedCode"},{"text":" we need to shift up the BCD values. This is done by selecting the msb of the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"previous bcd register and shifting it in - expect for index 0 where we select the msb of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the input binary value.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"In ","type":"SimpleText"},{"code":"Dabble","type":"InlinedCode"},{"text":" we iterate through each BCD digit - if we have 3 digits, it will take 3","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"cycles. On each cycle we use ","type":"SimpleText"},{"code":"digit_count_one_hot","type":"InlinedCode"},{"text":" to enable the write to the appropriate","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"BCD digit register. This is created using the ","type":"SimpleText"},{"code":"binary_to_onehot","type":"InlinedCode"},{"text":" function which converts","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"values as follows:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"00","type":"InlinedCode"},{"text":" -> ","type":"SimpleText"},{"code":"0001","type":"InlinedCode"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"01","type":"InlinedCode"},{"text":" -> ","type":"SimpleText"},{"code":"0010","type":"InlinedCode"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"10","type":"InlinedCode"},{"text":" -> ","type":"SimpleText"},{"code":"0100","type":"InlinedCode"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"11","type":"InlinedCode"},{"text":" -> ","type":"SimpleText"},{"code":"1000","type":"InlinedCode"}]}]}]},{"type":"Paragraph","content":[{"text":"We could have implemented the write enable check as ","type":"SimpleText"},{"code":"digit_count.value ==:. index","type":"InlinedCode"},{"text":" but the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"onehot version is a bit more efficient.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Finally, note that we write the value ","type":"SimpleText"},{"code":"bcd_dabbled","type":"InlinedCode"},{"text":" to every BCD digit register (guarded","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"by the write enable). This value is created by multiplexing the BCD registers based on","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"digit_count","type":"InlinedCode"},{"text":" then performing the dabble check. This is important - there is only one","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"instantiation of the check, not one per digit.","type":"SimpleText"}]}]},{"id":"testing","additionalIds":[],"title":"Testing","type":"Section","content":[{"type":"Paragraph","content":[{"text":"We need to create a ","type":"SimpleText"},{"code":"Circuit","type":"InlinedCode"},{"text":", a ","type":"SimpleText"},{"code":"Cyclesim","type":"InlinedCode"},{"text":" simulator and provide access to the input and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"output ports. The following code does this. We will soon learn about ","type":"SimpleText"},{"code":"Interfaces","type":"InlinedCode"},{"text":" which","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"makes a lot of this boilerplate code go away.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Make_sim (Digits : sig\n    val num_digits : int\n  end) =\nstruct\n  open Digits\n  include Make (Digits)\n\n  let circuit () =\n    let done_, bcd =\n      create\n        ~clock:(input \"clock\" 1)\n        ~start:(input \"start\" 1)\n        ~binary_in:(input \"binary\" binary_bits)\n    in\n    Circuit.create_exn\n      ~name:\"double_dabble\"\n      (output \"done\" done_\n       :: Array.to_list (Array.mapi bcd ~f:(fun i -> output [%string \"bcd%{i#Int}\"])))\n  ;;\n\n  type ports =\n    { start : Bits.t ref\n    ; binary_in : Bits.t ref\n    ; done_ : Bits.t ref\n    ; bcd : Bits.t ref array\n    }\n\n  let sim () =\n    let sim = Cyclesim.create (circuit ()) in\n    ( sim\n    , { start = Cyclesim.in_port sim \"start\"\n      ; binary_in = Cyclesim.in_port sim \"binary\"\n      ; done_ = Cyclesim.out_port sim \"done\"\n      ; bcd =\n          Array.init num_digits ~f:(fun i ->\n            Cyclesim.out_port sim [%string \"bcd%{i#Int}\"])\n      } )\n  ;;\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"There is nothing interesting going on here, just definition of string names for circuit ports,","type":"SimpleText"},{"type":"HardLineBreak"},{"text":"then constructing a simulator and looking up the ports.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Below we write exhaustive testbenches for 2, 3, and 4 digit conversions.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let create_test num_digits =\n  let module Bcd =\n    Make_sim (struct\n      let num_digits = num_digits\n    end)\n  in\n  let open Bits in\n  let sim, ports = Bcd.sim () in\n  Cyclesim.cycle sim;\n  let test value =\n    (* Start the statemachine. *)\n    ports.start := Bits.vdd;\n    ports.binary_in <--. value;\n    Cyclesim.cycle sim;\n    ports.start := Bits.gnd;\n    (* Wait for it to complete. *)\n    while not (Bits.to_bool !(ports.done_)) do\n      Cyclesim.cycle sim\n    done;\n    (* Convert the BCD output to a string. *)\n    Array.map ports.bcd ~f:(fun bcd ->\n      Char.of_int_exn (Bits.to_unsigned_int !bcd + Char.to_int '0'))\n    |> Array.to_list\n    |> List.rev\n    |> String.of_list\n  in\n  test\n;;\n\nlet%expect_test \"2 digits\" =\n  let num_digits = 2 in\n  let test = create_test num_digits in\n  for i = 0 to Int.pow 10 num_digits - 1 do\n    assert (Int.of_string (test i) = i)\n  done;\n  [%expect {| |}]\n;;\n\nlet%expect_test \"3 digits\" =\n  let num_digits = 3 in\n  let test = create_test num_digits in\n  for i = 0 to Int.pow 10 num_digits - 1 do\n    assert (Int.of_string (test i) = i)\n  done;\n  [%expect {| |}]\n;;\n\nlet%expect_test \"4 digits\" =\n  let num_digits = 4 in\n  let test = create_test num_digits in\n  for i = 0 to Int.pow 10 num_digits - 1 do\n    assert (Int.of_string (test i) = i)\n  done;\n  [%expect {| |}]\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709443724,"tocItem":{"chapterTitle":"More On Circuit Design","pageTitle":"4.3.2 Double Dabble","pageMeta":{"parent":["state_machine_always_api.mdx"],"title":["4.3.2 Double Dabble"],"uuid":["eaaa4bce-21f3-3f45-2ef9-590c98a09851"]},"dirName":"more-on-circuit-design","fileName":"double_dabble","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Double, then Dabble","id":"double-then-dabble","customAnchorId":"double-then-dabble"},{"title":"Implementing the Hardware","id":"implementing-the-hardware","customAnchorId":"implementing-the-hardware"},{"title":"Testing","id":"testing","customAnchorId":"testing"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"An","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Instantiation/index.html","isFile":false,"type":"Link","content":[{"text":"instantiation","type":"SimpleText"}]},{"type":"SoftLineBreak"},{"text":"creates a placeholder for a named sub-circuit with specified input and output ports.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"This placeholder can be later filled in with an implementation -- it could be a Verilog","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"design, a vendor macro or even another Hardcaml circuit.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# Instantiation.create;;\n- : ?lib:string ->\n    ?arch:string ->\n    ?instance:string ->\n    ?parameters:Parameter.t list ->\n    ?attributes:Hardcaml.Rtl_attribute.t list ->\n    unit ->\n    name:string ->\n    inputs:(string * Signal.t) list ->\n    outputs:(string * int) list -> Instantiation.t\n= <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Three arguments must be supplied","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"name","type":"InlinedCode"},{"text":" of the sub-circuit.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"inputs","type":"InlinedCode"},{"text":" a list of port names and the signal they should attach to.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"outputs","type":"InlinedCode"},{"text":" a list of port names and the width of the port.","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"The returned type can be queried using ","type":"SimpleText"},{"code":"Instantiation.output","type":"InlinedCode"},{"text":" to retrieve a signal for an","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"output port.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let the_instantiation =\n    let a = Signal.input \"a_in\" 2 in\n    let b = Signal.input \"b_in\" 4 in\n    Instantiation.create\n      ~name:\"my_sub_circuit_name\"\n      ~inputs:[ (\"a\", a) ; (\"b\", b) ]\n      ~outputs:[ (\"x\", 5); (\"y\", 10) ]\n      ()\nval the_instantiation : Instantiation.t = <abstr>\n# Instantiation.output the_instantiation \"x\"\n- : Signal.t = (select (width 5) (range (4 0)) (data_in instantiation))\n# Instantiation.output the_instantiation \"y\"\n- : Signal.t = (select (width 10) (range (14 5)) (data_in instantiation))","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"code":"Instantiation.outputs","type":"InlinedCode"},{"text":" returns a map of output name to signal.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# Instantiation.outputs the_instantiation\n- : Signal.t Base.Map.M(Base.String).t = <abstr>","lineNumber":"","type":"Snippet"},{"id":"parameters","additionalIds":[],"level":2,"title":"Parameters","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"External hardware designs are often configured using parameters (in Verilog) or generics","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"(in VHDL).","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The optional ","type":"SimpleText"},{"code":"parameters","type":"InlinedCode"},{"text":" argument allows them to be specified. It takes a list of","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Parameter.t","type":"InlinedCode"},{"text":"s.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let parameter = Parameter.create ~name:\"bus_width\" ~value:(Int 3)\nval parameter : Parameter.t =\n  {Hardcaml.Parameter.name = <abstr>; value = Hardcaml.Parameter.Value.Int 3}","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Each parameter is specified using a ","type":"SimpleText"},{"code":"name","type":"InlinedCode"},{"text":" and a ","type":"SimpleText"},{"code":"type","type":"InlinedCode"},{"text":" with a value. Various","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Parameter/Value/index.html","isFile":false,"type":"Link","content":[{"text":"types","type":"SimpleText"}]},{"text":" are","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"supported including ","type":"SimpleText"},{"code":"Int","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"String","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"Bool","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"Real","type":"InlinedCode"},{"text":" and various bit and vector types","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"associated with Verilog and VHDL - ","type":"SimpleText"},{"code":"Bit","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"Std_logic_vector","type":"InlinedCode"},{"text":" etc.","type":"SimpleText"}]},{"id":"instantiation-control","additionalIds":[],"level":2,"title":"Instantiation control","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The optional ","type":"SimpleText"},{"code":"instance","type":"InlinedCode"},{"text":" parameter can provide a label for the specific instantiation of a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"sub-circuit. Note that a sub-circuit can be instantiated multiple times and each one must","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"have a different label. Hardcaml will appropriately mangle labels so they are unique, but","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"a human can usually come up with better names.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"lib","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"arch","type":"InlinedCode"},{"text":" are concepts related to library management in VHDL. Hardcaml instantiates","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"in VHDL using the syntax","type":"SimpleText"}]},{"lang":"","snippet":"entity <lib>.module_name(<arch>)`","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"to avoid writing out component declarations. By default ","type":"SimpleText"},{"code":"work","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"rtl","type":"InlinedCode"},{"text":" are used.","type":"SimpleText"}]},{"id":"external-ip","additionalIds":[],"level":2,"title":"External IP","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Instantiations can reference hardware designs written in another hardware description","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"language (HDL) such as Verilog or VHDL and connect them to a Hardcaml design.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Such designs contain a hole from Hardcaml's point of view. As such it will no longer be","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"possible to simulate them with ","type":"SimpleText"},{"code":"Cyclesim","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"They can be ","type":"SimpleText"},{"type":"Emphasis","content":[{"text":"linked","type":"SimpleText"}]},{"text":" with the external design by an HDL simulator or the Vendor","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"implementation tools.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"In some cases, you may be able to leverage","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"http://github.com/janestreet/hardcaml_of_verilog","isFile":false,"type":"Link","content":[{"code":"hardcaml_of_verilog","type":"InlinedCode"}]},{"text":" to convert a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Verilog design to a Hardcaml circuit which can be simulated.","type":"SimpleText"}]},{"id":"hardcaml-sub-circuits","additionalIds":[],"level":2,"title":"Hardcaml sub-circuits","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"We can also instantiate sub-circuits that we actually do have a Hardcaml implementation","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"of. This approach is used to describe ","type":"SimpleText"},{"url":"/hardcaml-docs/using-interfaces/module_hierarchies","isFile":false,"type":"Link","content":[{"text":"module hierarchies","type":"SimpleText"}]},{"text":" in","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Hardcaml.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Hardcaml can link such designs together allowing them to be simulated.","type":"SimpleText"}]}],"lastModifiedTime":1750709444365,"tocItem":{"chapterTitle":"More On Circuit Design","pageTitle":"4.4 Instantiation","pageMeta":{"parent":["more_design.mdx"],"title":["4.4 Instantiation"],"uuid":["f4593ef9-be16-306e-b76f-720dc5c061bf"]},"dirName":"more-on-circuit-design","fileName":"instantiation","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[]}},{"type":"Page","content":[{"id":"what-is-it","additionalIds":[],"title":"What is it?","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Structural provides functions to generate hardware circuits. In fact its functionality is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"very similar to ","type":"SimpleText"},{"code":"Hardcaml.Signal","type":"InlinedCode"},{"text":", right down to supporting the standard Comb.S API.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"That said, there are some difference with respect the ","type":"SimpleText"},{"code":"instantiation","type":"InlinedCode"},{"text":"s and ","type":"SimpleText"},{"code":"wire","type":"InlinedCode"},{"text":"s.","type":"SimpleText"}]},{"id":"what-is-it-introducing-tristates","additionalIds":["introducing-tristates"],"level":2,"title":"Introducing tristates","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Structural is not quite as silly as it seems. There is something that Hardcaml ","type":"SimpleText"},{"code":"Signal","type":"InlinedCode"},{"text":"s","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"do not support that we sometimes need - tristate values. A tristate value (also called a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"three-state value) is a digital signal that can exist in one of three possible states:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Logic high (1).","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Logic low (0).","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"High impedance (Z).","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"First of all - why don't ","type":"SimpleText"},{"code":"Signal","type":"InlinedCode"},{"text":"s support tristates? They ","type":"SimpleText"},{"type":"Emphasis","content":[{"text":"could","type":"SimpleText"}]},{"text":" but it would make many","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"internal parts of the library much more complicated to do so. Indeed, all the backend","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"generators, simulators, and so on would need to be updated to support them, and we would","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"also have to use a multi-value logic type to do this properly.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"So instead we provide ","type":"SimpleText"},{"code":"Structural","type":"InlinedCode"},{"text":" - a cut down version of ","type":"SimpleText"},{"code":"Signal","type":"InlinedCode"},{"text":" which supports","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"tristates, instantiation, writing to Verilog, and nothing else.","type":"SimpleText"}]},{"id":"what-is-it-why-do-we-need-tristates","additionalIds":["why-do-we-need-tristates"],"level":2,"title":"Why do we need tristates?","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Most of the time we don't. They are not generally used inside most logic designs. However,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"when we interact with the outside world (ie via the pins on a chip) we quite often ","type":"SimpleText"},{"type":"Emphasis","content":[{"text":"DO","type":"SimpleText"}]},{"type":"SoftLineBreak"},{"text":"need to support tristates. Some chips will use tristate signals to daisy chain multiple","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"devices or reduce pin count.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"If we didn't provide a way to describe tristates the top level most module of a full","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"hardware design would still need to be described in a traditional HDL like Verilog. This","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"is what ","type":"SimpleText"},{"code":"Structural","type":"InlinedCode"},{"text":" is for - describing a design top level where we need support for","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"tristates.","type":"SimpleText"}]}]},{"id":"api","additionalIds":[],"title":"API","type":"Section","content":[{"id":"api-circuits","additionalIds":["circuits"],"level":2,"title":"Circuits","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"In structural, signals are recorded into a database rather than discovered dynamically as","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"with ","type":"SimpleText"},{"code":"Signal","type":"InlinedCode"},{"text":"s.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"To do this we must first call ","type":"SimpleText"},{"code":"start_circuit name","type":"InlinedCode"},{"text":" and when done call ","type":"SimpleText"},{"code":"end_circuit ()","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"id":"api-ports","additionalIds":["ports"],"level":2,"title":"Ports","type":"SubHeading"},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Input ports are created with ","type":"SimpleText"},{"code":"mk_input","type":"InlinedCode"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Output ports are created with ","type":"SimpleText"},{"code":"mk_output","type":"InlinedCode"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Tristate ports are created with ","type":"SimpleText"},{"code":"mk_tristate","type":"InlinedCode"}]}]}]},{"id":"api-instantiation","additionalIds":["instantiation"],"level":2,"title":"Instantiation","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Instantiations work a little differently than with ","type":"SimpleText"},{"code":"Signal","type":"InlinedCode"},{"text":"s. The inputs, outputs and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"tristate ports of the instantiated circuit are all passed to the ","type":"SimpleText"},{"code":"inst","type":"InlinedCode"},{"text":" function.","type":"SimpleText"}]},{"id":"api-basic-example","additionalIds":["basic-example"],"level":2,"title":"Basic example","type":"SubHeading"},{"lang":"ocaml","snippet":"# open Hardcaml.Structural\n# let gen () =\n    start_circuit \"example\";\n    let i = mk_input \"i\" 1 in\n    let o = mk_output \"o\" 1 in\n    let t = mk_tristate \"t\" 1 in\n    inst \"inner\" ~i:[ \"i\" ==> i ] ~o:[ \"o\" ==> o ] ~t:[ \"t\" ==> t ];\n    end_circuit ();\n    to_verilog (find_circuit \"example\") |> Rope.to_string |> print_string\nval gen : unit -> unit = <fun>\n# gen ()\nmodule example\n(\n  input i,\n  output o,\n  inout t\n);\n\n  inner _4\n  (\n    .i(i),\n    .o(o),\n    .t(t)\n  );\nendmodule\n- : unit = ()","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Circuits must have unique names.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# gen ()\nException: Hardcaml__Structural.Circuit_already_exists(\"example\").","lineNumber":"","type":"Snippet"},{"id":"api-api-functions","additionalIds":["api-functions"],"level":2,"title":"API functions","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"A small set of functions are natively supported by ","type":"SimpleText"},{"code":"Structural","type":"InlinedCode"},{"text":" - ","type":"SimpleText"},{"code":"of_bit_string","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"mux","type":"InlinedCode"},{"text":",","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"concat_msb","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"select","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"In addition, assignment is performed with ","type":"SimpleText"},{"code":"<--","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let gen () =\n    start_circuit \"example2\";\n    let i = mk_input \"i\" 3 in\n    let o = mk_output \"o\" 2 in\n    o <--\n        concat_msb\n            [ of_bit_string \"1\"\n            ; mux\n                (select i ~high:0 ~low:0)\n                [ select i ~high:1 ~low:1\n                ; select i ~high:2 ~low:2 ]\n            ];\n    end_circuit ();\n    to_verilog (find_circuit \"example2\") |> Rope.to_string |> print_string\nval gen : unit -> unit = <fun>\n# gen ()\nmodule example2\n(\n  input [2:0] i,\n  output [1:0] o\n);\n\n  wire _3;\n  wire _4;\n  wire _5;\n  wire _6;\n  wire _7;\n  wire [1:0] _8;\n  assign _3 = i[2:2];\n  assign _4 = i[1:1];\n  assign _5 = i[0:0];\n  assign _6 =\n    _5 == 0 ? _4 :\n    _3;\n  assign _7 = 1'b1;\n  assign _8 = { _7, _6 };\n  assign o = _8;\nendmodule\n- : unit = ()","lineNumber":"","type":"Snippet"},{"id":"api-api-functions-using-lib","additionalIds":["using-lib"],"level":3,"title":"Using Lib","headingContent":[{"text":"Using ","type":"SimpleText"},{"code":"Lib","type":"InlinedCode"}],"type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The complete ","type":"SimpleText"},{"code":"Comb","type":"InlinedCode"},{"text":" API be provided by instantiating the ","type":"SimpleText"},{"code":"Structural.Lib","type":"InlinedCode"},{"text":" functor (note","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"this must be done within a 'started' circuit). This uses hardcaml to create","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"implementations for each operation and allows them to be instantiated within ","type":"SimpleText"},{"code":"Structural","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"circuits.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let circuit =\n    create_circuit \"example3\" (fun () ->\n      let open Lib () in\n      let a = mk_input \"a\" 3 in\n      let b = mk_input \"b\" 3 in\n      let addsub = mk_input \"addsub\" 1 in\n      let c = mk_output \"c\" 3 in\n      c <-- mux2 addsub (a +: b) (a -: b));;\nval circuit : circuit = <abstr>\n# to_verilog circuit |> Rope.to_string |> print_string\nmodule example3\n(\n  input [2:0] a,\n  input [2:0] b,\n  input addsub,\n  output [2:0] c\n);\n\n  wire _1;\n  wire _2;\n  wire [2:0] _7;\n  wire [2:0] _9;\n  wire [2:0] _11;\n  assign _1 = 1'b1;\n  assign _2 = 1'b0;\n  assign _11 =\n    addsub == 0 ? _7 :\n    _9;\n  assign c = _11;\n  hardcaml_lib_sub_3 _8\n  (\n    .i0(a),\n    .i1(b),\n    .o(_7)\n  );\n  hardcaml_lib_add_3 _10\n  (\n    .i0(a),\n    .i1(b),\n    .o(_9)\n  );\nendmodule\n- : unit = ()","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We have used a new function here called ","type":"SimpleText"},{"code":"create_circuit","type":"InlinedCode"},{"text":". It will automatically call","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"start_circuit","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"end_circuit","type":"InlinedCode"},{"text":" and return the generated structural circuit.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"code":"(+:)","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"(-:)","type":"InlinedCode"},{"text":" functions have created instantiations for the operators. We can get","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"their implementations as follows:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let components = structural_rtl_components circuit\nval components : Base.Set.M(Hardcaml.Structural.Structural_rtl_component).t =\n  <abstr>\n# Set.iter components ~f:(fun subcircuit ->\n    let subcircuit = Structural_rtl_component.rtl_circuit subcircuit in\n    Hardcaml.Rtl.print Verilog subcircuit)\nmodule hardcaml_lib_add_3 (\n    i1,\n    i0,\n    o\n);\n\n    input [2:0] i1;\n    input [2:0] i0;\n    output [2:0] o;\n\n    wire [2:0] _4;\n    assign _4 = i0 + i1;\n    assign o = _4;\n\nendmodule\nmodule hardcaml_lib_sub_3 (\n    i1,\n    i0,\n    o\n);\n\n    input [2:0] i1;\n    input [2:0] i0;\n    output [2:0] o;\n\n    wire [2:0] _4;\n    assign _4 = i0 - i1;\n    assign o = _4;\n\nendmodule\n- : unit = ()","lineNumber":"","type":"Snippet"},{"id":"api-describing-a-tristate-mux","additionalIds":["describing-a-tristate-mux"],"level":2,"title":"Describing a tristate mux","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Tristate logic can also be generated by ","type":"SimpleText"},{"code":"Structural","type":"InlinedCode"},{"text":" rather than just passing through wires.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let circuit =\n    create_circuit \"example4\" (fun () ->\n      let d = mk_input \"d\" 1 in\n      let sel = mk_input \"sel\" 1 in\n      let t = mk_tristate \"t\" 1 in\n      t <-- mux sel [d; (z 1)])\nval circuit : circuit = <abstr>\n# to_verilog circuit |> Rope.to_string |> print_string\nmodule example4\n(\n  input d,\n  input sel,\n  inout t\n);\n\n  wire _4;\n  wire _5;\n  assign _4 = 1'bz;\n  assign _5 =\n    sel == 0 ? d :\n    _4;\n  assign t = _5;\nendmodule\n- : unit = ()","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709443888,"tocItem":{"chapterTitle":"More On Circuit Design","pageTitle":"4.5 Working with Structural","pageMeta":{"parent":["more_design.mdx"],"title":["4.5 Working with Structural"],"uuid":["8be661fd-fa65-396c-8b5a-661ef81afa58"]},"dirName":"more-on-circuit-design","fileName":"structural","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"What is it?","id":"what-is-it","customAnchorId":"what-is-it"},{"title":"API","id":"api","customAnchorId":"api"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"Hardcaml defines an OCaml variant type called ","type":"SimpleText"},{"code":"Signal.Type.t","type":"InlinedCode"},{"text":" which expresses the RTL","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"structures it can describe. How this is converted to RTL explains a lot about the various","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"choices we make in the Hardcaml API.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Below we will show how every variant in ","type":"SimpleText"},{"code":"Signal.Type.t","type":"InlinedCode"},{"text":" is converted to Verilog.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Conversion to VHDL is very similar. Note that this really is all of the primitives in","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Hardcaml! There are not very many, and all other features of Hardcaml are built atop them.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The correctness of the generated code will depend on rules that Hardcaml enforces and we","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"will highlight where that is the case. The following rules are applied in order to try to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"make the resulting Verilog constructs trivial to understand.","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Widths of arguments are restricted so we do not have to understand any weird Verilog","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"auto-conversion rules.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"The width of the LHS and RHS of assignments are nearly always the same (comparison and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"multiplication being exceptions).","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Assignments are ","type":"SimpleText"},{"type":"Emphasis","content":[{"text":"complete","type":"SimpleText"}]},{"text":" which generally means where we generate a Verilog ","type":"SimpleText"},{"code":"case","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"construct, we will include a ","type":"SimpleText"},{"code":"default","type":"InlinedCode"},{"text":" branch.","type":"SimpleText"}]}]}]},{"id":"simple-operations","additionalIds":[],"title":"Simple Operations","type":"Section","content":[{"type":"Paragraph","content":[{"text":"We will quickly go through a number of simple operations which convert trivially to RTL.","type":"SimpleText"}]},{"id":"simple-operations-constants","additionalIds":["constants"],"level":2,"title":"Constants","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Constants are always written in binary form.","type":"SimpleText"}]},{"lang":"verilog","snippet":"wire [4:0] _123;\nassign _123 = 5'b10001;","lineNumber":"","type":"Snippet"},{"id":"simple-operations-concatenation","additionalIds":["concatenation"],"level":2,"title":"Concatenation","type":"SubHeading"},{"lang":"verilog","snippet":"wire [23:0] _123;\nassign _123 = { _33, _87; _43 };","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The width of the result is the sum of the width of all the elements in the concatenation.","type":"SimpleText"}]},{"id":"simple-operations-wires","additionalIds":["wires"],"level":2,"title":"Wires","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Wires just make a copy. The only interesting thing in the generated RTL is that wires are","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"declared before they are assigned, which is a requirement to allow them to perform cyclic","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"references.","type":"SimpleText"}]},{"lang":"verilog","snippet":"wire [3:0] a_wire;\n\nassign a_wire = _123;","lineNumber":"","type":"Snippet"},{"id":"simple-operations-select","additionalIds":["select"],"level":2,"title":"Select","type":"SubHeading"},{"lang":"verilog","snippet":"wire [2:0] _123;\n\nassign _123 = _55[3:1];","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The rules of the Hardcaml ","type":"SimpleText"},{"code":"select","type":"InlinedCode"},{"text":" function ensure that the Verilog selection cannot","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"access out of range bits.","type":"SimpleText"}]}]},{"id":"arithmetic-operators","additionalIds":[],"title":"Arithmetic Operators","type":"Section","content":[{"id":"arithmetic-operators-addition-and-subtraction","additionalIds":["addition-and-subtraction"],"level":2,"title":"Addition and subtraction","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The Hardcaml rules are that the arguments and result must all be of the same width. Thus","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"we write:","type":"SimpleText"}]},{"lang":"verilog","snippet":"wire [7:0] _123;\n\nassign _123 = a + b;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Given ","type":"SimpleText"},{"code":"a","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"b","type":"InlinedCode"},{"text":" are the same size as the result it doesn't matter if we consider them to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"be signed or unsigned - the resulting bit pattern is the same.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The same is true of subtraction.","type":"SimpleText"}]},{"id":"arithmetic-operators-multiplication","additionalIds":["multiplication"],"level":2,"title":"Multiplication","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"We must differentiate between signed and unsigned multiplication. For unsigned we write:","type":"SimpleText"}]},{"lang":"verilog","snippet":"wire [8:0] _123;\n\nassign _123 = a * b;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"By default Verilog performs unsigned multiplication. The result width is the sum of the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"width of the arguments.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"To perform signed multiplication we write:","type":"SimpleText"}]},{"lang":"verilog","snippet":"wire [8:0] _123;\n\nassign _123 = $signed(a) * $signed(b);","lineNumber":"","type":"Snippet"}]},{"id":"logical-operators","additionalIds":[],"title":"Logical Operators","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"code":"and","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"or","type":"InlinedCode"},{"text":", and ","type":"SimpleText"},{"code":"xor","type":"InlinedCode"},{"text":" logical operations are defined similarly to addition and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"subtraction in that the result and arguments must have the same width.","type":"SimpleText"}]},{"lang":"verilog","snippet":"wire [7:0] _123;\n\nassign _123 = a ^ b;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"code":"not","type":"InlinedCode"},{"text":" is also similar except that it only has one argument.","type":"SimpleText"}]},{"lang":"verilog","snippet":"wire [7:0] _123;\n\nassign _123 = ~a;","lineNumber":"","type":"Snippet"}]},{"id":"comparison-operators","additionalIds":[],"title":"Comparison Operators","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Hardcaml provides 2 comparison operators - equals and unsigned less than. The result of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"both is a single bit. The arguments are the same width.","type":"SimpleText"}]},{"lang":"verilog","snippet":"wire _123;\n\nassign _123 = a == b;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"And less than:","type":"SimpleText"}]},{"lang":"verilog","snippet":"wire _123;\n\nassign _123 = a < b;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Hardcaml synthesizes the full set of comparison operators for both signed and unsigned","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"arguments using these two primitives and the ","type":"SimpleText"},{"code":"not","type":"InlinedCode"},{"text":" operator.","type":"SimpleText"}]}]},{"id":"mux","additionalIds":[],"title":"Mux","type":"Section","content":[{"type":"Paragraph","content":[{"text":"A Hardcaml mux takes a select signal and some number of data inputs. The final data input","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"is repeated enough times to create a complete mux structure. For example, our select could","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"be 3 bits and we provide 5 data inputs. The last value will be repeated and used for","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"indices 5, 6, and 7.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"These rules are encoded by using a case statement with a default branch.","type":"SimpleText"}]},{"lang":"verilog","snippet":"case (select)\n0: _123 <= _1;\n1: _123 <= _2;\n2: _123 <= _3;\n3: _123 <= _4;\ndefault: _123 <= _5;\nendcase","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Even if the case is complete, a default branch is written.","type":"SimpleText"}]},{"lang":"verilog","snippet":"case (select)\n0: _123 <= _1;\n1: _123 <= _2;\n2: _123 <= _3;\n3: _123 <= _4;\n4: _123 <= _5;\n5: _123 <= _6;\n6: _123 <= _7;\ndefault: _123 <= _8;\nendcase","lineNumber":"","type":"Snippet"}]},{"id":"cases","additionalIds":[],"title":"Cases","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The Hardcaml ","type":"SimpleText"},{"code":"Cases","type":"InlinedCode"},{"text":" variant also generates a Verilog case statement, but the branch match","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"values do not have to be successively incrementing constants starting at 0 as with a mux.","type":"SimpleText"}]},{"lang":"verilog","snippet":"case (select)\n3: _123 <= _1;\n7: _123 <= _2;\n9: _123 <= _4\ndefault: _123 <= _5;\nendcase","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We do, however, need to provide a default value. As with muxes we ensure that no matter","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"what select value is provided, the result value ","type":"SimpleText"},{"type":"Emphasis","content":[{"text":"must","type":"SimpleText"}]},{"text":" be driven.","type":"SimpleText"}]}]},{"id":"registers","additionalIds":[],"title":"Registers","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Register are written using the following general template:","type":"SimpleText"}]},{"lang":"verilog","snippet":"always @(posedge clock, posedge reset)\n  if (reset == 1'b1) q <= 1'b0;\n  else if (clear == 1'b1) q <= 1'b0;\n  else if (enable == 1'b1) q <= d;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The asynchronous reset, synchronous clear and enable are all optional. If they are not","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"present Hardcaml will not write out that part of the template.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"reset, clear and enable must all be 1 bit wide. The register input value, reset to value","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"and clear to value are all the same width as the result value.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Hardcaml further supports negative edge clocks.","type":"SimpleText"}]}]},{"id":"memories","additionalIds":[],"title":"Memories","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Hardcaml memories are defined in two parts - the memory array itself along with its write","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"logic and one or more read ports.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"These memory structures describe asynchronous read memories that may be converted to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"synchronous by registering the address(es) or output port(s).","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Hardcaml memories may have multiple read and/or write ports, though only specific","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"instances will be inferred into actual hardware memories (otherwise we describe","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"potentially inefficient register banks).","type":"SimpleText"}]},{"lang":"verilog","snippet":"reg [7:0] mem [0:3];\n\nalways @(posedge clock)\n  if (write_enable)\n    mem[write_address] <= write_data;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The above may be written once for each provided write port.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Read ports are written as:","type":"SimpleText"}]},{"lang":"verilog","snippet":"assign q = mem[read_address];","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Again, we will get similar code for each read port.","type":"SimpleText"}]}]},{"id":"instantiations","additionalIds":[],"title":"Instantiations","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Instantiations are written into the RTL following the specification of inputs and outputs","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"given in Hardcaml.","type":"SimpleText"}]},{"lang":"verilog","snippet":"foo the_foo (.i(i), .o1(_123[3:0]), .o2(_123[5:3]));","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Note that there is a single output vector defined for all the output ports from which each","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"individual output will then be selected. This makes the traversal of the Hardcaml signal","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"graph simpler, at the cost of slightly more verbose RTL.","type":"SimpleText"}]}]}],"lastModifiedTime":1750709443676,"tocItem":{"chapterTitle":"More On Circuit Design","pageTitle":"4.6 How Hardcaml Converts Signals","pageMeta":{"parent":["more_design.mdx"],"title":["4.6 How Hardcaml Converts Signals"],"uuid":["fdac4970-6add-369c-6fc6-1c7d6dd71390"]},"dirName":"more-on-circuit-design","fileName":"conversion-to-rtl","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Simple Operations","id":"simple-operations","customAnchorId":"simple-operations"},{"title":"Arithmetic Operators","id":"arithmetic-operators","customAnchorId":"arithmetic-operators"},{"title":"Logical Operators","id":"logical-operators","customAnchorId":"logical-operators"},{"title":"Comparison Operators","id":"comparison-operators","customAnchorId":"comparison-operators"},{"title":"Mux","id":"mux","customAnchorId":"mux"},{"title":"Cases","id":"cases","customAnchorId":"cases"},{"title":"Registers","id":"registers","customAnchorId":"registers"},{"title":"Memories","id":"memories","customAnchorId":"memories"},{"title":"Instantiations","id":"instantiations","customAnchorId":"instantiations"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"Abstractly, Hardcaml","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Interface/index.html","isFile":false,"type":"Link","content":[{"text":"interfaces","type":"SimpleText"}]},{"text":" are","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"made up of a polymorphic type (with a single polymorphic variable) and a set of functions","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"which can manipulate that type:","type":"SimpleText"}]},{"lang":"","snippet":"type 'a t [@@deriving sexp_of]\n\nval iter : 'a t -> f:('a -> unit) -> unit\nval iter2 : 'a t -> 'b t -> f:('a -> 'b -> unit) -> unit\nval map : 'a t -> f:('a -> 'b) -> 'b t\nval map2 : 'a t -> 'b t -> f:('a -> 'b -> 'c) -> 'c t\nval to_list : 'a t -> 'a list","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"In addition they contain a field","type":"SimpleText"}]},{"lang":"","snippet":"val port_names_and_widths : (string * int) t","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"which specifies for each ","type":"SimpleText"},{"code":"'a","type":"InlinedCode"},{"text":" contained in ","type":"SimpleText"},{"code":"'a t","type":"InlinedCode"},{"text":" a string name which can be used to label","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the value and the bit width of it's representation as hardware.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Most commonly an interface will be of type ","type":"SimpleText"},{"code":"Signal.t t","type":"InlinedCode"},{"text":" where it will represent a set of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Hardcaml signals within a hardware design, or ","type":"SimpleText"},{"code":"Bits.t t","type":"InlinedCode"},{"text":" where it is used to interact with","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"a Hardcaml simulator.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Interfaces actually contain many more convenience functions though they can all be","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"derived from the functions shown above.","type":"SimpleText"}]},{"id":"record-interfaces","additionalIds":[],"level":2,"title":"Record interfaces","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The most common form of interface is a record. Below we implement an interface by hand for","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"a record containing two fields: ","type":"SimpleText"},{"code":"foo","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"bar","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Explicit_interface_record_implementation = struct\n  module T = struct\n    type 'a t =\n      { foo : 'a\n      ; bar : 'a\n      }\n    [@@deriving equal ~localize, sexp_of]\n\n    let map t ~f = { foo = f t.foo; bar = f t.bar }\n    let map2 s t ~f = { foo = f s.foo t.foo; bar = f s.bar t.bar }\n    let iter t ~f = f t.foo; f t.bar\n    let iter2 s t ~f = f s.foo t.foo; f s.bar t.bar\n    let to_list t = [ t.foo; t.bar ]\n\n    let port_names_and_widths = { foo = \"FOO_FOO\", 32; bar = \"BAR_BAR\", 1 }\n  end\n  include T\n  include Hardcaml.Interface.Make(T)\nend;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"In the ","type":"SimpleText"},{"code":"port_names_and_widths","type":"InlinedCode"},{"text":" value we gave a 32 bit width to foo, and a 1 bit width to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"bar. Note also the names we specified were not the same as the record field name (although","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"much of the time it makes most sense if they are).","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"To reduce the amount of boilerplate code to write we provide a ppx called","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://github.com/janestreet/ppx_hardcaml","isFile":false,"type":"Link","content":[{"code":"ppx_hardcaml","type":"InlinedCode"}]},{"text":" which can generate the above","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"code for you from the type definition.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The type definition derives Hardcaml and various annotations exist to customize the names","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"and widths of each field.  Note that each field in the record must be of type ","type":"SimpleText"},{"code":"'a","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Simple_interface = struct\n  type 'a t =\n    { foo : 'a [@bits 32]\n    ; (* Where a bit width is not specified, it defaults to 1. *)\n      bar : 'a\n    }\n  [@@deriving hardcaml]\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Some simple ","type":"SimpleText"},{"url":"/hardcaml-docs/introduction/installing_with_opam","isFile":false,"type":"Link","content":[{"text":"setup","type":"SimpleText"}]},{"text":" is required to use Hardcaml interfaces,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"namely installing ","type":"SimpleText"},{"code":"ppx_hardcaml","type":"InlinedCode"},{"text":" and adding it as a preprocessor in the build system.","type":"SimpleText"}]},{"id":"using-interfaces","additionalIds":[],"level":2,"title":"Using interfaces","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Lets say ","type":"SimpleText"},{"code":"Simple_interface","type":"InlinedCode"},{"text":" defined the outputs of some hardware module. Generally we","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"would write something like:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let circuit =\n    Circuit.create_exn ~name:\"test\"\n      [ output \"foo\" outputs.foo; output \"bar\" outputs.bar ]","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Instead we can write:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let circuit =\n    Circuit.create_exn ~name:\"test\"\n      Simple_interface.(map2 port_names outputs ~f:Signal.output |> to_list)","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Now lets say we have built a simulator over this module and want access to the output ports","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let outputs =\n    Simple_interface.(map port_names ~f:(Cyclesim.out_port sim ))","lineNumber":"","type":"Snippet"},{"id":"other-types-of-interface","additionalIds":[],"level":2,"title":"Other types of interface","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"There are various use cases for interfaces where the outer type is not a record. ","type":"SimpleText"},{"code":"Enums","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"are one example and will be described later.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"Scalar","type":"InlinedCode"},{"text":"s are another where we abstract a Hardcaml value by restricting access to it's","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"implementation. They often come with a specialized API for manipulating the value.","type":"SimpleText"}]},{"id":"complete-interface-api","additionalIds":[],"title":"Complete Interface API","type":"Section","content":[{"id":"complete-interface-api-map-and-iter","additionalIds":["map-and-iter"],"level":2,"title":"Map and Iter","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"map","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"iter","type":"InlinedCode"},{"text":" functions are provided with up to 5 arguments.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# map5\n- : 'a Simple_interface.t ->\n    'b Simple_interface.t ->\n    'c Simple_interface.t ->\n    'd Simple_interface.t ->\n    'e Simple_interface.t ->\n    f:('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'f Simple_interface.t\n= <fun>","lineNumber":"","type":"Snippet"},{"id":"complete-interface-api-zip","additionalIds":["zip"],"level":2,"title":"Zip","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Between 2 and 5 interfaces can be combined using zip.  The result is an interface of tuples.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# zip port_names port_widths\n- : (string * int) Simple_interface.t = {foo = (\"foo\", 32); bar = (\"bar\", 1)}","lineNumber":"","type":"Snippet"},{"id":"complete-interface-api-fold-and-scan","additionalIds":["fold-and-scan"],"level":2,"title":"Fold and Scan","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"fold","type":"InlinedCode"},{"text":" passes each field of an interface, along with an accumulator, to the given function","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"f","type":"InlinedCode"},{"text":". For example we can compute the total width of an interface as follows.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# fold port_widths ~init:0 ~f:(fun total width -> total + width)\n- : int = 33","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"(note - this is also provided by the value ","type":"SimpleText"},{"code":"sum_of_port_widths","type":"InlinedCode"},{"text":").","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"scan","type":"InlinedCode"},{"text":" is similar except it returns an interface. The function ","type":"SimpleText"},{"code":"f","type":"InlinedCode"},{"text":" returns the next value","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"of the accumulator and the value of the result field. We can compute the offset of each","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"field in an interface as follows.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# scan port_widths ~init:0 ~f:(fun acc width -> acc + width, acc)\n- : int Simple_interface.t = {foo = 0; bar = 32}","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"(note - this is also provide by the function ","type":"SimpleText"},{"code":"offsets","type":"InlinedCode"},{"text":").","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"fold2","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"scan2","type":"InlinedCode"},{"text":" are also defined.","type":"SimpleText"}]},{"id":"complete-interface-api-association-lists-and-tags","additionalIds":["association-lists-and-tags"],"level":2,"title":"Association lists and Tags","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"An interface can be converted to and from an association list with ","type":"SimpleText"},{"code":"to_alist","type":"InlinedCode"},{"text":" and","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"of_alist","type":"InlinedCode"},{"text":". Note that we do not choose to use the string name of fields as keys - rather","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"we define and abstract type ","type":"SimpleText"},{"code":"tag","type":"InlinedCode"},{"text":" and value ","type":"SimpleText"},{"code":"tags","type":"InlinedCode"},{"text":" which uniquely represent each fields in","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"an interface.","type":"SimpleText"}]},{"id":"complete-interface-api-lists-of-interfaces","additionalIds":["lists-of-interfaces"],"level":2,"title":"Lists of Interfaces","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"of_interface_list","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"to_interface_list","type":"InlinedCode"},{"text":" convert between a list of interfaces and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"interface of lists.  The signatures should make the operation clearer.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# of_interface_list\n- : 'a Simple_interface.t list -> 'a list Simple_interface.t = <fun>\n# to_interface_list\n- : 'a list Simple_interface.t -> 'a Simple_interface.t list = <fun>","lineNumber":"","type":"Snippet"},{"id":"complete-interface-api-misc-functions","additionalIds":["misc-functions"],"level":2,"title":"Misc functions","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"port_names  : string t","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"port_widths : int t","type":"InlinedCode"},{"text":" provide direct access to the names and widths of fields in an interface.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"const c","type":"InlinedCode"},{"text":" sets each field to the value ","type":"SimpleText"},{"code":"c","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"id":"complete-interface-api-of_signal-and-of_bits","additionalIds":["of_signal-and-of_bits"],"level":2,"title":"Of_signal and Of_bits","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Both these modules implement the signature ","type":"SimpleText"},{"code":"Interface.Comb","type":"InlinedCode"},{"text":". They provides functions","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"specialized to the types ","type":"SimpleText"},{"code":"Signal.t t","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"Bits.t t","type":"InlinedCode"},{"text":" respectively.","type":"SimpleText"}]},{"id":"complete-interface-api-of_signal-and-of_bits-converting-from-ints","additionalIds":["converting-from-ints"],"level":3,"title":"Converting from Ints","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"of_unsigned_int","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"of_signed_int","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"of_int_trunc","type":"InlinedCode"},{"text":" set each field to the given value by","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"converting from a given integer.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"of_unsigned_ints","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"of_signed_ints","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"of_ints_trunc","type":"InlinedCode"},{"text":" also convert from integers but each","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"field may be specified individually.","type":"SimpleText"}]},{"id":"complete-interface-api-of_signal-and-of_bits-pack-and-unpack","additionalIds":["pack-and-unpack"],"level":3,"title":"Pack and Unpack","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"pack","type":"InlinedCode"},{"text":" flattens an interface into a single vector by concatenating all the fields.  ","type":"SimpleText"},{"code":"unpack","type":"InlinedCode"},{"text":" reverses the operation.","type":"SimpleText"}]},{"id":"complete-interface-api-of_signal-and-of_bits-muxs","additionalIds":["muxs"],"level":3,"title":"Muxs","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"mux2","type":"InlinedCode"},{"text":" selects between 2 interfaces and ","type":"SimpleText"},{"code":"mux","type":"InlinedCode"},{"text":" selects between an arbitrary number of interfaces.","type":"SimpleText"}]},{"id":"complete-interface-api-of_signal-and-of_bits-selection","additionalIds":["selection"],"level":3,"title":"Selection","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"priority_select","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"priority_select_with_default","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"onehot_select","type":"InlinedCode"},{"text":" all work the same","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"way as the corresponding versions on normal signals, expect they operate on all fields at","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"once.","type":"SimpleText"}]},{"id":"complete-interface-api-of_signal-and-of_bits-of_signal-specifics","additionalIds":["of_signal-specifics"],"level":3,"title":"Of_signal specifics","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"A few further functions apply only to the ","type":"SimpleText"},{"code":"Signal.t t","type":"InlinedCode"},{"text":" type.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"wires","type":"InlinedCode"},{"text":" creates an interface of wires.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"assign a b","type":"InlinedCode"},{"text":" performs wire assignment - ","type":"SimpleText"},{"code":"a","type":"InlinedCode"},{"text":" should be an interface of wires.","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"reg","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"pipeline","type":"InlinedCode"},{"text":" apply registers (or a pipeline of registers) to the given interface.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"inputs","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"outputs","type":"InlinedCode"},{"text":" create the input and output ports for circuits.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"apply_names","type":"InlinedCode"},{"text":" will apply names to each field based on ","type":"SimpleText"},{"code":"port_names","type":"InlinedCode"},{"text":" and a given prefix and suffix.","type":"SimpleText"}]},{"id":"complete-interface-api-of_always","additionalIds":["of_always"],"level":2,"title":"Of_always","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"Of_always","type":"InlinedCode"},{"text":" operates on interfaces of type ","type":"SimpleText"},{"code":"Always.Variable.t t","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"value","type":"InlinedCode"},{"text":" converts an interface of variables to an interface of signals.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"assign","type":"InlinedCode"},{"text":" assigns variables with values. It results in an always statement.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"reg","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"wire","type":"InlinedCode"},{"text":" define interfaces of variables.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"apply_names","type":"InlinedCode"},{"text":" will apply names to each field based on ","type":"SimpleText"},{"code":"port_names","type":"InlinedCode"},{"text":" and a given prefix and suffix.","type":"SimpleText"}]}]}],"lastModifiedTime":1750709444068,"tocItem":{"chapterTitle":"Using Interfaces","pageTitle":"5.1 Hardcaml Interfaces","pageMeta":{"parent":["using_interfaces.mdx"],"title":["5.1 Hardcaml Interfaces"],"uuid":["f97124f7-069b-32e1-d699-d81b87d34d3b"]},"dirName":"using-interfaces","fileName":"hardcaml_interfaces","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Complete Interface API","id":"complete-interface-api","customAnchorId":"complete-interface-api"}]}},{"type":"Page","content":[{"id":"interfaces-with-ppx_hardcaml","additionalIds":[],"title":"Interfaces with ppx_hardcaml","type":"Section","content":[{"lang":"ocaml","snippet":"module Simple_interface = struct\n  type 'a t =\n    { foo : 'a [@bits 32]\n    ; bar : 'a (* Where a bit width is not specified, it defaults to 1. *)\n    }\n  [@@deriving hardcaml]\nend","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# print_s [%message (Simple_interface.port_names_and_widths : (string * int) Simple_interface.t)]\n(Simple_interface.port_names_and_widths ((foo (foo 32)) (bar (bar 1))))\n- : unit = ()","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"By default the ppx uses the field name for the string name, and ","type":"SimpleText"},{"code":"[@bits N]","type":"InlinedCode"},{"text":" attribute to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"specify the field width - if not provided it defaults to ","type":"SimpleText"},{"code":"1","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The ppx supports nesting, arrays, lists, and various tools to manage port naming.","type":"SimpleText"}]},{"id":"interfaces-with-ppx_hardcaml-nesting","additionalIds":["nesting"],"level":2,"title":"Nesting","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Interfaces can contain other interfaces:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Nested_interfaces = struct\n  type 'a t =\n    { clock : 'a\n    ; clear : 'a\n    ; hello : 'a Simple_interface.t\n    ; world : 'a Simple_interface.t\n    }\n  [@@deriving hardcaml]\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Nesting can go as deep as required.","type":"SimpleText"}]},{"id":"interfaces-with-ppx_hardcaml-arrays-and-lists","additionalIds":["arrays-and-lists"],"level":2,"title":"Arrays and lists","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"For ","type":"SimpleText"},{"code":"array","type":"InlinedCode"},{"text":"s and ","type":"SimpleText"},{"code":"list","type":"InlinedCode"},{"text":"s, the lengths must be specified with an attribute.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Array_and_list_interfaces = struct\n  type 'a t =\n    { my_array : 'a array [@length 2]\n    ; my_list : 'a list [@length 10] [@bits 10]\n    }\n  [@@deriving hardcaml]\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Arrays of nested interfaces are also supported.","type":"SimpleText"}]},{"id":"interfaces-with-ppx_hardcaml-options","additionalIds":["options"],"level":2,"title":"Options","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Fields in an interface may be optional. Simple and nested fields are supported.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Interface_with_option = struct \n  type 'a t = \n    { maybe_x : 'a option[@exists true][@bits 3] \n    ; maybe_y : 'a Simple_interface.t option [@exists false]\n    }\n    [@@deriving hardcaml]\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The attribute ","type":"SimpleText"},{"code":"exists","type":"InlinedCode"},{"text":" controls if they are included in the interface or not and must be","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"specified. Such fields can arise when describing a circuit generator where some","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"configuration option may require extra inputs or outputs.","type":"SimpleText"}]}]},{"id":"naming","additionalIds":[],"title":"Naming","type":"Section","content":[{"id":"naming-naming-simple-fields","additionalIds":["naming-simple-fields"],"level":2,"title":"Naming simple fields","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"By default, the field name is used to derive a port name. Port names will be used during","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"RTL generation. This can be modified with attributes.","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"rtlname","type":"InlinedCode"},{"text":" overrides the fields name with the given string.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"rtlprefix","type":"InlinedCode"},{"text":" / ","type":"SimpleText"},{"code":"rtlsuffix","type":"InlinedCode"},{"text":" apply the given prefix and/or suffix to the name","type":"SimpleText"}]}]}]},{"lang":"ocaml","snippet":"module Unmodified_port_names = struct\n  type 'a t =\n    { a : 'a\n    ; b : 'a\n    ; c : 'a\n    }\n  [@@deriving hardcaml]\nend","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"module Modified_port_names = struct\n  type 'a t =\n    { a : 'a[@rtlname \"aaa\"]\n    ; b : 'a[@rtlprefix \"x_\"]\n    ; c : 'a[@rtlsuffix \"_x\"]\n    }\n  [@@deriving hardcaml]\nend","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# Unmodified_port_names.port_names;;\n- : string Unmodified_port_names.t =\n{Unmodified_port_names.a = \"a\"; b = \"b\"; c = \"c\"}\n# Modified_port_names.port_names;;\n- : string Modified_port_names.t =\n{Modified_port_names.a = \"aaa\"; b = \"x_b\"; c = \"c_x\"}","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"code":"rtlprefix","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"rtlsuffix","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"rtlmangle","type":"InlinedCode"},{"text":" attributes may also be used with nested","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"interfaces, though ","type":"SimpleText"},{"code":"rtlname","type":"InlinedCode"},{"text":" will not work.","type":"SimpleText"}]},{"id":"naming-naming-nested-interfaces","additionalIds":["naming-nested-interfaces"],"level":2,"title":"Naming nested interfaces","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"rtlprefix","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"rtlsuffix","type":"InlinedCode"},{"text":" can be applied to nested interfaces and will apply the given","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"prefix or suffix to each field within the nested interface.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"By default, we automatically mangle nested interface names by prefixing them with the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"field name and a ","type":"SimpleText"},{"code":"$","type":"InlinedCode"},{"text":" separator, to avoid name clashes.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# Nested_interfaces.port_names;;\n- : string Nested_interfaces.t =\n{Nested_interfaces.clock = \"clock\"; clear = \"clear\";\n hello = {Simple_interface.foo = \"hello$foo\"; bar = \"hello$bar\"};\n world = {Simple_interface.foo = \"world$foo\"; bar = \"world$bar\"}}","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"This functionality can be disabled with ","type":"SimpleText"},{"code":"~rtlmangle:false","type":"InlinedCode"},{"text":", or customized by specifying a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"different separator.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Nested_interfaces_mangled = struct\n  type 'a t =\n    { clock : 'a\n    ; clear : 'a\n    ; hello : 'a Simple_interface.t\n    ; world : 'a Simple_interface.t\n    }\n  [@@deriving hardcaml ~rtlmangle:\"_\"]\nend","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# Nested_interfaces_mangled.port_names;;\n- : string Nested_interfaces_mangled.t =\n{Nested_interfaces_mangled.clock = \"clock\"; clear = \"clear\";\n hello = {Simple_interface.foo = \"hello_foo\"; bar = \"hello_bar\"};\n world = {Simple_interface.foo = \"world_foo\"; bar = \"world_bar\"}}","lineNumber":"","type":"Snippet"},{"id":"naming-global-attributes","additionalIds":["global-attributes"],"level":2,"title":"Global attributes","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The naming attributes can be specified for all fields as follows:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Global_suffix = struct\n  type 'a t =\n    { a : 'a\n    ; b : 'a\n    ; c : 'a\n    }\n  [@@deriving hardcaml ~rtlsuffix:\"_i\"]\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"code":"rtlprefix","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"rtlsuffix","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"rtlmangle","type":"InlinedCode"},{"text":" are supported.","type":"SimpleText"}]}]}],"lastModifiedTime":1750709444495,"tocItem":{"chapterTitle":"Using Interfaces","pageTitle":"5.2 Interfaces with ppx_hardcaml","pageMeta":{"parent":["using_interfaces.mdx"],"title":["5.2 Interfaces with ppx_hardcaml"],"uuid":["48ef0dfa-1472-3118-1663-8302a7b49110"]},"dirName":"using-interfaces","fileName":"interfaces_with_ppx_hardcaml","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Interfaces with ppx_hardcaml","id":"interfaces-with-ppx_hardcaml","customAnchorId":"interfaces-with-ppx_hardcaml"},{"title":"Naming","id":"naming","customAnchorId":"naming"}]}},{"type":"Page","content":[{"id":"module-interfaces","additionalIds":[],"title":"Module Interfaces","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The primary use of interfaces is to define a general pattern to describe a Hardcaml","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"module. We will specify two interfaces called ","type":"SimpleText"},{"code":"I","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"O","type":"InlinedCode"},{"text":" which represent the input and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"output signals of a module along with a function called ","type":"SimpleText"},{"code":"create","type":"InlinedCode"},{"text":" to generate the logic.","type":"SimpleText"}]},{"lang":"","snippet":"module I : Interface.S\nmodule O : Interface.S\n\nval create : Signal.t I.t -> Signal.t O.t","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Hardcaml provides various functors (usually called ","type":"SimpleText"},{"code":"With_interface","type":"InlinedCode"},{"text":") that will generate","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"circuits, simulators, hierarchical instantiations, and more if we follow this pattern.","type":"SimpleText"}]},{"type":"BlockQuote","content":[{"type":"Paragraph","content":[{"text":"📝 The type of the create function does not have to precisely follow this signature. It","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"is fine to have further arguments (i.e. some configuration parameters) so long as it","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"ends with ","type":"SimpleText"},{"code":"Signal.t I.t -> Signal.t O.t","type":"InlinedCode"},{"text":".","type":"SimpleText"}]}]},{"id":"module-interfaces-example","additionalIds":["example"],"level":2,"title":"Example","type":"SubHeading"},{"lang":"ocaml","snippet":"module I = struct\n  type 'a t =\n    { clock : 'a\n    ; d : 'a[@bits 8]\n    }\n  [@@deriving hardcaml]\nend\n\nmodule O = struct\n  type 'a t =\n    { q : 'a[@bits 8]\n    ; q_n : 'a[@bits 8]\n    }\n  [@@deriving hardcaml]\nend","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# let create (i : _ I.t) =\n    let q = reg (Reg_spec.create ~clock:i.clock ()) i.d in\n    { O.q; q_n = ~: q }\nval create : t I.t -> t O.t = <fun>","lineNumber":"","type":"Snippet"},{"id":"module-interfaces-with_interface","additionalIds":["with_interface"],"level":2,"title":"With_interface","headingContent":[{"code":"With_interface","type":"InlinedCode"}],"type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Hardcaml supports this pattern by providing a number of functors usually called","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"With_interface","type":"InlinedCode"},{"text":". They take the ","type":"SimpleText"},{"code":"I","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"O","type":"InlinedCode"},{"text":" interfaces as parameters and will provide a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"function which takes ","type":"SimpleText"},{"code":"create","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"For example, we can create a circuit as follows:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# module My_circuit = Circuit.With_interface(I)(O)\nmodule My_circuit :\n  sig\n    type create = Hardcaml.Interface.Create_fn(I)(O).t\n    val create_exn :\n      ?config:Circuit.Config.t ->\n      ?input_attributes:Rtl_attribute.t list I.t ->\n      ?output_attributes:Rtl_attribute.t list O.t ->\n      name:string -> create -> Circuit.t\n  end\n# My_circuit.create_exn ~name:\"reg\" create\n- : Circuit.t = <abstr>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"In contrast this is what we would write without interfaces:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let create2 ~clock ~d = \n    let q = reg (Reg_spec.create ~clock ()) d in \n    q, ~:q\nval create2 : clock:t -> d:t -> t * t = <fun>\n# let q, q_n = create2 ~clock:(input \"clock\" 1) ~d:(input \"d\" 8) \nval q : t =\n  (register (width 8) ((clock clock) (clock_edge Rising)) (data_in d))\nval q_n : t = (not (width 8) (arguments (register)))\n# Circuit.create_exn ~name:\"reg\"\n    [ output \"q\" q; output \"q_n\" q_n ]\n- : Circuit.t = <abstr>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"As the number of signals into and out of a module grows (and 100's or even 1000's is not","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"infeasible) the utility of interfaces to deal with boilerplate grows.","type":"SimpleText"}]},{"id":"module-interfaces-configuration","additionalIds":["configuration"],"level":2,"title":"Configuration","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"When we define an interface we specify things like bit widths, field existence (using","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"options) and array or list lengths. However, we often want to write something more","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"generic. To do this we can use functors.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Taking the previous example, lets make the register width configurable.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Make(Config : sig val register_width : int end) = struct \n  module I = struct \n    type 'a t = \n      { clock : 'a \n      ; d : 'a[@bits Config.register_width] \n      }\n    [@@deriving hardcaml]\n  end\n\n  module O = struct \n    type 'a t = \n      { q : 'a[@bits Config.register_width] \n      ; q_n : 'a[@bits Config.register_width]\n      }\n    [@@deriving hardcaml]\n  end\n\n  let create (i : _ I.t) = \n      let q = reg (Reg_spec.create ~clock:i.clock ()) i.d in\n      { O.q; q_n = ~: q }\n  end","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We can now instantiate the functor and generate a circuit as before.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module My_design = Make(struct let register_width = 4 end) \nmodule My_circuit2 = Circuit.With_interface(My_design.I)(My_design.O)","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# My_circuit2.create_exn ~name:\"reg\" My_design.create\n- : Circuit.t = <abstr>","lineNumber":"","type":"Snippet"},{"id":"module-interfaces-configuration-interface-type-in-equality","additionalIds":["interface-type-in-equality"],"level":3,"title":"Interface type (in-)equality","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Consider the following 2 instantiations of our design.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module My_design16 = Make(struct let register_width = 16 end)\nmodule My_design32 = Make(struct let register_width = 32 end)","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Inside each instantiation we have records of type ","type":"SimpleText"},{"code":"I.t","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"O.t","type":"InlinedCode"},{"text":". They have exactly the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"same definition so are the types equal?","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"No. Because they are created inside a functor, distinct types are generated.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"On the other hand would we like them to be equal? I would argue no. Because they represent","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"interfaces with different bitwidths I would like the type system to differentiate them.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"On occasion it is useful to expose the type equality and it can still be done.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module X = struct \n  type 'a t = { x : 'a }[@@deriving hardcaml]\nend\n\nmodule Make_X(Config : sig val width : int end) \n  : Interface.S with type 'a t = 'a X.t\n= struct \n  include Interface.Update(X)(struct \n    let port_names_and_widths = { X.x = \"x\", Config.width }\n  end)\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"code":"Interface.Update","type":"InlinedCode"},{"text":" takes an existing interface and redefines the names and bitwidths of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the fields. The type constraint ","type":"SimpleText"},{"code":"with type 'a t = 'a X.t","type":"InlinedCode"},{"text":" exposes the desired equality.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Y = Make_X(struct let width = 10 end)\nmodule Z = Make_X(struct let width = 20 end)","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"As shown below the types of ","type":"SimpleText"},{"code":"Y.t","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"Z.t","type":"InlinedCode"},{"text":" are compatible.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# [ Y.port_names; Z.port_names ]\n- : string Z.t list = [{X.x = \"x\"}; {X.x = \"x\"}]","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709444366,"tocItem":{"chapterTitle":"Using Interfaces","pageTitle":"5.3 Module Interfaces","pageMeta":{"parent":["using_interfaces.mdx"],"title":["5.3 Module Interfaces"],"uuid":["3e42e133-1951-3dfd-442a-433342e680a5"]},"dirName":"using-interfaces","fileName":"module_interfaces","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Module Interfaces","id":"module-interfaces","customAnchorId":"module-interfaces"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"With standard Hardcaml ","type":"SimpleText"},{"url":"/hardcaml-docs/simulating-circuits/simulation","isFile":false,"type":"Link","content":[{"text":"simulations","type":"SimpleText"}]},{"text":" we are forced to manage input and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"output ports manually using the strings. ","type":"SimpleText"},{"url":"/hardcaml-docs/using-interfaces/hardcaml_interfaces","isFile":false,"type":"Link","content":[{"text":"Interfaces","type":"SimpleText"}]},{"text":" allow us to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"automate much of this work and are particularly useful as circuits get more complex.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The following is a common pattern for specifying a hardware circuit. It consists of an","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"input and output interface, and a function over these interfaces which constructs the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"logic.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"open Base\nopen Hardcaml\n\n(* Input interface. *)\nmodule I = struct\n  type 'a t =\n     { clock : 'a\n     ; foo : 'a [@bits 8]\n     ; bar : 'a [@bits 8]\n     }\n  [@@deriving hardcaml]\nend\n\n(* Output interface. *)\nmodule O = struct\n  type 'a t =\n    { baz : 'a [@bits 8]\n    ; baz_delayed : 'a [@bits 8]\n    }\n  [@@deriving hardcaml]\nend\n\nlet create (i : Signal.t I.t) : Signal.t O.t =\n  let open Signal in\n  let spec = Reg_spec.create ~clock:i.clock () in\n  let baz = i.foo +: i.bar in\n  let baz_delayed = reg ~enable:vdd spec baz in\n  { O. baz ; baz_delayed }\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"To simulate this, we can use the","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Cyclesim/With_interface/index.html","isFile":false,"type":"Link","content":[{"code":"Cyclesim.With_interface","type":"InlinedCode"}]},{"type":"SoftLineBreak"},{"text":"functor. This will automatically create a circuit with the input and output ports","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"labeled, build a simulator, and then construct input and output records for driving the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"simulator. All this and we never have to worry about the underlying string names of ports.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let create_sim () =\n    let module Sim = Cyclesim.With_interface(I)(O) in\n    Sim.create create\n  ;;\nval create_sim : unit -> (Bits.t ref I.t, Bits.t ref O.t) Cyclesim.t = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Notice the type signature of ","type":"SimpleText"},{"code":"(_, _) Cyclesim.t","type":"InlinedCode"},{"text":". The parametric type arguments to","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Cyclesim/index.html","isFile":false,"type":"Link","content":[{"code":"Cyclesim.t","type":"InlinedCode"}]},{"type":"SoftLineBreak"},{"text":"encode the types returned when retrieving the inputs and output values from the simulator","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"object.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Driving the inputs and reading outputs can be performed via the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"convenience of record fields.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let run_sim () =\n    let sim = create_sim () in\n    let inputs = Cyclesim.inputs sim in\n    let outputs = Cyclesim.outputs sim in\n    let print_outputs () =\n      Stdio.print_s (\n        [%sexp_of: int O.t]\n          (O.map outputs ~f:(fun p -> Bits.to_unsigned_int !p)))\n    in\n\n    inputs.foo := Bits.of_unsigned_int ~width:8 1;\n    inputs.bar := Bits.of_unsigned_int ~width:8 2;\n    Cyclesim.cycle sim;\n    print_outputs ();\n\n    inputs.foo := Bits.of_unsigned_int ~width:8 7;\n    inputs.bar := Bits.of_unsigned_int ~width:8 9;\n    Cyclesim.cycle sim;\n    print_outputs ();\n  ;;\nval run_sim : unit -> unit = <fun>\n\n# run_sim ()\n((baz 3) (baz_delayed 3))\n((baz 16) (baz_delayed 16))\n- : unit = ()","lineNumber":"","type":"Snippet"}],"lastModifiedTime":1750709443635,"tocItem":{"chapterTitle":"Using Interfaces","pageTitle":"5.4 Simulating with Interfaces","pageMeta":{"parent":["using_interfaces.mdx"],"title":["5.4 Simulating with Interfaces"],"uuid":["256cce50-2166-3727-3beb-ab7d28d16a62"]},"dirName":"using-interfaces","fileName":"simulating_with_interfaces","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"Hardcaml provides support for enumerations with a finite number of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"instances through the Enum module. An Enum type declares a finite (ie","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"non-recursive) set of variants and requires a deriving specification","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"as follows.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Simple_enum_example = struct\n  module Enum = struct\n    type t =\n      | Foo\n      | Bar\n    [@@deriving sexp_of, compare ~localize, enumerate]\n  end\n\n  include Hardcaml.Enum.Make_enums(Enum)\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The variant cases defining an enum may in turn have arguments which","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"are also Enums.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"open Base\nopen Hardcaml\n\nmodule Foo = struct\n  type t =\n    | Foo_a\n    | Foo_b\n  [@@deriving sexp_of, compare ~localize, enumerate]\nend\n\nmodule Bar = struct\n  type t =\n    | Bar_a\n    | Bar_b\n    | Bar_c\n  [@@deriving sexp_of, compare ~localize, enumerate]\nend\n\nmodule Hello = struct\n  module Enum = struct\n    type t =\n      | Foo of Foo.t\n      | Bar of Bar.t\n    [@@deriving sexp_of, compare ~localize, enumerate]\n  end\n\n  include Hardcaml.Enum.Make_enums(Enum)\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"code":"Make_enums","type":"InlinedCode"},{"text":" functor creates two modules called ","type":"SimpleText"},{"code":"One_hot","type":"InlinedCode"},{"text":" and","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Binary","type":"InlinedCode"},{"text":". Each of these modules conforms to the ","type":"SimpleText"},{"code":"Hardcaml.Interface.S","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"signature so they can be treated as regular Hardcaml interfaces. The","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"'a","type":"InlinedCode"},{"text":" parameter specifies the underlying type of the enum. ie: in","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"designing circuits, it would be ","type":"SimpleText"},{"code":"Signal.t","type":"InlinedCode"},{"text":", and in simulations, it","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"will be ","type":"SimpleText"},{"code":"Bits.t ref","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Both variants have a similar API, differing only in their encoding as","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"a bit vector. From here on, we will demonstrate the ","type":"SimpleText"},{"code":"Binary","type":"InlinedCode"},{"text":" API.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The generated modules contain ","type":"SimpleText"},{"code":"of_enum","type":"InlinedCode"},{"text":" functions to transform","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"statically known enums into arbitrary desired ","type":"SimpleText"},{"code":"'a t","type":"InlinedCode"},{"text":", so long the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"provided ","type":"SimpleText"},{"code":"'a","type":"InlinedCode"},{"text":" satisfied the ","type":"SimpleText"},{"code":"Comb.S","type":"InlinedCode"},{"text":" interface. (Both ","type":"SimpleText"},{"code":"(module Bits)","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"and ","type":"SimpleText"},{"code":"(module Signal)","type":"InlinedCode"},{"text":" shipped with Hardcaml support them)","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let x : Signal.t Hello.Binary.t =\n    Hello.Binary.of_enum (module Signal) (Foo Foo_a)\n  ;;\nval x : Signal.t Hello.Binary.t = <abstr>\n# let y = Hello.Binary.Of_signal.of_enum (Bar Bar_a)\nval y : Signal.t Hello.Binary.t = <abstr>\n\n# let z = Hello.Binary.Of_signal.(==:) x y\nval z : Signal.t = (const (width 1) (value 0b0))\n\n# let a = Hello.Binary.Of_signal.is x (Foo Foo_a)\nval a : Signal.t = (const (width 1) (value 0b1))","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"You get several enum-specific features for defining circuits in the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"regular Signal-like API, notably the ","type":"SimpleText"},{"code":"match_","type":"InlinedCode"},{"text":" function for","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"multiplexing on the enum value. Note that this differs from ","type":"SimpleText"},{"code":"mux","type":"InlinedCode"},{"text":" which","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"creates a multiplexer that returns a value of the type enum.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let non_exhaustive_matching =\n  let open Signal in\n  Hello.Binary.match_\n    (module Signal)\n    (* [default] needs to be specified when the match cases are not\n       exhaustive. *)\n    ~default:(zero 10)\n    x\n    [ Foo Foo_a, ones 10\n    ; Bar Bar_a, zero 10\n    ]\n;;\n\n(* [Of_signal.match_] is similar to [match_], except it does not\n   require an explicit a first class module argument. *)\nlet exhaustive_matching =\n  let open Signal in\n  Hello.Binary.Of_signal.match_\n    y\n    [ Foo Foo_a, of_unsigned_int ~width:10 55\n    ; Foo Foo_b, of_unsigned_int ~width:10 44\n    ; Bar Bar_a, of_unsigned_int ~width:10 66\n    ; Bar Bar_b, of_unsigned_int ~width:10 88\n    ; Bar Bar_c, of_unsigned_int ~width:10 77\n    ]\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"code":"match_","type":"InlinedCode"},{"text":" function is also defined for the Always API, which makes","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"it really clean to write \"pattern-match\"-like applications on enums.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Similar to ","type":"SimpleText"},{"code":"Of_signal.match_","type":"InlinedCode"},{"text":", there is an optional ","type":"SimpleText"},{"code":"default","type":"InlinedCode"},{"text":" argument","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"for non-exhaustive matches.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# Hello.Binary.Of_always.match_ ;;\n- : ?default:Always.t list ->\n    Signal.t Hello.Binary.t ->\n    (Hello.Enum.t * Always.t list) list -> Always.t\n= <fun>\n\n# let exhaustive_matching case =\n    Hello.Binary.Of_always.match_\n      ~default:[\n        (* The default case here. *)\n      ]\n      case\n      [ Foo Foo_a, [\n          (* Some logic here. *)\n        ];\n        Bar Bar_a, [\n          (* Even more logic here. *)\n        ]\n      ]\n  ;;\nval exhaustive_matching : Signal.t Hello.Binary.t -> Always.t = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"This generated enum module implements the ","type":"SimpleText"},{"code":"Hardcaml.Interface.S","type":"InlinedCode"},{"text":", so you","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"get access to the various convenient functions defined in ","type":"SimpleText"},{"code":"Of_signal","type":"InlinedCode"},{"text":",","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Of_always","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"Of_bits","type":"InlinedCode"},{"text":". For example:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"(* A multiplexer that returns value of the enum, as opposed to\n   multiplexing on the enum itself (as match_ does). *)\nlet multiplexers =\n  let selector = Signal.input \"selector\" 2 in\n  Hello.Binary.Of_signal.(mux\n    selector\n    [ of_enum (Foo Foo_a)\n    ; of_enum (Bar Bar_a)\n    ; of_enum (Bar Bar_b)\n    ; of_enum (Foo Foo_b)\n    ]\n  )\n;;\n\nlet clock = Signal.input \"clock\" 1\nlet spec = Signal.Reg_spec.create ~clock ()\n\n(* Registers that stores the enum value. *)\nlet registers : Signal.t Hello.Binary.t =\n  let wires = Hello.Binary.Of_signal.wires () in\n\n  Hello.Binary.Of_signal.reg ~enable:Signal.vdd spec wires\n;;\n\n(* Usage in always blocks. You can (almost) seamlessly assign values\n   to them. *)\nlet _ : Always.t list =\n  let cond = Signal.input \"cond\" 1 in\n  let var = Hello.Binary.Of_always.reg ~enable:Signal.vdd spec in\n  let assign_hello = Hello.Binary.Of_always.assign in\n  Always.[\n    if_ cond [\n      assign_hello var (Hello.Binary.Of_signal.of_enum (Foo Foo_a))\n    ] @@ [\n      (* This doesn't make much sense in practice. This is just\n         to the [value] function.\n      *)\n      assign_hello var (Hello.Binary.Of_always.value var)\n    ]\n  ]\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The generated enum can even be used as part of regular Hardcaml","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"interfaces! This makes Hardcaml Enums powerful, since the circuit","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"interfaces can simply use it without nasty type conversions. For","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"example:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module I = struct\n  type 'a t =\n    { clock : 'a\n    ; clear : 'a\n    ; hello : 'a Hello.Binary.t\n    }\n  [@@deriving hardcaml]\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"For more advanced usage, you can convert to the underlying ","type":"SimpleText"},{"code":"Bits.t","type":"InlinedCode"},{"text":" or","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Signal.t","type":"InlinedCode"},{"text":" value. The ","type":"SimpleText"},{"code":"of_raw","type":"InlinedCode"},{"text":" function only performs checks on","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"widths. It is the caller's responsibility to ensure that when it's","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"One_hot","type":"InlinedCode"},{"text":", the provided raw value is always one hot; when it's","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Binary","type":"InlinedCode"},{"text":", the provided raw value should be strictly less than the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"number of possible cases.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let this_will_raise_due_to_a_width_mismatch =\n    Hello.Binary.Of_signal.of_raw (Signal.of_unsigned_int ~width:30 10)\n  ;;\nException: (Failure \"Width mismatch. Enum expects 3, but obtained 30\").\n\n# let this_is_valid_and_fine =\n    Hello.Binary.Of_signal.of_raw (Signal.of_unsigned_int ~width:3 0)\n  ;;\nval this_is_valid_and_fine : Signal.t Hello.Binary.t = <abstr>\n\n# let this_is_undefined_and_will_not_raise =\n    Hello.Binary.Of_signal.of_raw (Signal.of_unsigned_int ~width:3 6)\n  ;;\nval this_is_undefined_and_will_not_raise : Signal.t Hello.Binary.t = <abstr>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Enums are well supported in simulations too! Let's make a little state","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"machine that increments or decrements a counter based on an enum's input","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"value. The module simulation will also output the previous clock","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"cycle's enum input.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module O = struct\n  type 'a t =\n    { counter : 'a [@bits 32]\n    ; prev_hello : 'a Hello.Binary.t [@rtlmangle true]\n    }\n  [@@deriving hardcaml]\nend","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# let create (i : _ I.t) =\n    let open Signal in\n    let spec = Signal.Reg_spec.create ~clock:i.clock ~clear:i.clear () in\n    let ctr = Always.Variable.reg spec ~width:32 ~enable:vdd in\n    let prev_hello = Hello.Binary.Of_always.reg ~enable:vdd spec in\n    Always.(compile [\n      Hello.Binary.Of_always.match_ i.hello [\n        (* Foo increments! *)\n        Foo Foo_a, [ ctr <-- (ctr.value +:. 1); ];\n        Foo Foo_b, [ ctr <-- (ctr.value +:. 2); ];\n\n        (* Bar decrements.. *)\n        Bar Bar_a, [ ctr <-- (ctr.value -:. 1) ];\n        Bar Bar_b, [ ctr <-- (ctr.value -:. 2) ];\n        Bar Bar_c, [ ctr <-- (ctr.value -:. 3) ];\n      ];\n\n      Hello.Binary.Of_always.assign prev_hello i.hello;\n    ]);\n    { O.\n      counter = ctr.value\n    ; prev_hello = Hello.Binary.Of_always.value prev_hello\n    }\n  ;;\nval create : Signal.t I.t -> Signal.t O.t = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Since these enum files are not simply of type ","type":"SimpleText"},{"code":"Bits.t ref","type":"InlinedCode"},{"text":", we need to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"opt for special APIs for getting/setting them in simulations:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# Hello.Binary.sim_set\n- : Bits.t ref Hello.Binary.t -> Hello.Enum.t -> unit = <fun>\n# Hello.Binary.sim_set_raw\n- : Bits.t ref Hello.Binary.t -> Bits.t -> unit = <fun>\n# Hello.Binary.sim_get\n- : Bits.t ref Hello.Binary.t -> Hello.Enum.t Or_error.t = <fun>\n# Hello.Binary.sim_get_raw\n- : Bits.t ref Hello.Binary.t -> Bits.t = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Using those functions, we can drive a Hardcaml Cyclesim.t similar to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"regular Hardcaml sims:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let sim =\n    let module Sim = Cyclesim.With_interface(I)(O) in\n    Sim.create create\n\nlet inputs = Cyclesim.inputs sim\nlet outputs = Cyclesim.outputs sim\n\nlet print () =\n  let prev_hello = Or_error.ok_exn (Hello.Binary.sim_get outputs.prev_hello) in\n  let counter = Bits.to_unsigned_int !(outputs.counter) in\n  Stdio.print_s [%message\n    (prev_hello : Hello.Enum.t)\n    (counter : int)\n  ]","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# Hello.Binary.sim_set inputs.hello (Foo Foo_a);\n- : unit = ()\n# Cyclesim.cycle sim;\n- : unit = ()\n# print ();\n((prev_hello (Foo Foo_a)) (counter 1))\n- : unit = ()\n# Hello.Binary.sim_set inputs.hello (Foo Foo_b);\n- : unit = ()\n# Cyclesim.cycle sim;\n- : unit = ()\n# print ();\n((prev_hello (Foo Foo_b)) (counter 3))\n- : unit = ()\n# Hello.Binary.sim_set inputs.hello (Bar Bar_a);\n- : unit = ()\n# Cyclesim.cycle sim;\n- : unit = ()\n# Cyclesim.cycle sim;\n- : unit = ()\n# print ();\n((prev_hello (Bar Bar_a)) (counter 1))\n- : unit = ()","lineNumber":"","type":"Snippet"}],"lastModifiedTime":1750709443886,"tocItem":{"chapterTitle":"Using Interfaces","pageTitle":"5.5 Enums in Hardcaml","pageMeta":{"parent":["using_interfaces.mdx"],"title":["5.5 Enums in Hardcaml"],"uuid":["27e11f7a-7f68-33eb-4afb-7aa13b7785bd"]},"dirName":"using-interfaces","fileName":"enums_in_hardcaml","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"We saw a simple implementation of an 8 bit ","type":"SimpleText"},{"url":"/hardcaml-docs/designing-circuits/alu","isFile":false,"type":"Link","content":[{"text":"ALU","type":"SimpleText"}]},{"text":" before. With interfaces and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"enums we can now express it as follows:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Op = struct\n  module Enum = struct\n    type t =\n      | Add\n      | Sub\n      | Mul\n      | Sll\n      | Srl\n      | And\n      | Or\n      | Xor\n      | Not\n      | Less\n      | Equal\n    [@@deriving sexp_of, compare ~localize, enumerate]\n  end\n\n  include Hardcaml.Enum.Make_enums (Enum)\nend\n\nmodule I = struct\n  type 'a t =\n    { op : 'a Op.Binary.t\n    ; a : 'a [@bits 8]\n    ; b : 'a [@bits 8]\n    }\n  [@@deriving hardcaml]\nend\n\nmodule O = struct\n  type 'a t = { q : 'a [@bits 8] } [@@deriving hardcaml]\nend\n\nlet typed_alu ({ op; a; b } : _ I.t) =\n  { O.q =\n      Op.Binary.match_\n        (module Signal)\n        ~default:(zero 8)\n        op\n        [ Add, a +: b\n        ; Sub, a -: b\n        ; Mul, (a *: b).:[7, 0]\n        ; Srl, srl a ~by:1\n        ; Sll, sll a ~by:1\n        ; And, a &: b\n        ; Or, a |: b\n        ; Xor, a ^: b\n        ; Not, ~:a\n        ; Less, uresize (a <: b) ~width:8\n        ; Equal, uresize (a ==: b) ~width:8\n        ]\n  }\n;;","lineNumber":"","type":"Snippet"}],"lastModifiedTime":1750709444070,"tocItem":{"chapterTitle":"Using Interfaces","pageTitle":"5.5.1 Typed ALU","pageMeta":{"parent":["enums.mdx"],"title":["5.5.1 Typed ALU"],"uuid":["d1a5eb35-3ddf-3ca6-8d31-9d9900b0cffc"]},"dirName":"using-interfaces","fileName":"typed_alu","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"A ","type":"SimpleText"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Scope/index.html","isFile":false,"type":"Link","content":[{"code":"Scope.t","type":"InlinedCode"}]},{"text":" is a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"(mutable) object passed between the circuits that form a complete Hardcaml design. It","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"performs a number of roles","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Track the current position within a design hierarchy.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Control how we elaborate a design.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Provide a means to generate hierarchy aware names.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Record sub-circuits within a database.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Capture ","type":"SimpleText"},{"type":"Emphasis","content":[{"text":"side band","type":"SimpleText"}]},{"text":" data such as properties and assertions.","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"We will shortly learn how to generate hierarchical designs in Hardcaml, and ","type":"SimpleText"},{"code":"Scope","type":"InlinedCode"},{"text":"s play","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"a key role in that.","type":"SimpleText"}]},{"id":"creating-scopes","additionalIds":[],"level":2,"title":"Creating Scopes","type":"SubHeading"},{"lang":"ocaml","snippet":"# let scope = Scope.create ()\nval scope : Scope.t = <abstr>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"code":"Scope","type":"InlinedCode"},{"text":"s take a few interesting arguments which control how a design is elaborated.","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"flatten_design","type":"InlinedCode"},{"text":" if ","type":"SimpleText"},{"code":"true","type":"InlinedCode"},{"text":" the entire circuit is flattened (or inlined). If ","type":"SimpleText"},{"code":"false","type":"InlinedCode"},{"text":" it","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"will retain hierarchy.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"auto_label_hierarchical_ports","type":"InlinedCode"},{"text":" a useful option when using the Hardcaml waveform viewer","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"that allows it to show the hierarchical structure of a design.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"naming_scheme","type":"InlinedCode"},{"text":" control how names are generated. The defaults are set up to work with","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the value of ","type":"SimpleText"},{"code":"flatten_design","type":"InlinedCode"},{"text":", but can be overridden.","type":"SimpleText"}]}]}]},{"id":"creating-scopes-flattening-a-design","additionalIds":["flattening-a-design"],"level":3,"title":"Flattening a Design","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"By default ","type":"SimpleText"},{"code":"Scope","type":"InlinedCode"},{"text":"s set ","type":"SimpleText"},{"code":"flatten_design","type":"InlinedCode"},{"text":" to ","type":"SimpleText"},{"code":"false","type":"InlinedCode"},{"text":". This is generally what you want when","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"generating RTL. For simulation this wont work - our simulators do not support hierarchical","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"designs so this argument should be set to ","type":"SimpleText"},{"code":"true","type":"InlinedCode"},{"text":":","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let scope = Scope.create ~flatten_design:true ~auto_label_hierarchical_ports:true ()\nval scope : Scope.t = <abstr>","lineNumber":"","type":"Snippet"},{"id":"creating-scopes-sub-scopes","additionalIds":["sub-scopes"],"level":3,"title":"Sub-scopes","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"A new sub-scope can be created from a scope.  This is how we record a design hierarchy.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let scope = Scope.sub_scope scope \"foo\"","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Sub-scopes are just ","type":"SimpleText"},{"code":"Scope","type":"InlinedCode"},{"text":"s placed at the appropriate point in the hierarchy.","type":"SimpleText"}]},{"id":"naming-signals-with-scopes","additionalIds":[],"level":2,"title":"Naming signals with Scopes","headingContent":[{"text":"Naming signals with ","type":"SimpleText"},{"code":"Scope","type":"InlinedCode"},{"text":"s","type":"SimpleText"}],"type":"SubHeading"},{"type":"Paragraph","content":[{"text":"We can define a scope aware naming function with:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let (--) = Scope.naming scope\nval ( -- ) : loc:[%call_pos] -> Signal.t -> string -> Signal.t = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"And this is what we should do within hierarchical Hardcaml designs.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let x = Signal.of_string \"0\" -- \"x\"\nval x : Signal.t = (const (names (foo$x)) (width 1) (value 0b0))","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Note that name of ","type":"SimpleText"},{"code":"x","type":"InlinedCode"},{"text":" is aware of its position within ","type":"SimpleText"},{"code":"foo","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"id":"using-scopes","additionalIds":[],"level":2,"title":"Using Scopes","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The main thing we need to do is pass a scope argument to every ","type":"SimpleText"},{"code":"create","type":"InlinedCode"},{"text":" function we","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"define:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let create (scope : Scope.t) (i : _ I.t) =\n  let foo = Foo.create (Scope.sub_scope scope \"foo\") in\n  ...","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Sub-scopes are then created when we create other circuits. This is how they track the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"current hierarchy position.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"However, you shouldn't really ever need to actually do anything much with scopes except:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Create them with ","type":"SimpleText"},{"code":"flatten_design","type":"InlinedCode"},{"text":" set to true or false depending on whether you want to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"generate RTL or run a simulation.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Pass them to your create functions.","type":"SimpleText"}]}]}]}],"lastModifiedTime":1750709443233,"tocItem":{"chapterTitle":"Using Interfaces","pageTitle":"5.6 Scopes","pageMeta":{"parent":["using_interfaces.mdx"],"title":["5.6 Scopes"],"uuid":["10a3debf-e820-35f5-5239-a8c435568edc"]},"dirName":"using-interfaces","fileName":"scopes","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"type":"Emphasis","content":[{"text":"Prerequisite: ","type":"SimpleText"},{"url":"/hardcaml-docs/using-interfaces/hardcaml_interfaces","isFile":false,"type":"Link","content":[{"text":"Hardcaml interfaces","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"In Hardcaml, module","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Hierarchy/index.html","isFile":false,"type":"Link","content":[{"text":"hierarchy","type":"SimpleText"}]},{"text":" allows","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"us to partition a design into a tree of sub-circuits, each generated as its own Verilog or","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"VHDL module when producing RTL output.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"This builds upon ","type":"SimpleText"},{"url":"/hardcaml-docs/more-on-circuit-design/instantiation","isFile":false,"type":"Link","content":[{"text":"instantiation","type":"SimpleText"}]},{"text":", ","type":"SimpleText"},{"url":"/hardcaml-docs/designing-circuits/rtl_generation","isFile":false,"type":"Link","content":[{"text":"circuit","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"databases","type":"SimpleText"}]},{"text":", ","type":"SimpleText"},{"code":"Scope","type":"InlinedCode"},{"text":"s, and the design pattern for defining circuits","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"using ","type":"SimpleText"},{"code":"I","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"O","type":"InlinedCode"},{"text":" interfaces along with a ","type":"SimpleText"},{"code":"create","type":"InlinedCode"},{"text":" function.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Module hierarchies provide several important benefits:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Controls the naming of signals within the design hierarchy.","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Timing reports/logic utilization reports from backend vendor tools will be much easier","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"to comprehend.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Allows better organization of waveforms which can group signals according to the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"module hierarchy.","type":"SimpleText"}]}]}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Reduces the size of the generated RTL file, where there is substantial logic","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"duplication.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Provides some options for controlling the backend process of building the final hardware","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"design with vendor tools.","type":"SimpleText"}]}]}]},{"id":"a-design-pattern-for-circuits","additionalIds":[],"title":"A Design Pattern for Circuits","type":"Section","content":[{"type":"Paragraph","content":[{"text":"We extend our previous design pattern for circuits to now include a ","type":"SimpleText"},{"code":"Scope.t","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"open Hardcaml\n\nmodule type Module_design_pattern = sig\n  module I : Interface.S\n  module O : Interface.S\n\n  val create : Scope.t -> Signal.t I.t -> Signal.t O.t\n  val hierarchical : Scope.t -> Signal.t I.t -> Signal.t O.t\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"code":"I","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"O","type":"InlinedCode"},{"text":" interfaces and the ","type":"SimpleText"},{"code":"create","type":"InlinedCode"},{"text":" function we already know about.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module I = struct\n  type 'a t =\n    { clock : 'a\n    ; clear : 'a\n    ; foo : 'a [@bits 8]\n    }\n  [@@deriving hardcaml]\nend\n\nmodule O = struct\n  type 'a t = { foo_d : 'a [@bits 8] }\n  [@@deriving hardcaml]\nend","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# let create (_scope : Scope.t) (input : Signal.t I.t) =\n    let spec_with_clear =\n      Signal.Reg_spec.create ~clock:input.clock ~clear:input.clear ()\n    in\n    let foo_d = Signal.reg spec_with_clear ~enable:Signal.vdd input.foo in\n    { O. foo_d }\nval create : Scope.t -> Signal.t I.t -> Signal.t O.t = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"code":"hierarchical","type":"InlinedCode"},{"text":" is new, and is what we use to generate structured, multi-level Hardcaml","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"designs. It's mechanically derived as follows:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let hierarchical (scope : Scope.t) (input : Signal.t I.t) =\n    let module H = Hierarchy.In_scope(I)(O) in\n    H.hierarchical ~scope ~name:\"module_name\" ~instance:\"module_instance_2\" create input\nval hierarchical : Scope.t -> Signal.t I.t -> Signal.t O.t = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"code":"hierarchical","type":"InlinedCode"},{"text":" function is built using the ","type":"SimpleText"},{"code":"Hierarchy.In_scope","type":"InlinedCode"},{"text":" functor. It provides a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"function called ","type":"SimpleText"},{"code":"H.hierarchical","type":"InlinedCode"},{"text":" that takes ","type":"SimpleText"},{"code":"scope","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"create","type":"InlinedCode"},{"text":" and elaborates it","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"according to whether ","type":"SimpleText"},{"code":"flatten_design","type":"InlinedCode"},{"text":" setting of the root scope:","type":"SimpleText"}]},{"bulletMarker":"-","tight":false,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"type":"StrongEmphasis","content":[{"text":"Flattened Mode","type":"SimpleText"}]},{"text":" (","type":"SimpleText"},{"code":"flatten_design = true","type":"InlinedCode"},{"text":"): The function calls the ","type":"SimpleText"},{"code":"create","type":"InlinedCode"},{"text":" function","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"of your submodule directly, which inlines all the logic into the parent circuit. This","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"results in a single, flat module with no hierarchy.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"type":"StrongEmphasis","content":[{"text":"Hierarchical Mode","type":"SimpleText"}]},{"text":" (","type":"SimpleText"},{"code":"flatten_design = false","type":"InlinedCode"},{"text":"): The function generates an","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"instantiation for our subcircuit, then elaborates it separately and stores its","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"implementation in a ","type":"SimpleText"},{"code":"Circuit_database.t","type":"InlinedCode"},{"text":". This maintains proper module hierarchy in the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"generated RTL.","type":"SimpleText"}]}]}]}]},{"id":"summary","additionalIds":[],"title":"Summary","type":"Section","content":[{"type":"Paragraph","content":[{"text":"If we follow the design pattern here we must pass a scope to our ","type":"SimpleText"},{"code":"create","type":"InlinedCode"},{"text":" functions. We","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"then use the ","type":"SimpleText"},{"code":"Hierarchy.In_scope","type":"InlinedCode"},{"text":" functor to derive the ","type":"SimpleText"},{"code":"hierarchical","type":"InlinedCode"},{"text":" function. When we","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"want to instantiate a subcircuit, we call ","type":"SimpleText"},{"code":"hierarchical","type":"InlinedCode"},{"text":" instead of ","type":"SimpleText"},{"code":"create","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"To elaborate a full design, we call the top level ","type":"SimpleText"},{"code":"create","type":"InlinedCode"},{"text":" function with a scope that will","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"set ","type":"SimpleText"},{"code":"flatten_design","type":"InlinedCode"},{"text":" as appropriate. As the design is elaborated (by calling the","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"hierarchical","type":"InlinedCode"},{"text":" functions of subcircuits) we will either build a single large fully inlined","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"design, or just the top level circuit along with a database containing all the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"instantiated subcircuits.","type":"SimpleText"}]},{"id":"summary-simulation","additionalIds":["simulation"],"level":2,"title":"Simulation","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Here's an example of how we would simulate a hierarchical design:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let create_sim () =\n    let module Sim = Cyclesim.With_interface(I)(O) in\n    let scope = Scope.create ~flatten_design:true () in\n    Sim.create (create scope)\nval create_sim : unit -> (Bits.t ref I.t, Bits.t ref O.t) Cyclesim.t = <fun>","lineNumber":"","type":"Snippet"},{"id":"summary-rtl-generation","additionalIds":["rtl-generation"],"level":2,"title":"RTL generation","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"For RTL generation we need to do a couple of things:","type":"SimpleText"}]},{"delimiter":".","startNumber":1,"type":"OrderedList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Create the scope with ","type":"SimpleText"},{"code":"flatten_design","type":"InlinedCode"},{"text":" set to false.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Construct a ","type":"SimpleText"},{"code":"Circuit","type":"InlinedCode"},{"text":".","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Get the circuit database from the scope.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Pass the circuit database to the ","type":"SimpleText"},{"code":"Rtl.print","type":"InlinedCode"},{"text":" function.","type":"SimpleText"}]}]}]},{"lang":"ocaml","snippet":"# let write_verilog () = \n    let module Circuit = Circuit.With_interface(I)(O) in \n    let scope = Scope.create ~flatten_design:false () in \n    let circuit = Circuit.create_exn ~name:\"top\" (create scope) in\n    let database = Scope.circuit_database scope in \n    Rtl.print ~database Verilog circuit\nval write_verilog : unit -> unit = <fun>","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709444241,"tocItem":{"chapterTitle":"Using Interfaces","pageTitle":"5.7 Module Hierarchies","pageMeta":{"parent":["using_interfaces.mdx"],"title":["5.7 Module Hierarchies"],"uuid":["f91e686c-452e-3009-465e-c14ac99c3d78"]},"dirName":"using-interfaces","fileName":"module_hierarchies","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"A Design Pattern for Circuits","id":"a-design-pattern-for-circuits","customAnchorId":"a-design-pattern-for-circuits"},{"title":"Summary","id":"summary","customAnchorId":"summary"}]}},{"type":"Page","content":[{"id":"naming-with-ppx_hardcaml","additionalIds":[],"title":"Naming with ppx_hardcaml","headingContent":[{"text":"Naming with ","type":"SimpleText"},{"code":"ppx_hardcaml","type":"InlinedCode"}],"type":"Section","content":[{"type":"Paragraph","content":[{"text":"We have seen the ","type":"SimpleText"},{"code":"(--)","type":"InlinedCode"},{"text":" operator which applies a simple string name to a signal. We have","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"also seen ","type":"SimpleText"},{"code":"Scope.naming","type":"InlinedCode"},{"text":" which creates a naming operator appropriate for the current level","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"in a design hierarchy.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The Hardcaml ppx provides a syntax which makes it very convenient to apply scoped names to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Hardcaml signals.","type":"SimpleText"}]},{"id":"naming-with-ppx_hardcaml-basic-use","additionalIds":["basic-use"],"level":2,"title":"Basic use","type":"SubHeading"},{"lang":"ocaml","snippet":"# let create scope x =\n  let%hw y = ~: x in\n  y\nval create : Scope.t -> t -> t = <fun>\n# create (Scope.create ()) (of_string \"111\")\n- : t = (const (names (y)) (width 3) (value 0b000))","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The syntax ","type":"SimpleText"},{"code":"%hw","type":"InlinedCode"},{"text":" can be applied to let bindings whose name will then be applied to the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"expression. A ","type":"SimpleText"},{"code":"scope","type":"InlinedCode"},{"text":" must be (excuse me for this) ","type":"SimpleText"},{"type":"Emphasis","content":[{"text":"in scope","type":"SimpleText"}]},{"text":" for the ppx to work.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"An additional syntax allows the naming of ","type":"SimpleText"},{"code":"Always.Variable","type":"InlinedCode"},{"text":"s.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let create scope =\n    let%hw_var x = Always.Variable.wire ~default:gnd () in\n    x.value;;\nval create : Scope.t -> t = <fun>\n# create (Scope.create ())\n- : t = (wire (names (x)) (width 1))","lineNumber":"","type":"Snippet"},{"id":"naming-with-ppx_hardcaml-naming-interfaces","additionalIds":["naming-interfaces"],"level":2,"title":"Naming interfaces","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Interfaces can be named with the ppx:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let create scope x =\n    let%hw.X.Of_signal foo = x in\n    foo\nval create : Scope.t -> X.Of_signal.t -> X.Of_signal.t = <fun>\n# create (Scope.create ()) { X.x = (of_string \"111\") }\n- : X.Of_signal.t = {X.x = (const (names (foo$x)) (width 3) (value 0b111))}","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Similarly, interfaces containing ","type":"SimpleText"},{"code":"Always.Variable","type":"InlinedCode"},{"text":"s are named thus:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let create scope x =\n    let%hw.X.Of_always foo = X.Of_always.wire Signal.zero in\n    X.Of_always.value foo\nval create : Scope.t -> 'a -> t X.t = <fun>\n# create (Scope.create ()) { X.x = (of_string \"111\") }\n- : t X.t = {X.x = (wire (names (foo$x)) (width 1))}","lineNumber":"","type":"Snippet"},{"id":"naming-with-ppx_hardcaml-naming-with-a-module-path","additionalIds":["naming-with-a-module-path"],"level":2,"title":"Naming with a module path","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Interface naming is actually done via a more general framework. When we write","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"let%hw.Module.Path","type":"InlinedCode"},{"text":" the ppx finds a function called ","type":"SimpleText"},{"code":"Module.Path.__ppx_auto_name","type":"InlinedCode"},{"text":". This","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"is given the thing to name and a prefix derived from the scope and binding name and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"sets the names.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"This can be applied to specialized Hardcaml types and in particular is implemented for","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Always.State_machine","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let create scope =\n    let%hw.Always.State_machine my_state_machine = Always.State_machine.create (module State) spec in\n    my_state_machine\nval create : Scope.t -> State.t Always.State_machine.t = <fun>\n# create (Scope.create ())\n- : State.t Always.State_machine.t =\n{Hardcaml.Always.State_machine.current =\n  (register (names (my_state_machine)) (width 1)\n ((clock 0b0) (clock_edge Rising)) (data_in wire));\n is = <fun>; set_next = <fun>; switch = <fun>}","lineNumber":"","type":"Snippet"}]},{"id":"tuples","additionalIds":[],"title":"Tuples","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Bindings which describe a tuple are also supported.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let create scope x =\n  let%hw y, z = ~: x, x +:. 1 in\n  y, z\nval create : Scope.t -> t -> t * t = <fun>\n# create (Scope.create ()) (of_string \"111\")\n- : t * t =\n((const (names (y)) (width 3) (value 0b000)),\n (const (names (z)) (width 3) (value 0b000)))","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We can use ","type":"SimpleText"},{"code":"%hw_var","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"%hw.Module.Path","type":"InlinedCode"},{"text":" with this form also, however, all components","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"must be of the appropriate, and same, type (ie ","type":"SimpleText"},{"code":"Signal.t","type":"InlinedCode"},{"text":" or ","type":"SimpleText"},{"code":"Always.Variable.t","type":"InlinedCode"},{"text":" or","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Some_interface.t","type":"InlinedCode"},{"text":").","type":"SimpleText"}]}]},{"id":"lists-arrays-and-iarrays","additionalIds":[],"title":"Lists, Arrays, and Iarrays","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The final supported form allows lists, arrays, and iarrays to be named. As might be","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"expected, it applies the name along with an index for each element.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let create scope x =\n  let%hw_list foo = x in\n  foo\nval create : Scope.t -> t list -> t list = <fun>\n# create (Scope.create ()) [ of_string \"111\"; of_string \"101\" ]\n- : t list =\n[(const (names (foo$0)) (width 3) (value 0b111));\n (const (names (foo$1)) (width 3) (value 0b101))]","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"code":"%hw_list","type":"InlinedCode"},{"text":" is used for lists of signals.  ","type":"SimpleText"},{"code":"%hw_array","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"%hw_iarray","type":"InlinedCode"},{"text":" is similarly for","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"arrays and iarrays respectively.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"%hw_var_list","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"%hw_var_array","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"%hw_var_iarray","type":"InlinedCode"},{"text":" expect the list/array/iarray to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"contain ","type":"SimpleText"},{"code":"Always.Variable.t","type":"InlinedCode"},{"text":"s.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"These forms may also include a module path for use with interfaces and so on.","type":"SimpleText"}]}]}],"lastModifiedTime":1750709442905,"tocItem":{"chapterTitle":"Using Interfaces","pageTitle":"5.8 Naming with ppx_hardcaml","pageMeta":{"parent":["using_interfaces.mdx"],"title":["5.8 Naming with ppx_hardcaml"],"uuid":["15860b19-465d-3f71-fcd7-2b2ef0c48503"]},"dirName":"using-interfaces","fileName":"naming_with_ppx_hardcaml","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Naming with ppx_hardcaml","id":"naming-with-ppx_hardcaml","customAnchorId":"naming-with-ppx_hardcaml"},{"title":"Tuples","id":"tuples","customAnchorId":"tuples"},{"title":"Lists, Arrays, and Iarrays","id":"lists-arrays-and-iarrays","customAnchorId":"lists-arrays-and-iarrays"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"The following is a simple 8-bit counter. It resets back to 0 when the clear signal is high","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"and counts up when the incr signal is high. Otherwise, it holds its previous value.","type":"SimpleText"}]},{"id":"design","additionalIds":[],"level":2,"title":"Design","type":"SubHeading"},{"lang":"ocaml","snippet":"open Hardcaml\nopen Hardcaml.Signal\nopen Hardcaml_waveterm\n\nmodule I = struct\n  type 'a t =\n    { clock : 'a\n    ; clear : 'a\n    ; incr : 'a\n    }\n  [@@deriving hardcaml]\nend\n\nmodule O = struct\n  type 'a t =\n    { dout : 'a[@bits 8]\n    }\n  [@@deriving hardcaml]\nend","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# let create (i : _ I.t) =\n    { O.dout =\n        reg_fb\n          (Reg_spec.create ~clock:i.clock ~clear:i.clear ())\n          ~enable:i.incr\n          ~width:8\n          ~f:(fun d -> d +:. 1)\n    }\nval create : t I.t -> t O.t = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"This design, although simple, shows the usual pattern for defining a circuit in Hardcaml.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"The inputs and outputs of the circuit are specified using interfaces, and the circuit is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"built using a function which takes an input interface and returns an output interface.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The implementation uses the ","type":"SimpleText"},{"code":"reg_fb","type":"InlinedCode"},{"text":" function. This constructs a register with feedback.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Let's look at each argument in turn.","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"Reg_spec.t","type":"InlinedCode"},{"text":" packages up the ","type":"SimpleText"},{"code":"clock","type":"InlinedCode"},{"text":" and synchronous clear ","type":"SimpleText"},{"code":"signal","type":"InlinedCode"},{"text":". There are various","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"other arguments which can control an asynchronous reset, rising or falling clock edge","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"and so on.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"enable","type":"InlinedCode"},{"text":": when high the register will load a new value. Otherwise, it holds its previous","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"value.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"width","type":"InlinedCode"},{"text":" is the bit width of the register.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"f","type":"InlinedCode"},{"text":": this function receives the current value of the register, and computes the next","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"value. In this case, it increments it by one.","type":"SimpleText"}]}]}]},{"id":"testbench","additionalIds":[],"level":2,"title":"Testbench","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The following is a simple testbench for the counter which shows its behavior for","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"different values of ","type":"SimpleText"},{"code":"clear","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"incr","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The purpose of a testbench is to set values for the inputs of a circuit and check what","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"values this causes the outputs to take over time.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Simulator = Cyclesim.With_interface(I)(O)","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# let testbench (create_design_fn : t I.t -> t O.t) =\n    (* Construct the simulation and get its input and output ports. *)\n    let sim = Simulator.create create_design_fn in\n    let inputs : _ I.t = Cyclesim.inputs sim in\n    let outputs : _ O.t = Cyclesim.outputs sim in\n    (* Perform a clock cycle.  Apply the given values to [incr] and [clear].\n       Printf the current values of [dout]. *)\n    let step ~clear ~incr =\n      inputs.clear := if clear=1 then Bits.vdd else Bits.gnd;\n      inputs.incr := if incr=1 then Bits.vdd else Bits.gnd;\n      Stdio.printf \"dout='%s'\\n\" (Bits.to_string !(outputs.dout));\n      Cyclesim.cycle sim\n    in\n    (* Run the counter for 6 clock cycles. *)\n    step ~clear:0 ~incr:0;\n    step ~clear:0 ~incr:1;\n    step ~clear:0 ~incr:1;\n    step ~clear:1 ~incr:0;\n    step ~clear:0 ~incr:0;\n    step ~clear:0 ~incr:0\n  ;;\nval testbench : (t I.t -> t O.t) -> unit = <fun>\n\n# testbench create\ndout='00000000'\ndout='00000000'\ndout='00000001'\ndout='00000010'\ndout='00000000'\ndout='00000000'\n- : unit = ()","lineNumber":"","type":"Snippet"},{"id":"two-other-implementations","additionalIds":[],"level":2,"title":"Two other implementations","type":"SubHeading"},{"id":"two-other-implementations-with-a-wire","additionalIds":["with-a-wire"],"level":3,"title":"With a wire","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The following implementation shows what is actually happening within the ","type":"SimpleText"},{"code":"reg_fb","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"function. First, a wire is created that can be read when we construct a register. It is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"assigned after we have the register output.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Wires allow us to describe cyclic logic structures in Hardcaml. Note that all such cycles","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"in a hardware design ","type":"SimpleText"},{"type":"Emphasis","content":[{"text":"must","type":"SimpleText"}]},{"text":" pass through a sequential element such as a register or","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"memory. Cyclic paths that do not are called combinational loops, and Hardcaml will detect","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"and raise an error if one is found.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let counter_with_wire (i : _ I.t) =\n    let w = wire 8 in\n    let dout =\n      reg\n        (Reg_spec.create ~clock:i.clock ~clear:i.clear ())\n        ~enable:i.incr\n        (w +:. 1)\n    in\n    w <-- dout;\n    { O.dout }\nval counter_with_wire : t I.t -> t O.t = <fun>\n# testbench counter_with_wire\ndout='00000000'\ndout='00000000'\ndout='00000001'\ndout='00000010'\ndout='00000000'\ndout='00000000'\n- : unit = ()","lineNumber":"","type":"Snippet"},{"id":"two-other-implementations-with-the-always-dsl","additionalIds":["with-the-always-dsl"],"level":3,"title":"With the Always DSL","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"We can also describe the counter with the ","type":"SimpleText"},{"url":"/hardcaml-docs/more-on-circuit-design/always","isFile":false,"type":"Link","content":[{"text":"Always DSL","type":"SimpleText"}]},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Note that we could have encoded the clear and increment logic when we constructed the","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Always.Variable.reg","type":"InlinedCode"},{"text":". The Always fragment would then have only consisted of an assignment","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"to ","type":"SimpleText"},{"code":"dout","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let counter_with_always (i : _ I.t) =\n    let dout =\n      Always.Variable.reg\n        (Reg_spec.create ~clock:i.clock ())\n        ~enable:vdd\n        ~width:8\n    in\n    Always.(compile [\n        if_ i.clear\n          [ dout <--. 0;]\n          [ when_ i.incr\n            [ dout <-- dout.value +:. 1 ]\n          ]\n    ]);\n    { O.dout = dout.value}\nval counter_with_always : t I.t -> t O.t = <fun>\n# testbench counter_with_always\ndout='00000000'\ndout='00000000'\ndout='00000001'\ndout='00000010'\ndout='00000000'\ndout='00000000'\n- : unit = ()","lineNumber":"","type":"Snippet"}],"lastModifiedTime":1750709443657,"tocItem":{"chapterTitle":"Examples","pageTitle":"6.1 Counter","pageMeta":{"parent":["examples.mdx"],"title":["6.1 Counter"],"uuid":["7173c9ab-66c0-3eea-32c4-0fb788d7850e"]},"dirName":"examples","fileName":"counter","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"We now show a complete example which implements a bit-serial unsigned multiplier. We will","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"both implement the design and show how to test it.","type":"SimpleText"}]},{"id":"algorithm","additionalIds":[],"title":"Algorithm","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Given two input numbers of bit-widths ","type":"SimpleText"},{"code":"N","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"M","type":"InlinedCode"},{"text":", a bit serial multiplier will produce a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"result of size ","type":"SimpleText"},{"code":"M+N","type":"InlinedCode"},{"text":" every M clock cycles.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Given two input values ","type":"SimpleText"},{"code":"a","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"b","type":"InlinedCode"},{"text":", we consider each bit of ","type":"SimpleText"},{"code":"b","type":"InlinedCode"},{"text":" in turn and form a partial","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"product.","type":"SimpleText"}]},{"lang":"","snippet":"if b[i] then (a << i) else 0","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"This then gets added to a running sum. Let's start with a simple OCaml implementation of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"this algorithm.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# open Base\n# let rec umul a b =\n  if b=0 then 0\n  else\n    let partial_product = if (b land 1) = 1 then a else 0 in\n    partial_product + umul (a lsl 1) (b lsr 1)\nval umul : int -> int -> int = <fun>\n# umul 3 5\n- : int = 15\n# umul 100 99\n- : int = 9900","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Note that we do not explicitly track the iteration number. Rather we detect when to stop","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"by shifting ","type":"SimpleText"},{"code":"b","type":"InlinedCode"},{"text":" down on each iteration and checking if it is ","type":"SimpleText"},{"code":"0","type":"InlinedCode"},{"text":". Similarly, the partial","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"product term ","type":"SimpleText"},{"code":"a << i","type":"InlinedCode"},{"text":" is computed by shifting up by one each iteration. A similar set of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"tricks will be used to define an efficient hardware implementation.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Before we turn fully to the hardware implementation, let's try to port the above code to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the Hardcaml ","type":"SimpleText"},{"code":"Bits","type":"InlinedCode"},{"text":" type.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# open Hardcaml\n# open Hardcaml.Bits\n# let rec umul a b =\n  if to_unsigned_int b = 0 then zero (width a)\n  else\n    let partial_product = mux2 b.:[0,0] a (zero (width a)) in\n    partial_product +: umul (sll a ~by:1) (srl b ~by:1)\nval umul : t -> t -> t = <fun>\n# to_unsigned_int (umul (of_unsigned_int ~width:2 3) (of_unsigned_int ~width:3 5))\n- : int = 3","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The reason this hasn't worked is we are computing the running sum and partial product","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"terms using the bit-width of ","type":"SimpleText"},{"code":"a","type":"InlinedCode"},{"text":". We need to also include the width of ","type":"SimpleText"},{"code":"b","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let umul a b = umul (uresize a ~width:(width a + width b)) b\nval umul : t -> t -> t = <fun>\n# to_unsigned_int (umul (of_unsigned_int ~width:2 3) (of_unsigned_int ~width:3 5))\n- : int = 15\n# to_unsigned_int (umul (of_unsigned_int ~width:7 100) (of_unsigned_int ~width:7 99))\n- : int = 9900","lineNumber":"","type":"Snippet"}]},{"id":"hardware-implementation","additionalIds":[],"title":"Hardware implementation","type":"Section","content":[{"type":"Paragraph","content":[{"text":"We start by implementing functions for the partial product and running sum.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# open Hardcaml.Signal\n# let partial_product a b0 =\n    mux2 b0 a (zero (width a))\nval partial_product : Type.t -> Type.t -> Type.t = <fun>\n# let running_sum first sum a b0 =\n    let sum = mux2 first (zero (width sum)) sum in\n    ue sum +: (ue (partial_product a b0))\nval running_sum : Type.t -> Type.t -> Type.t -> Type.t -> Type.t = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"code":"running_sum","type":"InlinedCode"},{"text":" function takes a new argument called ","type":"SimpleText"},{"code":"first","type":"InlinedCode"},{"text":". This is used to indicate","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"when we are processing bit ","type":"SimpleText"},{"code":"0","type":"InlinedCode"},{"text":" of ","type":"SimpleText"},{"code":"b","type":"InlinedCode"},{"text":" and clears the initial sum to ","type":"SimpleText"},{"code":"0","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The inputs to the addition in ","type":"SimpleText"},{"code":"running_sum","type":"InlinedCode"},{"text":" are of ","type":"SimpleText"},{"code":"width a","type":"InlinedCode"},{"text":" and are zero-extended by the","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"ue","type":"InlinedCode"},{"text":" function to produce a result of ","type":"SimpleText"},{"code":"width a + 1","type":"InlinedCode"},{"text":". Didn't we need more precision than","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"this in the ","type":"SimpleText"},{"code":"Bits","type":"InlinedCode"},{"text":" implementation? We will avoid this by outputting a fully computed bit","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"at each iteration.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let running_sum_reg spec first a b0 =\n    let sum_w = wire (width a) -- \"running_sum\" in\n    let running_sum = running_sum first sum_w a b0  -- \"running_sum_next\" in\n    (* Split the sum into it's least significant bit and the rest. *)\n    let running_sum_bit_out = lsb running_sum in\n    let running_sum = msbs running_sum in\n    (* Register the sum *)\n    let sum = reg spec ~enable:vdd running_sum in\n    sum_w <-- sum;\n    sum, running_sum_bit_out\nval running_sum_reg :\n  Reg_spec.t -> Type.t -> Type.t -> Type.t -> Type.t * Type.t = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We also need to store the computed bits in a register.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let computed_bits spec width bit =\n   reg_fb spec ~width ~f:(fun d -> bit @: msbs d)\nval computed_bits : Reg_spec.t -> int -> Type.t -> Type.t = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The final implementation just needs to put these functions together.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let umul_sequential clock first a b_width b0 =\n    let spec = Reg_spec.create ~clock () in\n    let running_sum, computed_bit = running_sum_reg spec first a b0 in\n    let computed_bits = computed_bits spec b_width computed_bit in\n    running_sum @: computed_bits\nval umul_sequential : Type.t -> Type.t -> Type.t -> int -> Type.t -> Type.t =\n  <fun>","lineNumber":"","type":"Snippet"}]},{"id":"testbench","additionalIds":[],"title":"Testbench","type":"Section","content":[{"type":"Paragraph","content":[{"text":"We will now test our multiplier. First, let's create the required","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Circuit.t","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let create_circuit a_width b_width =\n    let clock = input \"clock\" 1 in\n    let first = input \"first\" 1 in\n    let a = input \"a\" a_width in\n    let b0 = input \"b0\" 1 in\n    let result = umul_sequential clock first a b_width b0 in\n    Circuit.create_exn ~name:\"umul\" [ output \"result\" result ]\nval create_circuit : int -> int -> Circuit.t = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We can now create a simulation and waveform and get a handle on the input and output","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"ports.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# module Waveform = Hardcaml_waveterm.Waveform\nmodule Waveform = Hardcaml_waveterm.Waveform\n# let create_sim circuit =\n    let sim = Cyclesim.create ~config:Cyclesim.Config.trace_all circuit in\n    let waves, sim = Waveform.create sim in\n    let first = Cyclesim.in_port sim \"first\" in\n    let a = Cyclesim.in_port sim \"a\" in\n    let b0 = Cyclesim.in_port sim \"b0\" in\n    let result = Cyclesim.out_port sim \"result\" in\n    waves, sim, first, a, b0, result\nval create_sim :\n  Circuit.t ->\n  Waveform.t * (Cyclesim.Port_list.t, Cyclesim.Port_list.t) Cyclesim.t *\n  Binary.t ref * Binary.t ref * Binary.t ref * Binary.t ref = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The following testbench will take ","type":"SimpleText"},{"code":"a","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"b","type":"InlinedCode"},{"text":" and create a circuit adapted to their bit","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"widths. It will then perform ","type":"SimpleText"},{"code":"width b","type":"InlinedCode"},{"text":" iterations and return the final result.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let test a_in b_in =\n    let open Bits in\n    let waves, sim, first, a, b0, result =\n      create_circuit (width a_in) (width b_in)\n      |> create_sim\n    in\n    let step iteration =\n      first := if iteration=0 then vdd else gnd;\n      b0 := b_in.:[iteration,iteration];\n      Cyclesim.cycle sim;\n    in\n    a := a_in;\n    for i=0 to width b_in - 1 do\n      step i\n    done;\n    (* grab the result and perform 1 more cycle so we can see the result in the waveform *)\n    let result = !result in\n    Cyclesim.cycle sim;\n    waves, result\nval test : Binary.t -> Binary.t -> Waveform.t * Binary.t = <fun>","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Let's test our running examples of multiplying ","type":"SimpleText"},{"code":"3*5","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"100*99","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let waves, result = test (Bits.of_unsigned_int ~width:2 3) (Bits.of_unsigned_int ~width:3 5)\nval waves : Waveform.t = <abstr>\nval result : Binary.t = 01111\n# Stdio.printf \"%i\" (Bits.to_unsigned_int result)\n15\n- : unit = ()\n# Waveform.print waves\n┌Signals────────┐┌Waves──────────────────────────────────────────────┐\n│clock          ││┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌──│\n│               ││    └───┘   └───┘   └───┘   └───┘   └───┘   └───┘  │\n│               ││────────────────────────────────                   │\n│a              ││ 3                                                 │\n│               ││────────────────────────────────                   │\n│b0             ││────────┐       ┌───────────────                   │\n│               ││        └───────┘                                  │\n│first          ││────────┐                                          │\n│               ││        └───────────────────────                   │\n│               ││────────┬───────┬───────┬───────                   │\n│result         ││ 00     │0C     │06     │0F                        │\n│               ││────────┴───────┴───────┴───────                   │\n│gnd            ││                                                   │\n│               ││────────────────────────────────                   │\n│               ││────────┬───────┬───────┬───────                   │\n│running_sum    ││ 0      │1      │0      │1                         │\n│               ││────────┴───────┴───────┴───────                   │\n│               ││────────┬───────┬───────┬───────                   │\n│running_sum_nex││ 3      │1      │3      │4                         │\n│               ││────────┴───────┴───────┴───────                   │\n└───────────────┘└───────────────────────────────────────────────────┘\n- : unit = ()\n# let _, result = test (Bits.of_unsigned_int ~width:7 100) (Bits.of_unsigned_int ~width:7 99)\nval result : Binary.t = 10011010101100\n# Stdio.printf \"%i\" (Bits.to_unsigned_int result)\n9900\n- : unit = ()","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709443679,"tocItem":{"chapterTitle":"Examples","pageTitle":"6.2 Serial Multipler","pageMeta":{"parent":["examples.mdx"],"title":["6.2 Serial Multipler"],"uuid":["6ee57d03-6283-3f55-aa1d-980301b708d7"]},"dirName":"examples","fileName":"serial_multiplier","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Algorithm","id":"algorithm","customAnchorId":"algorithm"},{"title":"Hardware implementation","id":"hardware-implementation","customAnchorId":"hardware-implementation"},{"title":"Testbench","id":"testbench","customAnchorId":"testbench"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"In the following example we design a state machine which computes the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"n-th Fibonacci number.","type":"SimpleText"}]},{"id":"defining-the-circuit-interfaces","additionalIds":[],"level":2,"title":"Defining the circuit interfaces","type":"SubHeading"},{"lang":"ocaml","snippet":"module I = struct\n  type 'a t =\n    { clock : 'a\n    ; clear : 'a\n    ; start : 'a\n    ; n : 'a[@bits 8]\n    }\n  [@@deriving hardcaml]\nend\n\nmodule O = struct\n  type 'a t =\n    { done_ : 'a[@rtlname \"done\"]\n    ; result : 'a[@bits 32]\n    ; state : 'a[@bits 2]\n    }\n  [@@deriving hardcaml]\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Note that we must use the field name ","type":"SimpleText"},{"code":"done_","type":"InlinedCode"},{"text":" in the output interface as it is a reserved","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"word in OCaml, but can use the ppx to give it our preferred name.","type":"SimpleText"}]},{"id":"defining-the-state-type","additionalIds":[],"level":2,"title":"Defining the State type","type":"SubHeading"},{"lang":"ocaml","snippet":"open Base\nopen Hardcaml\nmodule Waveform = Hardcaml_waveterm.Waveform\n\nmodule States = struct\n  type t =\n    | S_wait\n    | S_counting\n    | S_write_result\n  [@@deriving sexp_of, compare, enumerate]\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The circuit will wait for a start signal in ","type":"SimpleText"},{"code":"S_wait","type":"InlinedCode"},{"text":" and capture the input value ","type":"SimpleText"},{"code":"n","type":"InlinedCode"},{"text":" to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"compute the Fibonacci number for. The computation will happen over multiple cycles in","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"state ","type":"SimpleText"},{"code":"S_counting","type":"InlinedCode"},{"text":" and the result will be output in the state ","type":"SimpleText"},{"code":"S_write_result","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"id":"implementing-the-logic","additionalIds":[],"level":2,"title":"Implementing the logic","type":"SubHeading"},{"lang":"ocaml","snippet":"let create (i : _ I.t) =\n  let r_sync = Signal.Reg_spec.create ~clock:i.clock ~clear:i.clear () in\n  let sm = Always.State_machine.create (module States) ~enable:vdd r_sync in\n  let done_ = Always.Variable.wire ~default:gnd () in\n  let result = Always.Variable.wire ~default:(zero 32) () in\n  let f0 = Always.Variable.reg ~width:32 ~enable:Signal.vdd r_sync in\n  let f1 = Always.Variable.reg ~width:32 ~enable:Signal.vdd r_sync in\n  let remaining = Always.Variable.reg ~width:8 ~enable:Signal.vdd r_sync in\n  Always.(\n    compile\n      [ sm.switch\n          [ ( S_wait\n            , [ (* The [a <--. b] is semantically equivalent to\n\n                   [a <-- Signal.of_unsigned_int ~width:(Signal.width a.value) b]\n\n                   Similar syntactic sugar exists for [+:.] and [-:.]. *)\n                f0 <--. 1\n              ; f1 <--. 1\n              ; remaining <-- i.n -:. 1\n              ; when_\n                  i.start\n                  [ if_\n                      (i.n ==:. 0)\n                      [ sm.set_next S_write_result ]\n                      [ sm.set_next S_counting ]\n                  ]\n              ] )\n          ; ( S_counting\n            , [ if_\n                  (remaining.value ==:. 0)\n                  [ sm.set_next S_write_result ]\n                  [ remaining <-- remaining.value -:. 1\n                  ; (* Recall that all hardcaml assignments are synchronous, so the [f1]\n                       assignment below will make use of the old [f0] value. *)\n                    f0 <-- f1.value\n                  ; f1 <-- f0.value +: f1.value\n                  ]\n              ] )\n          ; (* Output the computation result to the user. *)\n            S_write_result, [ done_ <--. 1; result <-- f1.value; sm.set_next S_wait ]\n          ]\n      ]);\n  { O.done_ = done_.value\n  ; result = result.value\n  ; state =\n      (* We output the [state] to help tracing in the simulation example that follows. *)\n      sm.current\n  }\n;;","lineNumber":"","type":"Snippet"},{"id":"testing-the-logic","additionalIds":[],"level":2,"title":"Testing the logic","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Lets now write a testbench which traces the sequence of states and the computed result.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let fibonacci_testbench (sim : (_ I.t, _ O.t) Cyclesim.t) =\n  let inputs, outputs = Cyclesim.inputs sim, Cyclesim.outputs sim in\n  let print_state_and_outputs () =\n    let state = List.nth_exn States.all (Bits.to_unsigned_int !(outputs.state)) in\n    let done_ = Bits.to_bool !(outputs.done_) in\n    let result = Bits.to_unsigned_int !(outputs.result) in\n    Stdio.print_s [%message (state : States.t) (done_ : bool) (result : int)]\n  in\n  (* Start by resetting simulation and clearing the circuit. *)\n  Cyclesim.reset sim;\n  inputs.clear := Bits.vdd;\n  Cyclesim.cycle sim;\n  inputs.clear := Bits.gnd;\n  (* Cycle 0 *)\n  print_state_and_outputs ();\n  (* Cycle 1 *)\n  inputs.start := Bits.vdd;\n  inputs.n := Bits.of_unsigned_int ~width:8 4;\n  Cyclesim.cycle sim;\n  print_state_and_outputs ();\n  inputs.start := Bits.gnd;\n  (* Cycle 2 - Start counting the fibonacci number. *)\n  Cyclesim.cycle sim;\n  print_state_and_outputs ();\n  (* Cycle 3 *)\n  Cyclesim.cycle sim;\n  print_state_and_outputs ();\n  (* Cycle 4 *)\n  Cyclesim.cycle sim;\n  print_state_and_outputs ();\n  (* Cycle 5 - notice that the wire assignment is combinational - the [done] signal is\n     asserted during the same cycle it is assigned in the state machine. *)\n  Cyclesim.cycle sim;\n  print_state_and_outputs ();\n  (* Cycle 6 - this goes back to the initial waiting state. *)\n  Cyclesim.cycle sim;\n  print_state_and_outputs ();\n  Cyclesim.cycle sim\n;;\n\nlet test () =\n  let module Sim = Cyclesim.With_interface (I) (O) in\n  let sim = Sim.create create in\n  let waves, sim = Waveform.create sim in\n  fibonacci_testbench sim;\n  waves\n;;","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"# let waves = test ()\n((state S_wait) (done_ false) (result 0))\n((state S_counting) (done_ false) (result 0))\n((state S_counting) (done_ false) (result 0))\n((state S_counting) (done_ false) (result 0))\n((state S_counting) (done_ false) (result 0))\n((state S_write_result) (done_ true) (result 5))\n((state S_wait) (done_ false) (result 0))\nval waves : Waveform.t = <abstr>","lineNumber":"","type":"Snippet"},{"id":"seeing-the-computation-in-a-waveform","additionalIds":[],"level":2,"title":"Seeing the computation in a waveform","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Lets set up some display rules so the waveform prints nicely.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"A useful pattern when defining ","type":"SimpleText"},{"code":"display_rules","type":"InlinedCode"},{"text":" is to ","type":"SimpleText"},{"code":"map","type":"InlinedCode"},{"text":" over the ","type":"SimpleText"},{"code":"port_names","type":"InlinedCode"},{"text":" and use","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the default ","type":"SimpleText"},{"code":"wave_format","type":"InlinedCode"},{"text":" ","type":"SimpleText"},{"code":"(Bit_or X)","type":"InlinedCode"},{"text":". If the width of the port is 1 it will show as a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"bit, otherwise, it will show as the type ","type":"SimpleText"},{"code":"X","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"For the state value, we use the ","type":"SimpleText"},{"code":"Index","type":"InlinedCode"},{"text":" type which allows us to show the value","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"symbolically.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let display_rules =\n  let open Display_rule in\n  let input_rules =\n    I.(map port_names ~f:(port_name_is ~wave_format:(Bit_or Unsigned_int)) |> to_list)\n  in\n  let output_rules =\n    { O.(map port_names ~f:(port_name_is ~wave_format:(Bit_or Unsigned_int))) with\n      O.state =\n        port_name_is\n          \"state\"\n          ~wave_format:\n            (Index\n               (List.map States.all ~f:(fun t -> States.sexp_of_t t |> Sexp.to_string)))\n    }\n    |> O.to_list\n  in\n  input_rules @ output_rules\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Showing the waveform.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let () =\n    Waveform.print waves\n      ~display_width:94\n      ~display_rules\n  ;;\n┌Signals───────────┐┌Waves───────────────────────────────────────────────────────────────────┐\n│clock             ││┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   │\n│                  ││    └───┘   └───┘   └───┘   └───┘   └───┘   └───┘   └───┘   └───┘   └───│\n│clear             ││        ┌───────┐                                                       │\n│                  ││────────┘       └───────────────────────────────────────────────────────│\n│start             ││                ┌───────┐                                               │\n│                  ││────────────────┘       └───────────────────────────────────────────────│\n│                  ││────────────────┬───────────────────────────────────────────────────────│\n│n                 ││ 0              │4                                                      │\n│                  ││────────────────┴───────────────────────────────────────────────────────│\n│done              ││                                                        ┌───────┐       │\n│                  ││────────────────────────────────────────────────────────┘       └───────│\n│                  ││────────────────────────────────────────────────────────┬───────┬───────│\n│result            ││ 0                                                      │5      │0      │\n│                  ││────────────────────────────────────────────────────────┴───────┴───────│\n│                  ││────────────────────────┬───────────────────────────────┬───────┬───────│\n│state             ││ S_wait                 │S_counting                     │S_writ.│S_wait │\n│                  ││────────────────────────┴───────────────────────────────┴───────┴───────│\n└──────────────────┘└────────────────────────────────────────────────────────────────────────┘","lineNumber":"","type":"Snippet"}],"lastModifiedTime":1750709443960,"tocItem":{"chapterTitle":"Examples","pageTitle":"6.3 Fibonacci Numbers","pageMeta":{"parent":["examples.mdx"],"title":["6.3 Fibonacci Numbers"],"uuid":["445561d5-fcf1-37e8-7643-0c6e0189edca"]},"dirName":"examples","fileName":"fibonacci_numbers","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[]}},{"type":"Page","content":[{"id":"fast-fourier-transform","additionalIds":[],"title":"Fast Fourier Transform","type":"Section","content":[{"type":"Paragraph","content":[{"text":"In this example we will implement a 16-point fast Fourier transform (FFT).","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"We'll not spend much time going through the theory and will focus on translating a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"software reference model to hardware. For more background you can look up wikipedia.","type":"SimpleText"}]}]},{"id":"software-implementation","additionalIds":[],"title":"Software Implementation","type":"Section","content":[{"lang":"ocaml","snippet":"let make_twiddle_factors len =\n  let pi = 3.14159265358979 in\n  let c = ~-.2.0 *. pi /. Float.of_int len in\n  Array.init (len / 2) ~f:(fun i -> Complex.exp { re = 0.; im = c *. Float.of_int i })\n;;\n\nlet fft x =\n  let len = Array.length x in\n  let n_bits = Int.ceil_log2 len in\n  let w = make_twiddle_factors len in\n  let y = Array.init len ~f:(fun i -> x.(bitrev n_bits i)) in\n  for nb = 1 to n_bits do\n    let n = 1 lsl nb in\n    let m = 1 lsl (n_bits - nb) in\n    for h = 0 to m - 1 do\n      let ofs = n * h in\n      for i = 0 to (n / 2) - 1 do\n        let j, k = ofs + i, ofs + i + (n / 2) in\n        let a, b = y.(j), y.(k) in\n        let wm = w.(i * m) in\n        let wb = Complex.mul wm b in\n        y.(j) <- Complex.add a wb;\n        y.(k) <- Complex.sub a wb\n      done\n    done\n  done;\n  y\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"At the heart of the loops we perform a complex multiply and a complex add/subtract which","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"is called a butterfly operation.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"We read 2 values from ","type":"SimpleText"},{"code":"y","type":"InlinedCode"},{"text":" at indices ","type":"SimpleText"},{"code":"j","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"k","type":"InlinedCode"},{"text":". In addition we look up a ","type":"SimpleText"},{"code":"w","type":"InlinedCode"},{"text":" table of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"twiddle factors up at index ","type":"SimpleText"},{"code":"wm","type":"InlinedCode"},{"text":". The butterfly operation is performed and the results are","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"written back to the ","type":"SimpleText"},{"code":"y","type":"InlinedCode"},{"text":" array.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The outer most loop runs ","type":"SimpleText"},{"code":"log(16) = 4","type":"InlinedCode"},{"text":" times. The two innermost loops together will perform","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"16/2=8","type":"InlinedCode"},{"text":" iterations.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"To generate hardware for this we need to consider the following:","type":"SimpleText"}]},{"delimiter":".","startNumber":1,"type":"OrderedList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"State machine to generate the ","type":"SimpleText"},{"code":"j","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"k","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"m","type":"InlinedCode"},{"text":" values and control the iterations.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"A ROM to store the twiddle factor coefficients.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"RAMs to store the input, output and intermediate values during the outer iterations.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Logic to implement the butterfly operation.","type":"SimpleText"}]}]}]}]},{"id":"hardware-implementation","additionalIds":[],"title":"Hardware Implementation","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The follows shows the architecture we are aiming for.","type":"SimpleText"}]},{"lang":"","snippet":"write input       read output\n       ---->[MEM]---->\n              |\n            [FFT]","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We will load FFT coefficients into MEM through the write input. The FFT will read and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"write MEM multiple times to perform the transform. Then we will read the result back","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"through the read output.","type":"SimpleText"}]},{"id":"hardware-implementation-controller-state-machine","additionalIds":["controller-state-machine"],"level":2,"title":"Controller state machine","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Lets look at the values we need to generate. We can do that by modifying the FFT code and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"printing the values we need to generate.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let n_bits = 4\nval n_bits : int = 4\n# Stdio.printf \" j |  k |  m\\n\";\n  for nb = 1 to n_bits do\n    Stdio.printf \"------------\\n\";\n    let n = 1 lsl nb in\n    let m = 1 lsl (n_bits - nb) in\n    for h = 0 to m - 1 do\n      let ofs = n * h in\n      for i = 0 to (n / 2) - 1 do\n        let j, k = ofs + i, ofs + i + (n / 2) in\n        let m = i*m in\n        Stdio.printf \"%2d | %2d | %2d\\n\" j k m\n      done\n    done\n  done\n j |  k |  m\n------------\n 0 |  1 |  0\n 2 |  3 |  0\n 4 |  5 |  0\n 6 |  7 |  0\n 8 |  9 |  0\n10 | 11 |  0\n12 | 13 |  0\n14 | 15 |  0\n------------\n 0 |  2 |  0\n 1 |  3 |  4\n 4 |  6 |  0\n 5 |  7 |  4\n 8 | 10 |  0\n 9 | 11 |  4\n12 | 14 |  0\n13 | 15 |  4\n------------\n 0 |  4 |  0\n 1 |  5 |  2\n 2 |  6 |  4\n 3 |  7 |  6\n 8 | 12 |  0\n 9 | 13 |  2\n10 | 14 |  4\n11 | 15 |  6\n------------\n 0 |  8 |  0\n 1 |  9 |  1\n 2 | 10 |  2\n 3 | 11 |  3\n 4 | 12 |  4\n 5 | 13 |  5\n 6 | 14 |  6\n 7 | 15 |  7\n- : unit = ()","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"As stated before, the outer loop runs 4 times, and the inner two loops combine to run 8","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"iterations.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"We can encode this into a state machine is follows:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module State = struct\n  type t =\n    | Start\n    | Loop\n  [@@deriving sexp_of, compare ~localize, enumerate]\nend\n\nlet loop_controller (i : _ I.t) =\n  let spec = Reg_spec.create ~clock:i.clock ~clear:i.clear () in\n  let pass = Always.Variable.reg spec ~width:(Int.ceil_log2 4) in\n  let count = Always.Variable.reg spec ~width:3 in\n  let sm = Always.State_machine.create (module State) spec in\n  Always.(\n    compile\n      [ sm.switch\n          [ Start, [ pass <--. 0; count <--. 0; when_ i.start [ sm.set_next Loop ] ]\n          ; ( Loop\n            , [ count <-- count.value +:. 1\n              ; when_\n                  (count.value ==:. 7)\n                  [ pass <-- pass.value +:. 1\n                  ; when_ (pass.value ==:. 3) [ sm.set_next Start ]\n                  ]\n              ] )\n          ]\n      ]);\n  pass.value, count.value, sm.is Start\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We now need a way to convert the ","type":"SimpleText"},{"code":"pass","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"count","type":"InlinedCode"},{"text":" values into ","type":"SimpleText"},{"code":"j","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"k","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"m","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Looking the at the addresses we need to generate when ","type":"SimpleText"},{"code":"pass=0","type":"InlinedCode"},{"text":" we just need to add a bit","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"to the bottom of count.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# open Bits\n# Array.init 8 ~f:(fun i ->\n    let count = of_unsigned_int ~width:3 i in\n    let j = count @: gnd in\n    let k = count @: vdd in\n    Bits.to_unsigned_int j, Bits.to_unsigned_int k)\n- : (int * int) array =\n[|(0, 1); (2, 3); (4, 5); (6, 7); (8, 9); (10, 11); (12, 13); (14, 15)|]","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Similarly, when ","type":"SimpleText"},{"code":"pass=1","type":"InlinedCode"},{"text":" we insert a bit between bits 0 and 1 of ","type":"SimpleText"},{"code":"count","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# Array.init 8 ~f:(fun i ->\n    let count = of_unsigned_int ~width:3 i in\n    let j = count.:[2,1] @: gnd @: count.:(0) in\n    let k = count.:[2,1] @: vdd @: count.:(0) in\n    Bits.to_unsigned_int j, Bits.to_unsigned_int k)\n- : (int * int) array =\n[|(0, 2); (1, 3); (4, 6); (5, 7); (8, 10); (9, 11); (12, 14); (13, 15)|]","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"For ","type":"SimpleText"},{"code":"pass=2","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"pass=3","type":"InlinedCode"},{"text":" we do the same thing at the next bit position up.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"For ","type":"SimpleText"},{"code":"m","type":"InlinedCode"},{"text":" we shift ","type":"SimpleText"},{"code":"count","type":"InlinedCode"},{"text":" left by ","type":"SimpleText"},{"code":"3-pass","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"There is one final thing - in the FFT code the first thing we do is reorganize the input","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"array as follows:","type":"SimpleText"}]},{"lang":"","snippet":"let y = Array.init len ~f:(fun i -> x.(bitrev n_bits i)) in","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We can do this by reversing the input address when we load the input FFT coefficients into","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the design.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Here's the final code:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let index_generator ~pass ~count =\n  let jk const =\n    mux\n      pass\n      [ count @: const\n      ; count.:[2, 1] @: const @: count.:[0, 0]\n      ; count.:[2, 2] @: const @: count.:[1, 0]\n      ; const @: count.:[2, 0]\n      ]\n  in\n  let j = jk gnd in\n  let k = jk vdd in\n  let m =\n    mux pass [ sll count ~by:3; sll count ~by:2; sll count ~by:1; sll count ~by:0 ]\n  in\n  j, k, m\n;;","lineNumber":"","type":"Snippet"},{"id":"hardware-implementation-butterfly-operation","additionalIds":["butterfly-operation"],"level":2,"title":"Butterfly operation","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"To compute the butterfly operation we need to decide how we are going to represent complex","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"numbers.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Typically we would consider a fixed point format designed to suit our dynamic range and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"required precision. Instead we are going to cheat and use a feature of Hardcaml that lets","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"us represent full precision floating point numbers within hardware simulations.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Dcomplex = struct\n  type 'a t =\n    { re : 'a [@bits 64]\n    ; im : 'a [@bits 64]\n    }\n  [@@deriving hardcaml]\n\n  open Cyclesim_float_ops.Double\n\n  let add a b = { re = a.re +: b.re; im = a.im +: b.im }\n  let sub a b = { re = a.re -: b.re; im = a.im -: b.im }\n\n  let mul a b =\n    { re = (a.re *: b.re) -: (a.im *: b.im); im = (a.re *: b.im) +: (a.im *: b.re) }\n  ;;\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The ","type":"SimpleText"},{"code":"Cyclcesim_float_ops.Double","type":"InlinedCode"},{"text":" module provides the operators which take and return 64","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"bit signals and implement various floating point operations over them. ","type":"SimpleText"},{"code":"Dcomplex","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"implements complex multiply and add using it.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The butterfly implementation is now as follows:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let butterfly a b w =\n  let wb = Dcomplex.mul w b in\n  Dcomplex.add a wb, Dcomplex.sub a wb\n;;","lineNumber":"","type":"Snippet"},{"id":"hardware-implementation-twiddle-factors","additionalIds":["twiddle-factors"],"level":2,"title":"Twiddle factors","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"This is straight forward - we just create a ROM of ","type":"SimpleText"},{"code":"Dcomplex","type":"InlinedCode"},{"text":" values from the floating","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"point twiddle factors computed for the software version.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let bits_of_float (type a) (module Comb : Comb.S with type t = a) f : a =\n  Int64.bits_of_float f |> Comb.of_int64_trunc ~width:64\n;;\n\nlet float_of_bits b = Bits.to_int64_trunc b |> Int64.float_of_bits\n\nlet twiddle_factor_rom m =\n  let w = make_twiddle_factors 16 in\n  Array.to_list w\n  |> List.map ~f:(fun (w : Complex.t) ->\n    { Dcomplex.re = bits_of_float (module Signal) w.re\n    ; im = bits_of_float (module Signal) w.im\n    })\n  |> Dcomplex.Of_signal.mux m\n;;","lineNumber":"","type":"Snippet"},{"id":"hardware-implementation-memory-buffer","additionalIds":["memory-buffer"],"level":2,"title":"Memory buffer","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"For simplicity, the memory is implemented with 3 read and 3 write ports. The FFT algorithm","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"needs to read and write two complex numbers per cycle so that accounts for two of the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"read/write ports. In addition we use 1 write port to load the FFT coefficients and 1 read","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"port to get the result.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The memory will store 16 complex numbers in total.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"It is also set up with asynchronous read ports - yet another small simplification for","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"this example.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"This is not a terribly realistic memory structure for efficient implementation, but it","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"allows us to complete the design and test it.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let memory_buffer\n  ~clock\n  ~(ext_write : _ Write_port.t)\n  ~(int_write_a : _ Write_port.t)\n  ~(int_write_b : _ Write_port.t)\n  ~int_read_a\n  ~int_read_b\n  ~ext_read\n  =\n  let q =\n    multiport_memory\n      16\n      ~write_ports:\n        [| { write_clock = clock\n           ; write_data = Dcomplex.Of_signal.pack ext_write.data\n           ; write_enable = ext_write.enable\n           ; write_address = reverse ext_write.address\n           }\n         ; { write_clock = clock\n           ; write_data = Dcomplex.Of_signal.pack int_write_a.data\n           ; write_enable = int_write_a.enable\n           ; write_address = int_write_a.address\n           }\n         ; { write_clock = clock\n           ; write_data = Dcomplex.Of_signal.pack int_write_b.data\n           ; write_enable = int_write_b.enable\n           ; write_address = int_write_b.address\n           }\n        |]\n      ~read_addresses:[| ext_read; int_read_a; int_read_b |]\n  in\n  Array.map q ~f:Dcomplex.Of_signal.unpack\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Note that the write address on the first port is reversed as we said would be required.","type":"SimpleText"}]},{"id":"hardware-implementation-sticking-it-all-together","additionalIds":["sticking-it-all-together"],"level":2,"title":"Sticking it all together","type":"SubHeading"},{"lang":"ocaml","snippet":"let create (i : _ I.t) =\n  let scope = Scope.create () in\n  let%hw pass, count, done_ = loop_controller i in\n  let%hw j, k, m = index_generator ~pass ~count in\n  let%hw.Dcomplex.Of_signal w = twiddle_factor_rom m in\n  let%hw.Dcomplex.Of_signal a = Dcomplex.Of_signal.wires () in\n  let%hw.Dcomplex.Of_signal b = Dcomplex.Of_signal.wires () in\n  let%hw.Dcomplex.Of_signal a_next, b_next = butterfly a b w in\n  let memory_buffer =\n    memory_buffer\n      ~clock:i.clock\n      ~ext_write:i.write\n      ~int_write_a:{ enable = ~:done_; address = j; data = a_next }\n      ~int_write_b:{ enable = ~:done_; address = k; data = b_next }\n      ~int_read_a:j\n      ~int_read_b:k\n      ~ext_read:i.read_address\n  in\n  Dcomplex.Of_signal.assign a memory_buffer.(1);\n  Dcomplex.Of_signal.assign b memory_buffer.(2);\n  { O.done_; data_out = memory_buffer.(0) }\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"This instantiates the loop controller, index generator, twiddle factor rom, butterfly and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"memory buffer.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"There is a loop through the butterfly and memory buffer logic which requires us to predefine the","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"a","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"b","type":"InlinedCode"},{"text":" complex values as ","type":"SimpleText"},{"code":"wires","type":"InlinedCode"},{"text":".","type":"SimpleText"}]}]},{"id":"testing-the-design","additionalIds":[],"title":"Testing the Design","type":"Section","content":[{"type":"Paragraph","content":[{"text":"To test the FFT design we will need 4 functions","type":"SimpleText"}]},{"delimiter":".","startNumber":1,"type":"OrderedList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"clear_core","type":"InlinedCode"},{"text":" simple clear (reset) of the registers in the design.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"load_fft_coefficients","type":"InlinedCode"},{"text":" load the input test data.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"run_fft","type":"InlinedCode"},{"text":" start the core and wait for it to complete.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"code":"read_results","type":"InlinedCode"},{"text":" read back the final results from the design.","type":"SimpleText"}]}]}]},{"lang":"ocaml","snippet":"let clear_core (sim : Sim.t) =\n  let inputs = Cyclesim.inputs sim in\n  inputs.clear := vdd;\n  Cyclesim.cycle sim;\n  inputs.clear := gnd\n;;\n\nlet load_fft_coefficients (sim : Sim.t) =\n  let inputs = Cyclesim.inputs sim in\n  inputs.write.enable := Bits.vdd;\n  for i = 0 to 15 do\n    inputs.write.address <--. i;\n    inputs.write.data.re := bits_of_float (module Bits) (Float.of_int (i + 1));\n    inputs.write.data.im := bits_of_float (module Bits) (Float.of_int 0);\n    Cyclesim.cycle sim\n  done;\n  inputs.write.enable := Bits.gnd\n;;\n\nlet run_fft (sim : Sim.t) =\n  let inputs = Cyclesim.inputs sim in\n  let outputs = Cyclesim.outputs sim in\n  inputs.start := Bits.vdd;\n  Cyclesim.cycle sim;\n  inputs.start := Bits.gnd;\n  while not (Bits.to_bool !(outputs.done_)) do\n    Cyclesim.cycle sim\n  done\n;;\n\nlet read_results (sim : Sim.t) =\n  let inputs = Cyclesim.inputs sim in\n  let outputs = Cyclesim.outputs sim in\n  for i = 0 to 15 do\n    inputs.read_address <--. i;\n    Cyclesim.cycle sim;\n    let result =\n      { Complex.re = float_of_bits !(outputs.data_out.re)\n      ; im = float_of_bits !(outputs.data_out.im)\n      }\n    in\n    Stdio.printf \"[%d] %f %+fi\\n\" i result.re result.im\n  done\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Finally, we create our simulator and run a simulation.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Note that we have provided the ","type":"SimpleText"},{"code":"Cyclesim_float_ops.Double.database","type":"InlinedCode"},{"text":" to ","type":"SimpleText"},{"code":"Cyclesim","type":"InlinedCode"},{"text":" so it","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"knows how to implement the floating point operations.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let hw_test () =\n  let sim =\n    Sim.create\n      ~config:\n        { Cyclesim.Config.trace_all with\n          combinational_ops_database = Cyclesim_float_ops.Double.database\n        }\n      create\n  in\n  let waves, sim = Waveform.create sim in\n  clear_core sim;\n  load_fft_coefficients sim;\n  run_fft sim;\n  read_results sim;\n  Waveform.expect waves ~wave_width:2 ~display_rules ~start_cycle:38\n;;","lineNumber":"","type":"Snippet"},{"id":"testing-the-design-waveform","additionalIds":["waveform"],"level":2,"title":"Waveform","type":"SubHeading"},{"lang":"ocaml","snippet":"let%expect_test \"\" =\n  hw_test ();\n  [%expect\n    {|\n    [0] 136.000000 +0.000000i\n    [1] -8.000000 +40.218716i\n    [2] -8.000000 +19.313708i\n    [3] -8.000000 +11.972846i\n    [4] -8.000000 +8.000000i\n    [5] -8.000000 +5.345429i\n    [6] -8.000000 +3.313708i\n    [7] -8.000000 +1.591299i\n    [8] -8.000000 +0.000000i\n    [9] -8.000000 -1.591299i\n    [10] -8.000000 -3.313708i\n    [11] -8.000000 -5.345429i\n    [12] -8.000000 -8.000000i\n    [13] -8.000000 -11.972846i\n    [14] -8.000000 -19.313708i\n    [15] -8.000000 -40.218716i\n    ┌Signals────────┐┌Waves──────────────────────────────────────────────┐\n    │clock          ││┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──│\n    │               ││   └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  │\n    │clear          ││                                                   │\n    │               ││───────────────────────────────────────────────────│\n    │start          ││                                                   │\n    │               ││───────────────────────────────────────────────────│\n    │done_          ││                                                   │\n    │               ││───────────────────────────────────────────────────│\n    │i$enable       ││                                                   │\n    │               ││───────────────────────────────────────────────────│\n    │               ││────────────────────────┬──────────────────────────│\n    │pass           ││ 2                      │3                         │\n    │               ││────────────────────────┴──────────────────────────│\n    │               ││──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──│\n    │count          ││ 4    │5    │6    │7    │0    │1    │2    │3    │4 │\n    │               ││──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──│\n    │               ││──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──│\n    │j              ││ 8    │9    │10   │11   │0    │1    │2    │3    │4 │\n    │               ││──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──│\n    │               ││──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──│\n    │k              ││ 12   │13   │14   │15   │8    │9    │10   │11   │12│\n    │               ││──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──│\n    │               ││──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──│\n    │m              ││ 0    │2    │4    │6    │0    │1    │2    │3    │4 │\n    │               ││──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──│\n    │               ││───────────────────────────────────────────────────│\n    │i$address      ││ 15                                                │\n    │               ││───────────────────────────────────────────────────│\n    │               ││───────────────────────────────────────────────────│\n    │read_address   ││ 0                                                 │\n    │               ││───────────────────────────────────────────────────│\n    │               ││───────────────────────────────────────────────────│\n    │i$re           ││ 16.                                               │\n    │               ││───────────────────────────────────────────────────│\n    │               ││───────────────────────────────────────────────────│\n    │i$im           ││ 0.                                                │\n    │               ││───────────────────────────────────────────────────│\n    │               ││──────────────────────────────┬────────────────────│\n    │o$re           ││ 64.                          │136.                │\n    │               ││──────────────────────────────┴────────────────────│\n    │               ││───────────────────────────────────────────────────│\n    │o$im           ││ 0.                                                │\n    │               ││───────────────────────────────────────────────────│\n    │               ││──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──│\n    │a$re           ││ 32.  │-8.0.│-8.  │-7.9.│64.  │-8.0.│-8.0.│-8.0.│-8│\n    │               ││──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──│\n    │               ││──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──│\n    │a$im           ││ 0.   │8.   │0.   │-8.  │0.   │19.3.│8.   │3.31.│0.│\n    │               ││──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──│\n    │               ││──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──│\n    │b$re           ││ 40.  │-8.0.│-8.  │-7.9.│72.  │-8.0.│-8.0.│-8.0.│-8│\n    │               ││──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──│\n    │               ││──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──│\n    │b$im           ││ 0.   │8.   │0.   │-8.  │0.   │19.3.│8.   │3.31.│0.│\n    │               ││──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──│\n    │               ││──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──│\n    │w$re           ││ 1.   │0.70.│1.61.│-0.7.│1.   │0.92.│0.70.│0.38.│1.│\n    │               ││──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──│\n    │               ││──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──│\n    │w$im           ││ -0.  │-0.7.│-1.  │-0.7.│-0.  │-0.3.│-0.7.│-0.9.│-1│\n    │               ││──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──│\n    │               ││──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──│\n    │a_next$re      ││ 72.  │-8.0.│-8.0.│-8.0.│136. │-8.0.│-8.0.│-8.0.│-8│\n    │               ││──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──│\n    │               ││──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──│\n    │a_next$im      ││ 0.   │19.3.│8.   │3.31.│0.   │40.2.│19.3.│11.9.│8.│\n    │               ││──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──│\n    │               ││──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──│\n    │b_next$re      ││ -8.  │-7.9.│-7.9.│-7.9.│-8.  │-7.9.│-7.9.│-7.9.│-7│\n    │               ││──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──│\n    │               ││──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──│\n    │b_next$im      ││ 0.   │-3.3.│-8.  │-19..│0.   │-1.5.│-3.3.│-5.3.│-8│\n    │               ││──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──│\n    └───────────────┘└───────────────────────────────────────────────────┘\n    7a788a5d3036c98ecb7da5ed09414842\n    |}]\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"An interesting point here is we are displaying floating point values within the waveform.","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"This is done by writing a ","type":"SimpleText"},{"code":"Custom","type":"InlinedCode"},{"text":" display rule for floating point numbers.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let display_rules =\n  let float name =\n    Display_rule.port_name_is\n      name\n      ~wave_format:(Custom (fun b -> float_of_bits b |> Float.to_string))\n  in\n  let complex name = [ float (name ^ \"$re\"); float (name ^ \"$im\") ] in\n  let bit name = Display_rule.port_name_is name ~wave_format:Bit in\n  let uint name = Display_rule.port_name_is name ~wave_format:Unsigned_int in\n  [ [ bit \"clock\"\n    ; bit \"clear\"\n    ; bit \"start\"\n    ; bit \"done_\"\n    ; bit \"i$enable\"\n    ; uint \"pass\"\n    ; uint \"count\"\n    ; uint \"j\"\n    ; uint \"k\"\n    ; uint \"m\"\n    ; uint \"i$address\"\n    ; uint \"read_address\"\n    ]\n  ; complex \"i\"\n  ; complex \"o\"\n  ; complex \"a\"\n  ; complex \"b\"\n  ; complex \"w\"\n  ; complex \"a_next\"\n  ; complex \"b_next\"\n  ]\n  |> List.concat\n;;","lineNumber":"","type":"Snippet"}]},{"id":"improving-the-design","additionalIds":[],"title":"Improving the Design","type":"Section","content":[{"type":"Paragraph","content":[{"text":"To make this design more realistic there are a few things we would need to change.","type":"SimpleText"}]},{"delimiter":".","startNumber":1,"type":"OrderedList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Switching to a fixed point representation of Complex numbers.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Pipelining the butterfly module, and synchronizing the read/write processes within the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"core. At the moment it is entirely combinational.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Making the memory buffer read ports synchronous so they can be implemented efficiently.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Adding ping pong buffers for the input/output stages to reduce the total number of ports required.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Making it work for generic power of 2 transform sizes.","type":"SimpleText"}]}]}]}]}],"lastModifiedTime":1750709444034,"tocItem":{"chapterTitle":"Examples","pageTitle":"6.4 FFT","pageMeta":{"parent":["examples.mdx"],"title":["6.4 FFT"],"uuid":["d4d44c81-9748-325a-2b32-4780a6161d9a"]},"dirName":"examples","fileName":"fft","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Fast Fourier Transform","id":"fast-fourier-transform","customAnchorId":"fast-fourier-transform"},{"title":"Software Implementation","id":"software-implementation","customAnchorId":"software-implementation"},{"title":"Hardware Implementation","id":"hardware-implementation","customAnchorId":"hardware-implementation"},{"title":"Testing the Design","id":"testing-the-design","customAnchorId":"testing-the-design"},{"title":"Improving the Design","id":"improving-the-design","customAnchorId":"improving-the-design"}]}},{"type":"Page","content":[{"id":"binary-search","additionalIds":[],"title":"Binary Search","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Binary search allows us to find an element in a sorted array of length ","type":"SimpleText"},{"code":"N","type":"InlinedCode"},{"text":" in ","type":"SimpleText"},{"code":"log2(N)","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"steps.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"It starts by considering the full range of the array ","type":"SimpleText"},{"code":"0..N-1","type":"InlinedCode"},{"text":" and testing the mid-point at","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"N/2","type":"InlinedCode"},{"text":". If the element is found we are done. Otherwise if the element at the midpoint is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"greater than the element we are looking for we repeat with the range set to ","type":"SimpleText"},{"code":"0..N/2","type":"InlinedCode"},{"text":". If","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"it is less we use the range ","type":"SimpleText"},{"code":"N/2..N","type":"InlinedCode"},{"text":". This continues until the element is found, or the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"range becomes empty.","type":"SimpleText"}]}]},{"id":"designing-the-hardware-interface","additionalIds":[],"title":"Designing the Hardware Interface","type":"Section","content":[{"type":"Paragraph","content":[{"text":"The elements of the array we search must contain a ","type":"SimpleText"},{"code":"key","type":"InlinedCode"},{"text":" value by which it is sorted and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"that the binary search algorithm can use.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"In Ocaml we could represent each element as:","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module type Data = sig \n    type t\n    \n    val key : t -> int\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"In Hardcaml we can take a similar approach.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module type Data = sig\n  include Interface.S\n\n  val key : Signal.t t -> Signal.t\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The hardware design also needs to know the size of the array we are searching and the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"number of bits in the key. Thus we define the following ","type":"SimpleText"},{"code":"Config","type":"InlinedCode"},{"text":" type.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module type Config = sig\n  module Data : Data\n\n  val log_size : int\n  val key_size : int\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The hardware design will be fully parameterized by ","type":"SimpleText"},{"code":"Config","type":"InlinedCode"},{"text":" by implementing it within a functor.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Make(Config : Config) = struct\n (* ... hardware implemented here ... *)\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The interface to the design is specified as follows","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Data_with_valid = With_valid.Wrap.Make (Config.Data)\n\nmodule I = struct\n  type 'a t =\n    { clocking : 'a Clocking.t (* Clock and clear. *)\n    ; start : 'a (* Pulsed to start search. *)\n    ; d : 'a Config.Data.t (* Data read at `address`. *)\n    ; find_key : 'a [@bits Config.key_size] (* Key we are looking for. *)\n    }\n  [@@deriving hardcaml]\nend\n\nmodule O = struct\n  type 'a t =\n    { done_ : 'a (* Low while searching. *)\n    ; index : 'a [@bits Config.log_size] (* Index where key was found. *)\n    ; q : 'a Data_with_valid.t (* Data where key was found. *)\n    ; address : 'a [@bits Config.log_size] (* Address into search array. *)\n    }\n  [@@deriving hardcaml]\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The interface consists of the following logical parts.","type":"SimpleText"}]},{"id":"designing-the-hardware-interface-clocking","additionalIds":["clocking"],"level":3,"title":"Clocking","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"Clocking","type":"InlinedCode"},{"text":" is an interface which groups together the ","type":"SimpleText"},{"code":"clock","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"clear","type":"InlinedCode"},{"text":" signals.","type":"SimpleText"}]},{"id":"designing-the-hardware-interface-control","additionalIds":["control"],"level":3,"title":"Control","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"start","type":"InlinedCode"},{"text":" is used to begin the search and ","type":"SimpleText"},{"code":"done_","type":"InlinedCode"},{"text":" indicates when a search is in progress.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"find_key","type":"InlinedCode"},{"text":" is the key we are searching for and must be provided coincident with ","type":"SimpleText"},{"code":"start","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"and be held during the search operation.","type":"SimpleText"}]},{"id":"designing-the-hardware-interface-array-access","additionalIds":["array-access"],"level":3,"title":"Array access","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"address","type":"InlinedCode"},{"text":" is the current index we are searching the array at and ","type":"SimpleText"},{"code":"d","type":"InlinedCode"},{"text":" is the data at that","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"address.","type":"SimpleText"}]},{"id":"designing-the-hardware-interface-output-result","additionalIds":["output-result"],"level":3,"title":"Output result","type":"SubHeading"},{"type":"Paragraph","content":[{"code":"index","type":"InlinedCode"},{"text":" is the address at which the element was found.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"q","type":"InlinedCode"},{"text":" is the data we found.  The type of ","type":"SimpleText"},{"code":"q","type":"InlinedCode"},{"text":" is ","type":"SimpleText"},{"code":"Data_with_valid","type":"InlinedCode"},{"text":" which was defined as:","type":"SimpleText"}]},{"lang":"","snippet":"module Data_with_valid = With_valid.Wrap.Make (Config.Data)","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"code":"With_valid","type":"InlinedCode"},{"text":" is common pattern in Hardcaml code. It wraps a signal or, as in this case, an","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Interface","type":"InlinedCode"},{"text":" with an additional ","type":"SimpleText"},{"code":"valid","type":"InlinedCode"},{"text":" bit. If ","type":"SimpleText"},{"code":"valid","type":"InlinedCode"},{"text":" is high the search succeeded and if","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"it is low the search failed (the element we were looking for did not exist in the input","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"array).","type":"SimpleText"}]}]},{"id":"implementing-the-search","additionalIds":[],"title":"Implementing the Search","type":"Section","content":[{"lang":"ocaml","snippet":"module State = struct\n  type t =\n    | Start\n    | Loop\n  [@@deriving sexp_of, compare ~localize, enumerate]\nend\n\nlet create scope (i : _ I.t) =\n  let%hw.Always.State_machine sm =\n    Always.State_machine.create (module State) (Clocking.to_spec i.clocking)\n  in\n  (* search range *)\n  let%hw_var low = Clocking.Var.reg i.clocking ~width:(Config.log_size + 1) in\n  let%hw_var mid = Clocking.Var.reg i.clocking ~width:(Config.log_size + 1) in\n  let%hw_var high = Clocking.Var.reg i.clocking ~width:(Config.log_size + 1) in\n  (* results *)\n  let index = Clocking.Var.reg i.clocking ~width:Config.log_size in\n  let q = Data_with_valid.Of_always.reg (Clocking.to_spec i.clocking) in\n  let%hw key = Config.Data.key i.d in\n  Always.(\n    compile\n      [ sm.switch\n          [ ( Start\n            , [ low <--. 0\n              ; mid <--. Int.pow 2 Config.log_size / 2\n              ; high <--. Int.pow 2 Config.log_size\n              ; when_ i.start [ q.valid <-- gnd; sm.set_next Loop ]\n              ] )\n          ; ( Loop\n            , [ (* success *)\n                if_\n                  (i.find_key ==: key)\n                  [ q.valid <-- vdd\n                  ; index <-- lsbs mid.value\n                  ; Config.Data.Of_always.assign q.value i.d\n                  ; sm.set_next Start\n                  ]\n                (* failure *)\n                @@ elif (mid.value ==: low.value) [ q.valid <-- gnd; sm.set_next Start ]\n                (* search left half *)\n                @@ elif\n                     (i.find_key <: key)\n                     [ high <-- mid.value\n                     ; mid <-- low.value +: srl (mid.value -: low.value) ~by:1\n                     ]\n                @@ (* search right half *)\n                [ low <-- mid.value\n                ; mid <-- mid.value +: srl (high.value -: mid.value) ~by:1\n                ]\n              ] )\n          ]\n      ]);\n  { O.done_ = sm.is Start\n  ; index = index.value\n  ; q = Data_with_valid.Of_always.value q\n  ; address = lsbs mid.value\n  }\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"When start is applied we set the initial range and the state machine transitions to the","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Loop","type":"InlinedCode"},{"text":" state. The ","type":"SimpleText"},{"code":"mid","type":"InlinedCode"},{"text":" point is output as ","type":"SimpleText"},{"code":"address","type":"InlinedCode"},{"text":" and the current element is checked:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"if we found the key the search succeeds. ","type":"SimpleText"},{"code":"q.valid","type":"InlinedCode"},{"text":" is set high and the index and data","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"are output.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"otherwise, if the mid point equals the low point, the search range is 0 and the search","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"fails. ","type":"SimpleText"},{"code":"q.valid","type":"InlinedCode"},{"text":" is set low.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"otherwise, if the search key is less than the current key, search the left half.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"otherwise, (if the search key is greater then the current key) search the right half.","type":"SimpleText"}]}]}]}]},{"id":"testing","additionalIds":[],"title":"Testing","type":"Section","content":[{"id":"testing-adding-the-search-array","additionalIds":["adding-the-search-array"],"level":2,"title":"Adding the search array","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"To make the testbench simpler to implement we are going to create a top level architecture","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"which include the search array memory.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The interface to this design has a write port for loading the search data along with the","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"start","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"find_key","type":"InlinedCode"},{"text":" values. The output is the same as before except we don't output","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"address","type":"InlinedCode"},{"text":" and wire this directly into the memory.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The implementation just instantiates the search array memory and binary search module.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Make_with_memory (Config : Config) = struct\n  module Binary_search = Make (Config)\n\n  module I = struct\n    type 'a t =\n      { clocking : 'a Clocking.t\n      ; write_enable : 'a\n      ; write_data : 'a Config.Data.t\n      ; write_address : 'a [@bits Config.log_size]\n      ; start : 'a\n      ; find_key : 'a [@bits Config.key_size]\n      }\n    [@@deriving hardcaml]\n  end\n\n  module O = struct\n    type 'a t =\n      { done_ : 'a\n      ; index : 'a [@bits Config.log_size]\n      ; q : 'a Binary_search.Data_with_valid.t\n      }\n    [@@deriving hardcaml]\n  end\n\n  let create scope (i : _ I.t) =\n    let read_address = wire Config.log_size in\n    let q =\n      multiport_memory\n        (Int.pow 2 Config.log_size)\n        ~write_ports:\n          [| { write_clock = i.clocking.clock\n             ; write_address = i.write_address\n             ; write_enable = i.write_enable\n             ; write_data = Config.Data.Of_signal.pack i.write_data\n             }\n          |]\n        ~read_addresses:[| read_address |]\n    in\n    let binary_search =\n      Binary_search.create\n        scope\n        { Binary_search.I.clocking = i.clocking\n        ; start = i.start\n        ; d = Config.Data.Of_signal.unpack q.(0)\n        ; find_key = i.find_key\n        }\n    in\n    read_address <-- binary_search.address;\n    { O.done_ = binary_search.done_; index = binary_search.index; q = binary_search.q }\n  ;;\nend","lineNumber":"","type":"Snippet"},{"id":"testing-writing-the-testbench","additionalIds":["writing-the-testbench"],"level":2,"title":"Writing the testbench","type":"SubHeading"},{"id":"testing-writing-the-testbench-configuring-the-testbench","additionalIds":["configuring-the-testbench"],"level":3,"title":"Configuring the testbench","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Define the ","type":"SimpleText"},{"code":"Data","type":"InlinedCode"},{"text":" interface we will search over and the size of the array to search.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Data = struct\n  let key_size = 6\n\n  type 'a t =\n    { key : 'a [@bits key_size]\n    ; data : 'a [@bits 32]\n    }\n  [@@deriving hardcaml]\n\n  let key t = t.key\nend\n\nmodule Config = struct\n  module Data = Data\n\n  let key_size = Data.key_size\n  let log_size = 4\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The array size will be 16 elements. The key is 6 bits so ranges from 0 to 63.","type":"SimpleText"}]},{"id":"testing-writing-the-testbench-test-functions","additionalIds":["test-functions"],"level":3,"title":"Test functions","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The testbench is implemented by the following functions.","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"clear_core - clear (reset) the registers.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"load_inputs - load the array to search.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"run_core - start the search, wait for it to complete then return the results.","type":"SimpleText"}]}]}]},{"lang":"ocaml","snippet":"let clear_core (sim : Sim.t) =\n  let inputs = Cyclesim.inputs sim in\n  inputs.clocking.clear <--. 1;\n  Cyclesim.cycle sim;\n  inputs.clocking.clear <--. 0\n;;\n\nlet load_inputs (sim : Sim.t) (input_data : int Data.t array) =\n  let inputs = Cyclesim.inputs sim in\n  inputs.write_enable <--. 1;\n  for i = 0 to Int.pow 2 Config.log_size - 1 do\n    inputs.write_address <--. i;\n    inputs.write_data.key <--. input_data.(i).key;\n    inputs.write_data.data <--. input_data.(i).data;\n    Cyclesim.cycle sim\n  done\n;;\n\nlet run_core (sim : Sim.t) find_key =\n  let inputs = Cyclesim.inputs sim in\n  let outputs = Cyclesim.outputs sim in\n  (* Start the search. *)\n  inputs.start <--. 1;\n  Cyclesim.cycle sim;\n  inputs.start <--. 0;\n  inputs.find_key <--. find_key;\n  (* Wait for it to finish.  Don't let it take more than 20 cycles. *)\n  let timeout = ref 0 in\n  while (not (Bits.to_bool !(outputs.done_))) && !timeout < 20 do\n    Cyclesim.cycle sim;\n    Int.incr timeout\n  done;\n  Cyclesim.cycle sim;\n  (* Collect and return results. *)\n  let found = Bits.to_bool !(outputs.q.valid) in\n  if found\n  then (\n    let index = Bits.to_unsigned_int !(outputs.index) in\n    let data = Bits.to_unsigned_int !(outputs.q.value.data) in\n    let key = Bits.to_unsigned_int !(outputs.q.value.key) in\n    (* Sanity check - make sure the key we found was actually the key we were searching\n       for. *)\n    if key <> find_key\n    then\n      raise_s\n        [%message\n          \"Found wrong key\" (find_key : int) (key : int) (index : int) (data : int)];\n    Some (index, data))\n  else None\n;;","lineNumber":"","type":"Snippet"},{"id":"testing-writing-the-testbench-testbench","additionalIds":["testbench"],"level":3,"title":"Testbench","type":"SubHeading"},{"lang":"ocaml","snippet":"let validate ~(input_data : int Data.t array) ~find_key ~result =\n  let key_is_in_input_data =\n    match Array.find input_data ~f:(fun { key; _ } -> key = find_key) with\n    | None -> false\n    | _ -> true\n  in\n  let raise_search_failed () =\n    raise_s\n      [%message\n        \"Search failed\"\n          (find_key : int)\n          (key_is_in_input_data : bool)\n          (result : (int * int) option)\n          (input_data : int Config.Data.t array)]\n  in\n  match result, key_is_in_input_data with\n  | None, true ->\n    (* The hardware didn't find the element but it was there. *)\n    raise_search_failed ()\n  | Some _, false ->\n    (* The hardware found an element but it wasn't there. *)\n    raise_search_failed ()\n  | None, false ->\n    (* Nothing to find. *)\n    ()\n  | Some (index, data), true ->\n    (* We found the element - check the key and data are as expected. *)\n    if input_data.(index).key <> find_key || input_data.(index).data <> data\n    then raise_search_failed ()\n;;\n\nlet test ~waves ~input_data ~find_key =\n  let open Hardcaml_waveterm in\n  (* Create the simulator. *)\n  let scope = Scope.create ~auto_label_hierarchical_ports:true ~flatten_design:true () in\n  let sim = Sim.create ~config:Cyclesim.Config.trace_all (Binary_search.create scope) in\n  let waves, sim =\n    (* Optionally trace a waveform. *)\n    if waves\n    then (\n      let waves, sim = Waveform.create sim in\n      Some waves, sim)\n    else None, sim\n  in\n  (* Run the testbench. *)\n  clear_core sim;\n  load_inputs sim input_data;\n  let result = run_core sim find_key in\n  (* Optionally show the waveform. *)\n  Option.iter\n    waves\n    ~f:(Waveform.expect_exact ~wave_width:3 ~start_cycle:16 ~display_rules);\n  (* Check the results are valid. *)\n  validate ~input_data ~find_key ~result\n;;","lineNumber":"","type":"Snippet"},{"id":"testing-writing-the-testbench-randomized-testing","additionalIds":["randomized-testing"],"level":3,"title":"Randomized testing","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"We can now perform some randomized testing. We create an array of random ","type":"SimpleText"},{"code":"Data","type":"InlinedCode"},{"text":" elements","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"and sort it. We then search for some random keys in the array. If it doesn't raise all is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"well.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let%expect_test \"random tests\" =\n  for _ = 1 to 10 do\n    let input_data =\n      Array.init (Int.pow 2 Config.log_size) ~f:(fun _ ->\n        { Config.Data.key = random_key (); data = random_data () })\n    in\n    Array.sort input_data ~compare:(fun { key; _ } { key = key1; _ } ->\n      Int.compare key key1);\n    for _ = 1 to 20 do\n      let find_key = random_key () in\n      test ~waves:false ~input_data ~find_key\n    done\n  done;\n  [%expect {| |}]\n;;","lineNumber":"","type":"Snippet"},{"id":"testing-writing-the-testbench-waveform","additionalIds":["waveform"],"level":3,"title":"Waveform","type":"SubHeading"},{"lang":"ocaml","snippet":"let%expect_test \"debug waveform\" =\n  let input_data =\n    Array.init (Int.pow 2 Config.log_size) ~f:(fun i -> { Config.Data.key = i; data = i })\n  in\n  let find_key = 3 in\n  test ~waves:true ~input_data ~find_key;\n  [%expect_exact\n    {|\n┌Signals───────────┐┌Waves───────────────────────────────────────────────────────────────┐\n│clocking$clock    ││┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───│\n│                  ││    └───┘   └───┘   └───┘   └───┘   └───┘   └───┘   └───┘   └───┘   │\n│clocking$clear    ││                                                                    │\n│                  ││────────────────────────────────────────────────────────            │\n│write_enable      ││────────────────────────────────────────────────────────            │\n│                  ││                                                                    │\n│                  ││────────────────────────────────────────────────────────            │\n│write_data$key    ││ 15                                                                 │\n│                  ││────────────────────────────────────────────────────────            │\n│                  ││────────────────────────────────────────────────────────            │\n│write_data$data   ││ 15                                                                 │\n│                  ││────────────────────────────────────────────────────────            │\n│                  ││────────────────────────────────────────────────────────            │\n│write_address     ││ 15                                                                 │\n│                  ││────────────────────────────────────────────────────────            │\n│start             ││        ┌───────┐                                                   │\n│                  ││────────┘       └───────────────────────────────────────            │\n│                  ││────────────────┬───────────────────────────────────────            │\n│find_key          ││ 0              │3                                                  │\n│                  ││────────────────┴───────────────────────────────────────            │\n│done_             ││────────────────┐                               ┌───────            │\n│                  ││                └───────────────────────────────┘                   │\n│                  ││────────────────────────────────────────────────┬───────            │\n│index             ││ 0                                              │3                  │\n│                  ││────────────────────────────────────────────────┴───────            │\n│q$valid           ││                                                ┌───────            │\n│                  ││────────────────────────────────────────────────┘                   │\n│                  ││────────────────────────────────────────────────┬───────            │\n│q$value$key       ││ 0                                              │3                  │\n│                  ││────────────────────────────────────────────────┴───────            │\n│                  ││────────────────────────────────────────────────┬───────            │\n│q$value$data      ││ 0                                              │3                  │\n│                  ││────────────────────────────────────────────────┴───────            │\n│                  ││────────────────────────────────────────┬───────────────            │\n│low               ││ 0                                      │2                          │\n│                  ││────────────────────────────────────────┴───────────────            │\n│                  ││────────────────────────┬───────┬───────┬───────────────            │\n│mid               ││ 8                      │4      │2      │3                          │\n│                  ││────────────────────────┴───────┴───────┴───────────────            │\n│                  ││────────────────────────┬───────┬───────────────────────            │\n│high              ││ 16                     │8      │4                                  │\n│                  ││────────────────────────┴───────┴───────────────────────            │\n│                  ││────────────────┬───────────────────────────────┬───────            │\n│sm                ││ Start          │Loop                           │Start              │\n│                  ││────────────────┴───────────────────────────────┴───────            │\n└──────────────────┘└────────────────────────────────────────────────────────────────────┘\nc55f6d1c162be347d7d0654ae22a7310\n|}]\n;;","lineNumber":"","type":"Snippet"}]}],"lastModifiedTime":1750709443062,"tocItem":{"chapterTitle":"Examples","pageTitle":"6.5 Binary Search","pageMeta":{"parent":["examples.mdx"],"title":["6.5 Binary Search"],"uuid":["fd00fcfb-2558-3b73-f13a-4bc939eca093"]},"dirName":"examples","fileName":"binary_search","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Binary Search","id":"binary-search","customAnchorId":"binary-search"},{"title":"Designing the Hardware Interface","id":"designing-the-hardware-interface","customAnchorId":"designing-the-hardware-interface"},{"title":"Implementing the Search","id":"implementing-the-search","customAnchorId":"implementing-the-search"},{"title":"Testing","id":"testing","customAnchorId":"testing"}]}},{"type":"Page","content":[{"id":"quicksort","additionalIds":[],"title":"Quicksort","type":"Section","content":[{"type":"Paragraph","content":[{"text":"Quicksort is a sorting algorithm that takes ","type":"SimpleText"},{"code":"O(N log N)","type":"InlinedCode"},{"text":" operations in the average case","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"and ","type":"SimpleText"},{"code":"O(N^2)","type":"InlinedCode"},{"text":" in the worst case. It is a divide and conquer algorithm that recursively sorts","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the input in two halves. It works as follows:","type":"SimpleText"}]},{"delimiter":".","startNumber":1,"type":"OrderedList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Pick some element from the array.  Call this the pivot.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Partition the array such into three parts.","type":"SimpleText"}]}]}]},{"lang":"","snippet":"[ <= pivot][pivot][ >= pivot]","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"All values less than or equal to the pivot are placed before the pivot and all elements","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"greater than the pivot are placed after it. Given this we can be sure pivot is now","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"actually in the correct position in the array.","type":"SimpleText"}]},{"delimiter":".","startNumber":3,"type":"OrderedList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Recursively apply quicksort to the left and right partitions.","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"Quicksort describes a family of algorithms with some different trade offs - in particular","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the actual partitioning algorithm and how to choose the pivot can affect its performance on","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"different input arrays.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Lets start with the most basic implementation.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let rec qsort a =\n  match a with\n  | [] -> []\n  | x :: xs ->\n    let left = List.filter xs ~f:(fun y -> y <= x) in\n    let right = List.filter xs ~f:(fun y -> y > x) in\n    List.concat [ qsort left; [ x ]; qsort right ]\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"It is a very elegant implementation and indeed runs with the expected average and worst","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"case complexities. However, it also allocates lots of intermediate lists and the amount of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"space needed will be proportional to the runtime i.e. in worst case it could require ","type":"SimpleText"},{"code":"O(N^2)","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"space.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"We want to implement this on in hardware so we'd like to get a better bound on the space","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"requirements.","type":"SimpleText"}]},{"id":"quicksort-in-place-sorting","additionalIds":["in-place-sorting"],"level":2,"title":"In place sorting","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Lomuto described a partitioning scheme that is both simple and can run in place i.e. it","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"modifies the input array rather than allocating new arrays.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let swap a i j =\n  let tmp = a.(i) in\n  a.(i) <- a.(j);\n  a.(j) <- tmp\n;;\n\nlet partition a ~low ~high =\n  let pivot = a.(high) in\n  let i = ref low in\n  for j = low to high - 1 do\n    if a.(j) < pivot\n    then (\n      swap a !i j;\n      Int.incr i)\n  done;\n  swap a !i high;\n  !i\n;;\n\nlet rec qsort a ~low ~high =\n  if not (low >= high || low < 0)\n  then (\n    let p = partition a ~high ~low in\n    qsort a ~low ~high:(p - 1);\n    qsort a ~low:(p + 1) ~high)\n;;\n\nlet qsort a = qsort a ~low:0 ~high:(Array.length a - 1)","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"So we've fixed the space problem ... except we haven't quite. Although we no longer","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"allocate new data arrays, we still use stack space for the recursive calls. The stack","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"usage will follow the average and worst case complexity of the algorithm depending on the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"input data ie it could be up to ","type":"SimpleText"},{"code":"O(N)","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Why does this happen? It's because of the choice of pivot. For best performance the pivot","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"should evenly split the input array but we cannot guarantee that. If the input was already","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"sorted we hit a degenerate case where the left partition is all the elements except the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"pivot and the right partition is empty. Thus we need to recurse ","type":"SimpleText"},{"code":"N","type":"InlinedCode"},{"text":" times to quicksort","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"it.","type":"SimpleText"}]},{"id":"quicksort-sedgewicks-log-stack-space-trick","additionalIds":["sedgewicks-log-stack-space-trick"],"level":2,"title":"Sedgewick's log stack space trick","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Now we come to the implementation we want to use for hardware. This reorganizes the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"recursion so it only uses stack space on the smaller partition. It doesn't change the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"amount of computation we do - it will still be ","type":"SimpleText"},{"code":"O(N^2)","type":"InlinedCode"},{"text":" - but we can ensure we use only","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"log N","type":"InlinedCode"},{"text":" stack space.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let rec qsort a ~low ~high =\n  let low, high = ref low, ref high in\n  while !low < !high do\n    let pivot = partition a ~low:!low ~high:!high in\n    if pivot - !low < !high - pivot\n    then (\n      qsort a ~low:!low ~high:(pivot - 1);\n      low := pivot + 1)\n    else (\n      qsort a ~low:(pivot + 1) ~high:!high;\n      high := pivot - 1)\n  done\n;;\n\nlet qsort a = qsort a ~low:0 ~high:(Array.length a - 1)","lineNumber":"","type":"Snippet"}]},{"id":"hardware-design","additionalIds":[],"title":"Hardware Design","type":"Section","content":[{"id":"hardware-design-top-level-architecture","additionalIds":["top-level-architecture"],"level":2,"title":"Top level architecture","type":"SubHeading"},{"lang":"","snippet":"      |\\   _______   |\\\n______||__|       |__||_____\n     _||  |  RAM  |  ||_\n    | |/  |_______|  |/ |\n    |      _______      |\n    |     |       |     |\n    |_____| QSORT |_____|\n          |       |\n          |_______|","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The top level design consists of a RAM and the sorting core.  The RAM is implementation","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"with a Simple Dual Port RAM.  This means it has one read and one write port.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The sorting core requires read/write access to the RAM as does the external interface in","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"order to load the data and read back the result. Thus the ports are multiplexed. This","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"basically means the RAM should not be accessed by the external interface while the core is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"running.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module type Config = sig\n  val log_size : int\n  val data_size : int\nend","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"module Make_with_memory (Config : Config) = struct\n  open Config\n  module Qsort = Make (Config)\n\n  module I = struct\n    type 'a t =\n      { clocking : 'a Types.Clocking.t\n      ; start : 'a\n      ; write_enable : 'a\n      ; write_address : 'a [@bits log_size]\n      ; write_data : 'a [@bits data_size]\n      ; read_address : 'a [@bits log_size]\n      ; read_enable : 'a\n      }\n    [@@deriving hardcaml ~rtlmangle:false]\n  end\n\n  module O = struct\n    type 'a t =\n      { done_ : 'a\n      ; data_out : 'a [@bits data_size]\n      }\n    [@@deriving hardcaml ~rtlmangle:false]\n  end\n\n  let create scope (i : _ I.t) =\n    let%hw.Qsort.O.Of_signal qsort = Qsort.O.Of_signal.wires () in\n    let%hw ram =\n      (Ram.create\n         ~name:\"my_ram\"\n         ~collision_mode:Read_before_write\n         ~size:(Int.pow 2 log_size)\n         ~write_ports:\n           [| { write_clock = i.clocking.clock\n              ; write_enable = i.write_enable |: qsort.write_enable\n              ; write_address = mux2 i.write_enable i.write_address qsort.write_address\n              ; write_data = mux2 i.write_enable i.write_data qsort.write_data\n              }\n           |]\n         ~read_ports:\n           [| { read_clock = i.clocking.clock\n              ; read_enable = i.read_enable |: qsort.read_enable\n              ; read_address = mux2 i.read_enable i.read_address qsort.read_address\n              }\n           |]\n         ()).(0)\n    in\n    Qsort.O.Of_signal.assign\n      qsort\n      (Qsort.create\n         scope\n         { Qsort.I.clocking = i.clocking; start = i.start; read_data = ram });\n    { O.done_ = qsort.done_; data_out = ram }\n  ;;\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We show a little trick for designs like this where the outputs of both modules are also","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"required as inputs to the modules. You can predefine the outputs of one model as wires and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"then use them in the other module. We can then assign the wires when we create the second","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"module. This trick extends to as many modules as needed.","type":"SimpleText"}]}]},{"id":"quicksort-design","additionalIds":[],"title":"Quicksort Design","type":"Section","content":[{"type":"Paragraph","content":[{"text":"There are three main things the core must implement:","type":"SimpleText"}]},{"delimiter":".","startNumber":1,"type":"OrderedList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"The partitioning process.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Control of recursion and iterations.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Management of the stack.","type":"SimpleText"}]}]}]},{"type":"Paragraph","content":[{"text":"In addition there is a complexity with regard to the RAM. Because we are instantiating a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"proper synthesizable RAM the read is synchronous - this means we get the read data one","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"cycle after providing the read address. We will need to account for this latency in our","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"state machine.","type":"SimpleText"}]},{"id":"quicksort-design-call-stack","additionalIds":["call-stack"],"level":2,"title":"Call stack","type":"SubHeading"},{"lang":"ocaml","snippet":"module Partition = struct\n  type 'a t =\n    { low : 'a [@bits log_size]\n    ; high : 'a [@bits log_size]\n    ; pivot : 'a [@bits log_size]\n    }\n  [@@deriving hardcaml ~rtlmangle:false]\nend\n\nmodule Partition_with_valids = With_valid.Fields.Make (Partition)","lineNumber":"","type":"Snippet"},{"lang":"ocaml","snippet":"module Call_stack = struct\n  module I = struct\n    type 'a t =\n      { clocking : 'a Clocking.t\n      ; partition : 'a Partition_with_valids.t\n      ; push : 'a\n      ; pop : 'a\n      }\n    [@@deriving hardcaml ~rtlmangle:false]\n  end\n\n  module O = struct\n    type 'a t =\n      { partition : 'a Partition.t\n      ; is_empty : 'a\n      }\n    [@@deriving hardcaml ~rtlmangle:false]\n  end\n\n  let create scope (i : _ I.t) : _ O.t =\n    let addr_bits = Int.ceil_log2 (log_size + 1) in\n    let%hw top = wire addr_bits in\n    let top_next = top +:. 1 in\n    let top_prev = top -:. 1 in\n    top\n    <-- Clocking.reg\n          i.clocking\n          ~enable:(i.push |: i.pop)\n          (mux2 i.push top_next top_prev);\n    let create_stack { With_valid.valid; value } =\n      (multiport_memory\n         (log_size + 1)\n         ~write_ports:\n           [| { write_clock = i.clocking.clock\n              ; write_enable = i.push |: valid\n              ; write_address = mux2 i.push top_next top\n              ; write_data = value\n              }\n           |]\n         ~read_addresses:[| top |]).(0)\n    in\n    { O.partition = Partition.map i.partition ~f:create_stack; is_empty = top ==:. 0 }\n  ;;\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"The hardware outputs the current top most entry of the stack via ","type":"SimpleText"},{"code":"O.partition","type":"InlinedCode"},{"text":". This is of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"type ","type":"SimpleText"},{"code":"_ Partition.t","type":"InlinedCode"},{"text":" and contains the low and high indices of the current range along with","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the pivot index.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"We allow writes to the stack in two different ways. ","type":"SimpleText"},{"code":"I.partition","type":"InlinedCode"},{"text":" has a valid associated","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"with each field. If the ","type":"SimpleText"},{"code":"valid","type":"InlinedCode"},{"text":" is high then we overwrite that field in the current ","type":"SimpleText"},{"code":"top","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"entry. Alternatively, if ","type":"SimpleText"},{"code":"I.push","type":"InlinedCode"},{"text":" is set then we write all fields (regardless of ","type":"SimpleText"},{"code":"valid","type":"InlinedCode"},{"text":")","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"to the next entry on the stack and increment the ","type":"SimpleText"},{"code":"top","type":"InlinedCode"},{"text":" pointer. Note ","type":"SimpleText"},{"code":"mux2","type":"InlinedCode"},{"text":" when setting","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the ","type":"SimpleText"},{"code":"write_address","type":"InlinedCode"},{"text":" of the memory which implements this.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"If ","type":"SimpleText"},{"code":"I.pop","type":"InlinedCode"},{"text":" is set we decrement the ","type":"SimpleText"},{"code":"top","type":"InlinedCode"},{"text":" pointer effectively popping the top entry","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"of the stack.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Lastly we provide ","type":"SimpleText"},{"code":"O.is_empty","type":"InlinedCode"},{"text":" which indicates if the stack is empty.","type":"SimpleText"}]},{"id":"quicksort-design-sorting-core","additionalIds":["sorting-core"],"level":2,"title":"Sorting core","type":"SubHeading"},{"id":"quicksort-design-sorting-core-interface","additionalIds":["interface"],"level":3,"title":"Interface","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The interface to the core is very simple. Apart from ","type":"SimpleText"},{"code":"clock","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"clear","type":"InlinedCode"},{"text":" it just consists of a","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"start","type":"InlinedCode"},{"text":" signal, a ","type":"SimpleText"},{"code":"done_","type":"InlinedCode"},{"text":" indicator and the connections to the read and write ports of the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"RAM.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module I = struct\n  type 'a t =\n    { clocking : 'a Types.Clocking.t\n    ; start : 'a\n    ; read_data : 'a [@bits data_size]\n    }\n  [@@deriving hardcaml ~rtlmangle:false]\nend\n\nmodule O = struct\n  type 'a t =\n    { done_ : 'a\n    ; write_enable : 'a\n    ; write_address : 'a [@bits log_size]\n    ; write_data : 'a [@bits data_size]\n    ; read_address : 'a [@bits log_size]\n    ; read_enable : 'a\n    }\n  [@@deriving hardcaml ~rtlmangle:false]\nend","lineNumber":"","type":"Snippet"},{"id":"quicksort-design-sorting-core-states","additionalIds":["states"],"level":3,"title":"States","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The sorting algorithm is implemented as state machine. The states ","type":"SimpleText"},{"code":"Qsort","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"Update_range","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"and ","type":"SimpleText"},{"code":"Recurse","type":"InlinedCode"},{"text":" are involved with recursion and iteration control. ","type":"SimpleText"},{"code":"Pivot","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"Partition","type":"InlinedCode"},{"text":",","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Swap","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"Swap_pivot","type":"InlinedCode"},{"text":" perform the partitioning process. The state machine begins in the","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Start","type":"InlinedCode"},{"text":" state.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module State = struct\n  type t =\n    | Start\n    | Qsort\n    | Pivot\n    | Partition\n    | Swap\n    | Swap_pivot\n    | Update_range\n    | Recurse\n  [@@deriving sexp_of, compare ~localize, enumerate]\nend","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"We'll discuss each state in detail below. Where appropriate we shall refer to the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Sedgewick implementation of qsort along with the Lomuto partitioning code shown again","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"below with line numbers.","type":"SimpleText"}]},{"lang":"","snippet":" 1  let swap a i j =\n 2    let tmp = a.(i) in\n 3    a.(i) <- a.(j);\n 4    a.(j) <- tmp\n 5  ;;\n 6\n 7  let partition a ~low ~high =\n 8    let pivot = a.(high) in\n 9    let i = ref low in\n10    for j = low to high - 1 do\n11      if a.(j) < pivot\n12      then (\n13        swap a !i j;\n14        int.incr i)\n15    done;\n16    swap a !i high;\n17    !i\n18  ;;\n19\n20  let rec qsort a ~low ~high =\n21    let low, high = ref low, ref high in\n22    while !low < !high do\n23      let pivot = partition a ~low:!low ~high:!high in\n24      if pivot - !low < !high - pivot\n25      then (\n26        qsort a ~low:!low ~high:(pivot - 1);\n27        low := pivot + 1)\n28      else (\n29        qsort a ~low:(pivot + 1) ~high:!high;\n30        high := pivot - 1)\n31    done\n32  ;;","lineNumber":"","type":"Snippet"},{"id":"quicksort-design-sorting-core-states-start","additionalIds":["start"],"level":4,"title":"Start","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"When ","type":"SimpleText"},{"code":"start","type":"InlinedCode"},{"text":" is raised the initial search range is set at the top of the call stack and we","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"transition to ","type":"SimpleText"},{"code":"Qsort","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"id":"quicksort-design-sorting-core-states-qsort","additionalIds":["qsort"],"level":4,"title":"Qsort","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"This controls the main while loop in the algorithm at line 22.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"If the test passes we move state ","type":"SimpleText"},{"code":"Pivot","type":"InlinedCode"},{"text":" and start the partitioning process. Note we also set","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the RAM read address to the pivot point. This is done so the pivot is available to be read","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"in the next state.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"When the test fails we end the qsort function - but only at this level of the stack. Hence","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the state machine will pop the ","type":"SimpleText"},{"code":"Call_stack","type":"InlinedCode"},{"text":" and repeat the test. If the ","type":"SimpleText"},{"code":"Call_stack","type":"InlinedCode"},{"type":"SoftLineBreak"},{"text":"becomes empty we are done and go back to the ","type":"SimpleText"},{"code":"Start","type":"InlinedCode"},{"text":" state.","type":"SimpleText"}]},{"id":"quicksort-design-sorting-core-states-pivot","additionalIds":["pivot"],"level":4,"title":"Pivot","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"In this state we simply read the pivot value we will use for partitioning. It corresponds","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"to line 8. We move directly to state ","type":"SimpleText"},{"code":"Partition","type":"InlinedCode"},{"text":". We set the read address to the start of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the partition so we can begin streaming through it in the following states.","type":"SimpleText"}]},{"id":"quicksort-design-sorting-core-states-partition-swap-and-swap_pivot","additionalIds":["partition-swap-and-swap_pivot"],"level":4,"title":"Partition, Swap, and Swap_pivot.","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"The states ","type":"SimpleText"},{"code":"Partition","type":"InlinedCode"},{"text":" and ","type":"SimpleText"},{"code":"Swap","type":"InlinedCode"},{"text":" implement the for loop on lines 10 to 15. If the test","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"against the pivot at line 11 passes we immediately write the value at ","type":"SimpleText"},{"code":"j","type":"InlinedCode"},{"text":" into ","type":"SimpleText"},{"code":"i","type":"InlinedCode"},{"text":" while","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"setting the read address to ","type":"SimpleText"},{"code":"i","type":"InlinedCode"},{"text":" and transition to ","type":"SimpleText"},{"code":"Swap","type":"InlinedCode"},{"text":". ","type":"SimpleText"},{"code":"Swap","type":"InlinedCode"},{"text":" writes the value at","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"i","type":"InlinedCode"},{"text":" into ","type":"SimpleText"},{"code":"j","type":"InlinedCode"},{"text":" completing the swap. It transitions back immediately to state ","type":"SimpleText"},{"code":"Partition","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Note we read and write the value at address ","type":"SimpleText"},{"code":"i","type":"InlinedCode"},{"text":" in the RAM on the same cycle. This will","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"write the new value while reading the old value (which is what we require for the swap","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"operation). This behavior is due to setting the collision mode of the RAM to","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Read_before_write","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"On line 10 we see the iteration goes up to ","type":"SimpleText"},{"code":"high-1","type":"InlinedCode"},{"text":". The state machine actually goes up to","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"high","type":"InlinedCode"},{"text":". The reason for this is we need to swap the values at high and ","type":"SimpleText"},{"code":"i","type":"InlinedCode"},{"text":" as on line 16. A","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"key point here is the test on line 11 - it will never be true for the value at ","type":"SimpleText"},{"code":"high","type":"InlinedCode"},{"text":" as","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"it is the pivot value. When we reach high we will transition to ","type":"SimpleText"},{"code":"Swap_pivot","type":"InlinedCode"},{"text":" to complete","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"the final swap operation.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Within ","type":"SimpleText"},{"code":"Swap_pivot","type":"InlinedCode"},{"text":" we also now know the correct index of the pivot so write it into the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"current ","type":"SimpleText"},{"code":"Call_stack","type":"InlinedCode"},{"text":" entry. It will be used for later iterations.","type":"SimpleText"}]},{"id":"quicksort-design-sorting-core-states-update_range-and-recurse","additionalIds":["update_range-and-recurse"],"level":4,"title":"Update_range and recurse","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"These states implement lines 23 to 30. They find the smaller of the two partitions and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"recurse into it.  In terms of hardware we need to do two things, hence the two states.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"In ","type":"SimpleText"},{"code":"Update_range","type":"InlinedCode"},{"text":" we are dealing with line 27 or 30. This is effectively replacing the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"current ","type":"SimpleText"},{"code":"Call_stack","type":"InlinedCode"},{"text":" entry with the larger range. A small subtlety here is by updating the","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Call_stack","type":"InlinedCode"},{"text":" entry we actually change the test for the smaller partition - hence we must","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"store it in a register for use in ","type":"SimpleText"},{"code":"Recurse","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"In ","type":"SimpleText"},{"code":"Recurse","type":"InlinedCode"},{"text":" we push the smaller partition into the ","type":"SimpleText"},{"code":"Call_stack","type":"InlinedCode"},{"text":". There is a little extra","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"logic to do with setting the ","type":"SimpleText"},{"code":"push","type":"InlinedCode"},{"text":" signal. We avoid doing so if the pivot would become","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"negative or larger than the array size. This is because our register values (high, low,","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"pivot etc) cannot represent numbers outside the range ","type":"SimpleText"},{"code":"0 .. array size-1","type":"InlinedCode"},{"text":". It is safe to","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"do this - if we did recurse (and extended the size of the registers) we would immediately","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"fail the test on line 22 anyway.","type":"SimpleText"}]},{"id":"quicksort-design-sorting-core-implementation","additionalIds":["implementation"],"level":3,"title":"Implementation","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Below is the complete implementation for reference.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"let create scope (i : _ I.t) =\n  let%hw.Always.State_machine sm =\n    Always.State_machine.create (module State) (Clocking.to_spec i.clocking)\n  in\n  let%hw.Partition_with_valids.Of_always write_partition =\n    Partition_with_valids.Of_always.wire zero\n  in\n  let%hw_var push = Always.Variable.wire ~default:gnd () in\n  let%hw_var pop = Always.Variable.wire ~default:gnd () in\n  let%hw.Call_stack.O.Of_signal stack =\n    Call_stack.create\n      scope\n      { Call_stack.I.clocking = i.clocking\n      ; partition = Partition_with_valids.Of_always.value write_partition\n      ; push = push.value\n      ; pop = pop.value\n      }\n  in\n  let read_address = Always.Variable.wire ~default:(zero log_size) () in\n  let write_address = Always.Variable.wire ~default:(zero log_size) () in\n  let write_enable = Always.Variable.wire ~default:gnd () in\n  let write_data = Always.Variable.wire ~default:(zero data_size) () in\n  let%hw_var i_idx = Clocking.Var.reg i.clocking ~width:log_size in\n  let%hw_var j_idx = Clocking.Var.reg i.clocking ~width:log_size in\n  let%hw_var j_idx_prev = Clocking.Var.reg i.clocking ~width:log_size in\n  let%hw_var pivot_at = Clocking.Var.reg i.clocking ~width:log_size in\n  let%hw_var tmp = Clocking.Var.reg i.clocking ~width:log_size in\n  let init_j_idx =\n    Always.(\n      proc [ j_idx <-- stack.partition.low +:. 1; j_idx_prev <-- stack.partition.low ])\n  in\n  let incr_j_idx =\n    Always.(proc [ j_idx <-- j_idx.value +:. 1; j_idx_prev <-- j_idx.value ])\n  in\n  let swap_write address data =\n    Always.(\n      proc [ write_address <-- address; write_data <-- data; write_enable <-- vdd ])\n  in\n  let partition_search_update raddr =\n    Always.(\n      proc\n        [ read_address <-- j_idx.value\n        ; incr_j_idx\n        ; when_\n            (j_idx_prev.value ==: stack.partition.high)\n            [ read_address <-- raddr\n            ; swap_write i_idx.value pivot_at.value\n            ; sm.set_next Swap_pivot\n            ]\n        ])\n  in\n  let left_partition_is_smaller =\n    stack.partition.pivot -: stack.partition.low\n    <: stack.partition.high -: stack.partition.pivot\n  in\n  let left_partition_is_smaller_reg = Clocking.Var.reg i.clocking ~width:1 in\n  let read_enable = Clocking.Var.reg i.clocking ~width:1 in\n  Always.(\n    compile\n      [ proc\n          (Partition.map write_partition ~f:(fun { valid; value = _ } -> valid <-- gnd)\n           |> Partition.to_list)\n      ; pop <-- gnd\n      ; sm.switch\n          [ ( Start\n            , [ when_\n                  i.start\n                  [ Partition_with_valids.Of_always.assign\n                      write_partition\n                      { low = { valid = vdd; value = zero log_size }\n                      ; high = { valid = vdd; value = ones log_size }\n                      ; pivot = { valid = vdd; value = zero log_size }\n                      }\n                  ; read_enable <-- vdd\n                  ; sm.set_next Qsort\n                  ]\n              ] )\n          ; ( Qsort\n            , [ if_\n                  (stack.partition.low <: stack.partition.high)\n                  [ i_idx <-- stack.partition.low\n                  ; init_j_idx\n                  ; read_address <-- stack.partition.high\n                  ; sm.set_next Pivot\n                  ]\n                  [ if_\n                      stack.is_empty\n                      [ read_enable <-- gnd; sm.set_next Start ]\n                      [ pop <-- vdd ]\n                  ]\n              ] )\n          ; ( Pivot\n            , [ read_address <-- stack.partition.low\n              ; pivot_at <-- i.read_data\n              ; sm.set_next Partition\n              ] )\n          ; ( Partition\n            , [ if_\n                  (i.read_data <: pivot_at.value)\n                  [ swap_write i_idx.value i.read_data\n                  ; read_address <-- i_idx.value\n                  ; i_idx <-- i_idx.value +:. 1\n                  ; sm.set_next Swap\n                  ]\n                  [ partition_search_update i_idx.value ]\n              ] )\n          ; ( Swap\n            , [ swap_write j_idx_prev.value i.read_data\n              ; read_address <-- j_idx.value\n              ; sm.set_next Partition\n              ; partition_search_update i_idx.value\n              ] )\n          ; ( Swap_pivot\n            , [ swap_write stack.partition.high i.read_data\n              ; write_partition.pivot.value <-- i_idx.value\n              ; write_partition.pivot.valid <-- vdd\n              ; sm.set_next Update_range\n              ] )\n          ; ( Update_range\n            , [ left_partition_is_smaller_reg <-- left_partition_is_smaller\n              ; if_\n                  left_partition_is_smaller\n                  [ tmp <-- stack.partition.low\n                  ; write_partition.low.value <-- stack.partition.pivot +:. 1\n                  ; write_partition.low.valid <-- vdd\n                  ]\n                  [ tmp <-- stack.partition.high\n                  ; write_partition.high.value <-- stack.partition.pivot -:. 1\n                  ; write_partition.high.valid <-- vdd\n                  ]\n              ; sm.set_next Recurse\n              ] )\n          ; ( Recurse\n            , [ if_\n                  left_partition_is_smaller_reg.value\n                  [ write_partition.low.value <-- tmp.value\n                  ; write_partition.high.value <-- stack.partition.pivot -:. 1\n                  ]\n                  [ write_partition.low.value <-- stack.partition.pivot +:. 1\n                  ; write_partition.high.value <-- tmp.value\n                  ]\n              ; push\n                <-- mux2\n                      left_partition_is_smaller_reg.value\n                      (stack.partition.pivot <>:. 0)\n                      (stack.partition.pivot <>+. -1)\n              ; sm.set_next Qsort\n              ] )\n          ]\n      ]);\n  { O.done_ = sm.is Start\n  ; write_enable = write_enable.value\n  ; write_address = write_address.value\n  ; write_data = write_data.value\n  ; read_address = read_address.value\n  ; read_enable = read_enable.value\n  }\n;;","lineNumber":"","type":"Snippet"},{"id":"quicksort-design-testing","additionalIds":["testing"],"level":2,"title":"Testing","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"We will not go through the testbench in detail for this example - suffice it to say it","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"looks very similar to previous examples - perform a reset, load the input data, start the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"core and wait for it to complete and then read back the results and check they are","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"correct.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"There is an interesting bit of code to do with debugging though.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"module Debug = struct\n  type t =\n    { ram : Cyclesim.Memory.t\n    ; low : Cyclesim.Node.t\n    ; pivot : Cyclesim.Node.t\n    ; high : Cyclesim.Node.t\n    ; sm : Cyclesim.Reg.t\n    ; pivot_state : int\n    }\n\n  let create sim =\n    let ram = Cyclesim.lookup_mem_by_name sim \"my_ram\" |> Option.value_exn in\n    let low = Cyclesim.lookup_node_by_name sim \"stack$low\" |> Option.value_exn in\n    let pivot = Cyclesim.lookup_node_by_name sim \"stack$pivot\" |> Option.value_exn in\n    let high = Cyclesim.lookup_node_by_name sim \"stack$high\" |> Option.value_exn in\n    let sm = Cyclesim.lookup_reg_by_name sim \"sm\" |> Option.value_exn in\n    let pivot_state, _ =\n      List.findi_exn Qsort.Qsort.State.all ~f:(fun _ -> function\n        | Pivot -> true\n        | _ -> false)\n    in\n    { ram; low; pivot; high; sm; pivot_state }\n  ;;\n\n  let update_on_cycle t =\n    if Cyclesim.Reg.to_int t.sm = t.pivot_state\n    then (\n      let ram = Cyclesim.Memory.read_all t.ram in\n      let ram = Array.map ram ~f:Bits.to_unsigned_int in\n      let low = Cyclesim.Node.to_int t.low in\n      let pivot = Cyclesim.Node.to_int t.pivot in\n      let high = Cyclesim.Node.to_int t.high in\n      Stdio.print_s\n        [%message \"\" ~_:((low, pivot, high) : int * int * int) (ram : int array)])\n  ;;\nend\n\nlet run_qsort (sim : Sim.t) debug =\n  let inputs = Cyclesim.inputs sim in\n  let outputs = Cyclesim.outputs sim in\n  inputs.start := vdd;\n  Cyclesim.cycle sim;\n  inputs.start := gnd;\n  let timeout = ref 0 in\n  while (not (Bits.to_bool !(outputs.done_))) && !timeout < 300 do\n    Option.iter debug ~f:Debug.update_on_cycle;\n    Cyclesim.cycle sim;\n    Int.incr timeout\n  done\n;;","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"While the core is running we (optionally) execute a function called","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Debug.update_on_cycle","type":"InlinedCode"},{"text":" on every clock cycle. This uses a feature of ","type":"SimpleText"},{"code":"Cyclesim","type":"InlinedCode"},{"text":" that","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"allows us to lookup internal values within a simulation. In particular, we look up the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"high, low and pivot values and the complete memory contents every time the state machine","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"enters the ","type":"SimpleText"},{"code":"Pivot state","type":"InlinedCode"},{"text":".","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"We then dump those values. When debugging the state machine this was very useful in","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"tracking down problems.  The output looks likes this:","type":"SimpleText"}]},{"lang":"","snippet":"((0 0 15) (ram (9 4 7 6 5 5 0 3 1 4 8 6 4 0 2 3)))\n((0 0 3) (ram (0 1 0 2 3 5 9 3 4 4 8 6 4 7 6 5)))\n((0 3 2) (ram (0 1 0 2 3 5 9 3 4 4 8 6 4 7 6 5)))\n((1 0 2) (ram (0 1 0 2 3 5 9 3 4 4 8 6 4 7 6 5)))\n((5 4 15) (ram (0 0 1 2 3 5 9 3 4 4 8 6 4 7 6 5)))\n((5 0 8) (ram (0 0 1 2 3 3 4 4 4 5 8 6 9 7 6 5)))\n((7 6 8) (ram (0 0 1 2 3 3 4 4 4 5 8 6 9 7 6 5)))\n((10 9 15) (ram (0 0 1 2 3 3 4 4 4 5 8 6 9 7 6 5)))\n((11 10 15) (ram (0 0 1 2 3 3 4 4 4 5 5 6 9 7 6 8)))\n((11 14 13) (ram (0 0 1 2 3 3 4 4 4 5 5 6 7 6 8 9)))\n((12 11 13) (ram (0 0 1 2 3 3 4 4 4 5 5 6 7 6 8 9)))","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"This data made it much, much easier to find points where things started to go awry.","type":"SimpleText"}]}]}],"lastModifiedTime":1750709442979,"tocItem":{"chapterTitle":"Examples","pageTitle":"6.6 Quicksort","pageMeta":{"parent":["examples.mdx"],"title":["6.6 Quicksort"],"uuid":["3d4d99d8-9e5a-3cfb-204c-0eba57ef2956"]},"dirName":"examples","fileName":"quicksort","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Quicksort","id":"quicksort","customAnchorId":"quicksort"},{"title":"Hardware Design","id":"hardware-design","customAnchorId":"hardware-design"},{"title":"Quicksort Design","id":"quicksort-design","customAnchorId":"quicksort-design"}]}},{"type":"Page","content":[{"type":"Paragraph","content":[{"text":"The default simulator shipped with Hardcaml is a cycle-accurate","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"simulator implemented in OCaml. There are two other types of simulator","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"backends shipped with Hardcaml, available in the ","type":"SimpleText"},{"code":"hardcaml_c","type":"InlinedCode"},{"text":" and","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"hardcaml_verilator","type":"InlinedCode"},{"text":" libraries.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The libraries can be installed with opam.","type":"SimpleText"}]},{"lang":"","snippet":"opam install hardcaml_verilator\nopam install hardcaml_c","lineNumber":"","type":"Snippet"},{"id":"hardcaml_verilator","additionalIds":[],"title":"Hardcaml_verilator","headingContent":[{"code":"Hardcaml_verilator","type":"InlinedCode"}],"type":"Section","content":[{"type":"Paragraph","content":[{"url":"https://www.veripool.org/wiki/verilator","isFile":false,"type":"Link","content":[{"text":"Verilator","type":"SimpleText"}]},{"text":" is a free and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"open-source software tool which converts Verilog to a cycle-accurate","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"behavioural model in C++ or SystemC that runs with high","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"performance. ","type":"SimpleText"},{"code":"Hardcaml_verilator","type":"InlinedCode"},{"text":" is a simulation backend that","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"compiles a Hardcaml circuit simulation to the Verilator backend, with","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"custom-generated C++ bindings. All these are done under the hood","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"whilst exposing the Cyclesim API to the end user.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"To use ","type":"SimpleText"},{"url":"https://ocaml.org/p/hardcaml_verilator/latest/doc/Hardcaml_verilator/index.html","isFile":false,"type":"Link","content":[{"code":"Hardcaml_verilator","type":"InlinedCode"}]},{"text":",","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://www.veripool.org/wiki/verilator","isFile":false,"type":"Link","content":[{"text":"Verilator","type":"SimpleText"}]},{"text":" and g++ have to be","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"installed on your system.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The key benefit of using the Verilator-based backend is that it is","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"much more performant than using Cyclesim or Hardcaml_c.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"There are several known downsides with this simulation backend:","type":"SimpleText"}]},{"bulletMarker":"-","tight":true,"type":"BulletList","content":[{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"The Verilator simulator does not support inspecting the values of","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"internal signals of the circuit.","type":"SimpleText"}]}]},{"type":"ListItem","content":[{"type":"Paragraph","content":[{"text":"Compiling extremely large circuits on Verilator can be slow, but the","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"trade-off is worthwhile for large-scale simulations.","type":"SimpleText"}]}]}]},{"lang":"ocaml","snippet":"open Hardcaml\nopen Signal\n\n(* Circuit definition. *)\nlet clock = input \"clock\" 1\nlet foo = input \"foo\" 32\nlet bar = input \"bar\" 32\nlet baz =\n  let r_sync = Reg_spec.create ~clock () in\n  output \"baz\" (reg ~enable:vdd r_sync (foo +: bar))\n;;\n\n(* Create Simulation. *)\nlet circuit = Circuit.create_exn ~name:\"adder\" [ baz ]","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"After creating the Verilator-based Cyclesim object, the simulation","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"works as would any Cyclesim simulator.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let cycle sim foo bar =\n    (Cyclesim.in_port sim \"foo\") := Bits.of_unsigned_int ~width:32 foo;\n    (Cyclesim.in_port sim \"bar\") := Bits.of_unsigned_int ~width:32 bar;\n    Cyclesim.cycle sim;\n    Stdio.printf \"%d + %d = %d\\n\"\n      foo bar (Bits.to_unsigned_int !(Cyclesim.out_port sim \"baz\"));\n  ;;\nval cycle : ('a, 'b) Cyclesim.t -> int -> int -> unit = <fun>\n\n# let sim_verilator =\n    Hardcaml_verilator.create\n       ~clock_names:[ \"clock\" ]\n       circuit\n  ;;\nval sim_verilator : Cyclesim.t_port_list = <abstr>\n\n#  cycle sim_verilator 1 2;\n1 + 2 = 3\n- : unit = ()\n\n#  cycle sim_verilator 23 34;\n23 + 34 = 57\n- : unit = ()","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Notice the type signature of ","type":"SimpleText"},{"code":"sim_verilator","type":"InlinedCode"},{"text":" being a simple","type":"SimpleText"},{"type":"SoftLineBreak"},{"code":"Cyclesim.t_port_list","type":"InlinedCode"},{"text":". This means that we can write simulation test","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"benches that are agnostic to the backend, whether it is Hardcaml's","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"Cyclesim, Hardcaml Verilator, or Hardcaml C.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"code":"Hardcaml_verilator","type":"InlinedCode"},{"text":" also supports an Interface-based API. See","type":"SimpleText"},{"type":"SoftLineBreak"},{"url":"https://ocaml.org/p/hardcaml_verilator/latest/doc/Hardcaml_verilator/With_interface/index.html","isFile":false,"type":"Link","content":[{"code":"Hardcaml_verilator.With_interface","type":"InlinedCode"}]},{"text":".","type":"SimpleText"}]},{"id":"hardcaml_verilator-compilation-options","additionalIds":["compilation-options"],"level":2,"title":"Compilation options","type":"SubHeading"},{"type":"Paragraph","content":[{"text":"Some Verilator configuration options are exposed via [","type":"SimpleText"},{"code":"Hardcaml_verilator.Config","type":"InlinedCode"},{"text":"]. In","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"particular, it is possible to split the generated C++ code into much smaller chunks and","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"use many more gcc processes which can drastically improve compilation time. See the config","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"module for some presets.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The code supports both version 4 and 5 of Verilator - set the config value","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"[verilator_version] appropriately.","type":"SimpleText"}]}]},{"id":"hardcaml_c","additionalIds":[],"title":"Hardcaml_c","headingContent":[{"code":"Hardcaml_c","type":"InlinedCode"}],"type":"Section","content":[{"type":"Paragraph","content":[{"text":"Hardcaml_c is a Hardcaml simulator that converts the design to a","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"C-based simulation model for improved performance.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The primary benefit of using Hardcaml_c is that it has a much more","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"modest compilation time (compared to ","type":"SimpleText"},{"code":"Hardcaml_verilator","type":"InlinedCode"},{"text":"), but is still","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"much more performant than the regular Hardcaml Cyclesim simulator.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"To use ","type":"SimpleText"},{"code":"Hardcaml_c","type":"InlinedCode"},{"text":", ","type":"SimpleText"},{"code":"gcc","type":"InlinedCode"},{"text":" has to be installed on your local machine.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"The key limitation in Hardcaml C is that, as of writing, it does not","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"properly support tracing outputs before clock edges.","type":"SimpleText"}]},{"type":"Paragraph","content":[{"text":"Using the ","type":"SimpleText"},{"code":"Hardcaml_c","type":"InlinedCode"},{"text":" simulation backend is simple, as demonstrated","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"in the example below.","type":"SimpleText"}]},{"lang":"ocaml","snippet":"# let sim_c =\n    Hardcaml_c.Cyclesim.create circuit\n  ;;\nval sim_c : Cyclesim.t_port_list = <abstr>\n\n# cycle sim_c 1 2;\n1 + 2 = 3\n- : unit = ()\n\n# cycle sim_c 23 50;\n23 + 50 = 73\n- : unit = ()","lineNumber":"","type":"Snippet"},{"type":"Paragraph","content":[{"text":"Like Hardcaml Verilator, Hardcaml C supports an Interface-based","type":"SimpleText"},{"type":"SoftLineBreak"},{"text":"API. See ","type":"SimpleText"},{"url":"https://ocaml.org/p/hardcaml_c/latest/doc/Hardcaml_c/Cyclesim/With_interface/index.html","isFile":false,"type":"Link","content":[{"code":"Hardcaml_c.Cyclesim.With_interface","type":"InlinedCode"}]},{"text":".","type":"SimpleText"}]}]}],"lastModifiedTime":1750709442904,"tocItem":{"chapterTitle":"Libraries","pageTitle":"7.1 High Performance Simulation Backends","pageMeta":{"parent":["libraries.mdx"],"title":["7.1 High Performance Simulation Backends"],"uuid":["1e88a449-912e-3457-91f8-b08e1f0ed98e"]},"dirName":"libraries","fileName":"high_performance_simulation_backends","fileExtension":"md","viewOnRelativePath":null,"pageSectionIdTitles":[{"title":"Hardcaml_verilator","id":"hardcaml_verilator","customAnchorId":"hardcaml_verilator"},{"title":"Hardcaml_c","id":"hardcaml_c","customAnchorId":"hardcaml_c"}]}}]