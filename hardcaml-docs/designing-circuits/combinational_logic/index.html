<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" /> 
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"> 
<title>Hardcaml: 2.1 Combinational Logic</title>
<link rel="stylesheet" type="text/css" href="/hardcaml-docs/static/css/katex.min.css">
<link rel="stylesheet" type="text/css" href="/hardcaml-docs/static/main.css">
<link rel="stylesheet" type="text/css" href="/hardcaml-docs/static/css/global-overrides.css">
</head>
<link rel="shortcut icon" href="/hardcaml-docs/favicon.png"type="image/ico"/>
<body class="znai-theme theme-znai-dark">
<script>(function() {
    var themeNameKey = 'znaiTheme';
    var darkThemeName = 'znai-dark';
    var lightThemeName = 'default';

    var znaiTheme = {
        changeHandlers: [],
        addChangeHandler(handler) {
            this.changeHandlers.push(handler);
        },
        removeChangeHandler(handler) {
            var idx = this.changeHandlers.indexOf(handler);
            this.changeHandlers.splice(idx, 1);
        },
        set(name) {
            this.name = name;
            document.body.className = 'znai-theme theme-' + name;

            var idx = 0;
            var len = this.changeHandlers.length;
            for (; idx < len; idx++) {
                this.changeHandlers[idx](name);
            }
        },
        setExplicitly(name) {
            storeThemeName(name);
            this.set(name);
        },
        setExplicitlyIfNotSetAlready(name) {
            const themeName = getStoredThemeName();
            if (themeName) {
                return
            }

            this.setExplicitly(name)
        },
        toggle() {
            this.setExplicitly(this.name === lightThemeName ? darkThemeName : lightThemeName)
        }
    };

    var mediaThemeName = setLightMatchMediaListenerAndGetThemeName()
    var themeName = getStoredThemeName() || mediaThemeName;
    znaiTheme.set(themeName);

    window.znaiTheme = znaiTheme;

    function getStoredThemeName() {
        return localStorage.getItem(themeNameKey);
    }

    function storeThemeName(name) {
        return localStorage.setItem(themeNameKey, name);
    }

    function setLightMatchMediaListenerAndGetThemeName() {
        if (!window.matchMedia) {
            return darkThemeName;
        }

        var lightQuery = window.matchMedia('(prefers-color-scheme: light)');
        lightQuery.addListener(function (e) {
            const newThemeName = e.matches ? lightThemeName : darkThemeName;
            znaiTheme.setExplicitly(newThemeName);
        });

        return lightQuery.matches ? lightThemeName : darkThemeName;
    }
})()</script>
<div id="znai"><div id="znai-initial-page-loading" style="margin: -20px 0 0 -20px; padding: 0 40px 40px 0; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center">
    <div></div>
</div><section id="page-content" style="max-width: 640px; margin-left: auto; margin-right: auto;">
<article>
<p>Combinational logic is formed from boolean functions whose outputs are fully determined by their current inputs This is in contrast to sequential logic where the outputs are a function of their current and previous inputs At the lowest level combinational circuits are built from simple primitives such as NAND gates in ASIC designs or LUTs in FPGA designs Building circuits with such low level primitives is tedious so instead we provide a set of higher level primitives with which to design circuits The module type provides these primitives Combinational circuits can be thought of as graphs with nodes representing logic operations and edges representing often also referred to as These graphs are directed and must not contain any cycles Comb S wires signals</p>
</article>

<article>
<header><h1>Vectors and Widths</h1></header>
<p>The fundamental type in Hardcaml is a vector with a specified width The width can be one or more bits There exists a special signal called which has zero width but is rarely used and exists for internal use In Hardcaml the types and are used to represent vectors For now we will consider s The simplest way to create a value is the function Note that in both the specification of the bit vector with and the printing of the value we treat the left most 1 or 0 as the most significant bit We can now interrogate the width of this value It is always possible to get the width of a Hardcaml vector empty Signal t Bits t Bits t Bits t of_string # open Hardcaml Bits # let x of_string 11001 val x t 11001 of_string x # width x int 5</p>
</article>

<article>
<header><h1>Binary Constants and Converting to OCaml Ints</h1></header>
<p>takes a string which consists of s and s s are also allowed and are ignored The first character in the string becomes the most significant bit msb of the vector The vector width is the sum of the number of and characters in the string A feature of the module but not s is the ability to convert back to an OCaml value We can do so with the function has interpreted as an unsigned three bit integer value will treat it as a signed twos complement integer value If the resulting value cannot fit in an integer then the functions will raise may be useful in such cases if used carefully of_string 0 1 _ 0 1 # let x of_string 100 val x t 100 Bits Signal to_unsigned_int # to_unsigned_int x int 4 to_unsigned_int x to_signed_int # to_signed_int x int 4 to_int_trunc</p>
</article>

<article>
<header><h1>Richer Constants</h1></header>
<p>Probably the most useful constant generating functions are and If the given value is negative it will be sign extended to the appropriate width Values too large or too small to be represented in bits will raise an exception will silently truncate the input value Variants for and are also provided The function is actually more general than just converting binary values It can also parse a specification string which roughly follows the Verilog constant format Binary decimal octal and hexadecimal notations are supported If the format specifier is capitalized the leading bit in the given value will be used for sign extension only relevant for the binary octal and hex specifiers of_unsigned_int of_signed_int # of_unsigned_int width 10 514 t 1000000010 # of_signed_int width 10 1 t 1111111111 width of_int_trunc Int32 t Int64 t of_string &lt;width&gt; &lt;format&gt;&lt;value&gt; b d o h # of_string 5 b1101 t 01101 # of_string 5 hd t 01101 # of_string 5 d13 t 01101 # of_string 5 B1101 t 11101 # of_string 5 Hd t 11101</p>
</article>

<article>
<header><h1>Operators, Widths, and Their Names</h1></header>
<p>Hardcaml provides a set of operators providing the usual functions such as logical arithmetic and comparison operations A key API design point is Hardcaml does not encode signedness into the type of vectors Instead the operator suffix indicates how to interpret the operands For example there are two less than operators Operators ending with treat operands as signed Operators ending with treat operands as unsigned For example there are two distinct less than operators for signed less than for unsigned less than Many operators are agnostic to signedness The addition operator is an example of this Addition requires both arguments to have the same bit width otherwise it raises a runtime exception and the bit by bit addition process produces identical results whether the values are interpreted as signed or unsigned The carry behavior is the same only the semantic interpretation of the result differs &lt; &lt;</p>
</article>

<article>
<header><h1>API Tour</h1></header>
<p>The following describes several key functions See the documentation for for other useful functions Arithmetic addition subtraction Both arguments must be the same width The result will be the width of the arguments unsigned multiplication signed multiplication The arguments can have arbitrary widths The result will be the sum of the widths of the arguments Logical logical and logical or logical xor Both arguments must be the same width The result will be the width of the arguments logical not The result will be the width of the argument Comparison equals not equals unsigned comparisons signed comparisons Both arguments must be the same width The result will be 1 bit Multiplexers selects when is high and when is low should be 1 bit wide and must be the same width selects the element in at position The range of must not exceed the length of can be shorter however and the last element in the list is logically repeated as much as needed Cases The function is similar to a multiplexer in that it selects one of its inputs to output It is given a signal and each case has a corresponding value The first case where is output If no case matches the value is output Select A range of bits can be extracted from the vector using The upper and lower indexes are inclusive Selecting outside the range of the input value raises The operator provides a nice syntax for this The operator can also be used similar to Verilog Other selection functions include and a richer set of operators for special circumstances Concatenation Vectors can be concatenated using the following functions The _msb and _lsb suffix in the functions indicates whether the head of the list holds the most significant bit or least significant bit respectively Comb S * * &amp; | ^ &lt;&gt; &lt; &lt; &gt; &gt; &lt; &lt; &gt; &gt; mux2 sel t f t sel f sel sel t f mux sel lst lst sel sel lst lst # List init 4 f fun sel &gt; mux of_unsigned_int width 2 sel gnd vdd t list 0 1 1 1 cases select match select match # let cases select cases default of_unsigned_int width 8 10 of_unsigned_int width 4 select of_unsigned_int width 4 2 of_unsigned_int width 8 20 of_unsigned_int width 4 3 of_unsigned_int width 8 30 of_unsigned_int width 4 6 of_unsigned_int width 8 60 |&gt; to_unsigned_int val cases int &gt; int &lt;fun&gt; # cases 3 int 30 # cases 6 int 60 default # cases 4 int 10 select # select of_string 0011000 high 4 low 3 t 11 # of_string 001100 3 2 t 11 Some x # of_string 001100 3 Some 2 t 01 sel_top sel_bottom drop_top drop_bottom # vdd @ gnd t 10 # concat_msb vdd gnd t 10 # concat_lsb gnd vdd t 10</p>
</article>

<article>
<header><h1>Integer Arguments</h1></header>
<p>Various operators can take an integer as their right hand argument The right hand argument will be converted to a vector by inferring the required width from the left hand argument Such operators are suffixed with a # of_string 011 1 t 100</p>
</article>

<article>
<header><h1>Richer Operations on Vectors</h1></header>
<p>The functions on vectors described so far form a small subset of the full API provided by Hardcaml However all the other functions are expressed in terms of this subset Splitting and split a vector into multiple parts defines the width of each part By default the original vector must be exactly divisible by Shifting shift a vector by a constant amount rotate by a constant amount builds a variable width shift circuit Resizing and resize a vector to the given width which may be larger or smaller When growing larger adds 0 s at the top while repeats the msb Reductions takes a list of vectors and an operation to perform between them all Or reduction Summation does much the same thing as except it forms the computation in a tree structure Additional the operation it performs can take more than 2 arguments as specified by an value We commonly use and together With_valid is a record type with a 1 bit signal and an arbitrary signal It is meant to work a little like an Option type where means and means Priority based selectors takes a list of and returns the first one whose is high It returns a single whose valid is low if no case was selected adds a default value which is output if no case is selected Counting bits all count some number of bits within a vector Their implementations are tree based and have logic depth Onehot and Gray and convert between onehot and binary representations Similarly for and Random creates a random constant vector of the given width Mostly useful for testbenches Bits set is equivalent to is equivalent to is equivalent to With_zero_width We disallow zero width vectors in Hardcaml allows us to represent them The type is where indicates zero width The functions provided try to do sane things with zero width vectors TypedMath and are modules with signature They provide arithmetic and comparison operators Since they know the signedness of the type they can for example add or compare vectors of different widths Additionally addition and subtraction grow their result width by one bit to ensure overflow is impossible This extra bit captures the carry that might result from the operation split_lsb split_msb part_width part_width # split_lsb part_width 4 of_string 16 H4321 t list 0001 0010 0011 0100 # split_msb part_width 4 exact false of_string 15 H4321 t list 1000 0110 0100 001 sll srl sra rotr rotl log_shift # sra of_string 10 by 1 t 11 # log_shift of_string 0100 f rotl by of_string 10 t 0001 uresize sresize uresize sresize reduce # reduce f | bits_lsb of_string 00100 t 1 # reduce f List map 1 3 5 6 f of_unsigned_int width 6 t 001111 tree reduce arity # tree arity 4 of_string 111111 |&gt; bits_lsb f function a &gt; a | a b &gt; a &amp; b | a b c &gt; a &amp; b &amp; c | a b c d &gt; a &amp; b &amp; c &amp; d | _ &gt; failwith impossible t 1 tree reduce # tree arity 4 of_string 111111 |&gt; bits_lsb f reduce f &amp; t 1 With_valid valid value valid 0 None valid 1 Some value priority_select With_valids valid With_valid priority_select_with_default # priority_select_with_default default of_string 1111 valid gnd value of_string 0001 valid gnd value of_string 0100 t 1111 # priority_select_with_default default of_string 1111 valid vdd value of_string 0001 valid vdd value of_string 0100 t 0001 popcount leading_zeros leading_ones trailing_zeros trailing_ones log width # popcount of_string 1100011 t 100 # trailing_zeros of_string 1110010100 t 0010 binary_to_onehot onehot_to_binary gray_to_binary binary_to_gray # binary_to_onehot of_string 110 t 01000000 # onehot_to_binary of_string 01000 t 011 # binary_to_gray of_string 110 t 101 # gray_to_binary of_string 01000 t 01111 random any_bits_set x &lt;&gt; 0 all_bits_set x 1 no_bits_set x 0 With_zero_width Comb t option None # With_zero_width concat_msb None ones 2 zero 0 zero 1 Some of_string 1101 With_zero_width t Base Option Some 1101101 Unsigned Signed TypedMath</p>
</article>
</section>
<section id="table-of-contents" style="max-width: 640px; margin-left: auto; margin-right: auto;">
<article>
<a href="/hardcaml-docs/introduction/why/">1.1 Why Hardcaml</a>
</article>

<article>
<a href="/hardcaml-docs/introduction/installing_with_opam/">1.2 Installing the Opensource Release</a>
</article>

<article>
<a href="/hardcaml-docs/introduction/quick_overview/">1.3 Quick Overview</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/combinational_logic/">2.1 Combinational Logic</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/rom/">2.1.1 ROM</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/mux4/">2.1.2 Mux4</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/priority_encoder/">2.1.3 Priority Encoder</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/parity/">2.1.4 Parity</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/alu/">2.1.5 ALU</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/sequential_logic/">2.2 Sequential Logic</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/jk_flip_flop/">2.2.1 JK Flip Flop</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/t_flip_flop/">2.2.2 T Flip Flop</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/d_flip_flop/">2.2.3 D Flip Flop</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/ring_counter/">2.2.4 Ring Counter</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/mobius_counter/">2.2.5 Mobius Counter</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/modulo_n_counter/">2.2.6 Modulo N Counter</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/gray_counter/">2.2.7 Gray Counter</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/bidirectional_shift_reg/">2.2.8 Bidirectional Shift Register</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/single_port_ram/">2.2.9 Single Port RAM</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/sync_fifo/">2.2.10 Synchronous FIFO</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/circuits/">2.3 Circuits</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/rtl_generation/">2.4 RTL Generation</a>
</article>

<article>
<a href="/hardcaml-docs/simulating-circuits/simulation/">3.1 Simulating with Cyclesim</a>
</article>

<article>
<a href="/hardcaml-docs/simulating-circuits/waveforms/">3.2 Waveforms</a>
</article>

<article>
<a href="/hardcaml-docs/simulating-circuits/waveterm_interactive_viewer/">3.3 Interactive Viewer</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/naming/">4.1 Naming</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/always/">4.2 Always DSL</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/binary_coded_decimal/">4.2.1 BCD Conversion</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/cylon_eye/">4.2.2 Cylon Eye</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/state_machine_always_api/">4.3 Designing State Machines</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/sequence_detector/">4.3.1 Sequence Detector</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/double_dabble/">4.3.2 Double Dabble</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/instantiation/">4.4 Instantiation</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/structural/">4.5 Working with Structural</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/conversion-to-rtl/">4.6 How Hardcaml Converts Signals</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/hardcaml_interfaces/">5.1 Hardcaml Interfaces</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/interfaces_with_ppx_hardcaml/">5.2 Interfaces with ppx_hardcaml</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/module_interfaces/">5.3 Module Interfaces</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/simulating_with_interfaces/">5.4 Simulating with Interfaces</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/enums_in_hardcaml/">5.5 Enums in Hardcaml</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/typed_alu/">5.5.1 Typed ALU</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/scopes/">5.6 Scopes</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/module_hierarchies/">5.7 Module Hierarchies</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/naming_with_ppx_hardcaml/">5.8 Naming with ppx_hardcaml</a>
</article>

<article>
<a href="/hardcaml-docs/examples/counter/">6.1 Counter</a>
</article>

<article>
<a href="/hardcaml-docs/examples/serial_multiplier/">6.2 Serial Multipler</a>
</article>

<article>
<a href="/hardcaml-docs/examples/fibonacci_numbers/">6.3 Fibonacci Numbers</a>
</article>

<article>
<a href="/hardcaml-docs/examples/fft/">6.4 FFT</a>
</article>

<article>
<a href="/hardcaml-docs/examples/binary_search/">6.5 Binary Search</a>
</article>

<article>
<a href="/hardcaml-docs/examples/quicksort/">6.6 Quicksort</a>
</article>

<article>
<a href="/hardcaml-docs/libraries/high_performance_simulation_backends/">7.1 High Performance Simulation Backends</a>
</article>
</section>
</div>
<script type="text/javascript" src="/hardcaml-docs/footer.js"></script>
<script type="text/javascript" src="/hardcaml-docs/toc.js"></script>
<script type="text/javascript" src="/hardcaml-docs/assets.js"></script>
<script type="module" src="/hardcaml-docs/static/main.js"></script>
<script type="module" src="/hardcaml-docs/search-index.js"></script>
<script type="module">
document.getElementById('znai').innerHTML = '';
/*<!--*/
window.ReactDOM.render(React.createElement(Documentation, {
  "docMeta" : {
    "viewOn" : {
      "link" : "https://github.com/janestreet/hardcaml",
      "title" : "View Source"
    },
    "id" : "hardcaml-docs",
    "title" : "Hardcaml",
    "type" : "",
    "previewEnabled" : false
  },
  "page" : {
    "type" : "Page",
    "content" : [ {
      "type" : "Paragraph",
      "content" : [ {
        "text" : "Combinational logic is formed from boolean functions whose outputs are fully",
        "type" : "SimpleText"
      }, {
        "type" : "SoftLineBreak"
      }, {
        "text" : "determined by their current inputs. This is in contrast to sequential logic,",
        "type" : "SimpleText"
      }, {
        "type" : "SoftLineBreak"
      }, {
        "text" : "where the outputs are a function of their current and previous inputs.",
        "type" : "SimpleText"
      } ]
    }, {
      "type" : "Paragraph",
      "content" : [ {
        "text" : "At the lowest level, combinational circuits are built from simple primitives such",
        "type" : "SimpleText"
      }, {
        "type" : "SoftLineBreak"
      }, {
        "text" : "as NAND gates (in ASIC designs) or LUTs (in FPGA designs). Building circuits",
        "type" : "SimpleText"
      }, {
        "type" : "SoftLineBreak"
      }, {
        "text" : "with such low-level primitives is tedious, so instead, we provide a set of higher-level",
        "type" : "SimpleText"
      }, {
        "type" : "SoftLineBreak"
      }, {
        "text" : "primitives with which to design circuits. The ",
        "type" : "SimpleText"
      }, {
        "code" : "Comb.S",
        "type" : "InlinedCode"
      }, {
        "text" : " module type",
        "type" : "SimpleText"
      }, {
        "type" : "SoftLineBreak"
      }, {
        "text" : "provides these primitives.",
        "type" : "SimpleText"
      } ]
    }, {
      "type" : "Paragraph",
      "content" : [ {
        "text" : "Combinational circuits can be thought of as graphs with nodes representing logic",
        "type" : "SimpleText"
      }, {
        "type" : "SoftLineBreak"
      }, {
        "text" : "operations and edges representing ",
        "type" : "SimpleText"
      }, {
        "code" : "wires",
        "type" : "InlinedCode"
      }, {
        "text" : " (often also referred to as ",
        "type" : "SimpleText"
      }, {
        "code" : "signals",
        "type" : "InlinedCode"
      }, {
        "text" : "). These",
        "type" : "SimpleText"
      }, {
        "type" : "SoftLineBreak"
      }, {
        "text" : "graphs are directed and must not contain any cycles.",
        "type" : "SimpleText"
      } ]
    }, {
      "id" : "vectors-and-widths",
      "additionalIds" : [ ],
      "title" : "Vectors and Widths",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The fundamental type in Hardcaml is a vector with a specified width. The width",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "can be one or more bits. There exists a special signal called ",
          "type" : "SimpleText"
        }, {
          "code" : "empty",
          "type" : "InlinedCode"
        }, {
          "text" : " which has",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "zero width but is rarely used and exists for internal use.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "In Hardcaml the types ",
          "type" : "SimpleText"
        }, {
          "code" : "Signal.t",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "Bits.t",
          "type" : "InlinedCode"
        }, {
          "text" : " are used to represent vectors. For now we",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "will consider ",
          "type" : "SimpleText"
        }, {
          "code" : "Bits.t",
          "type" : "InlinedCode"
        }, {
          "text" : "s.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The simplest way to create a ",
          "type" : "SimpleText"
        }, {
          "code" : "Bits.t",
          "type" : "InlinedCode"
        }, {
          "text" : " value is the ",
          "type" : "SimpleText"
        }, {
          "code" : "of_string",
          "type" : "InlinedCode"
        }, {
          "text" : " function:",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# open Hardcaml.Bits;;\n# let x = of_string \"11001\";;\nval x : t = 11001",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Note that in both the specification of the bit vector with ",
          "type" : "SimpleText"
        }, {
          "code" : "of_string",
          "type" : "InlinedCode"
        }, {
          "text" : " and the printing of",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "the value ",
          "type" : "SimpleText"
        }, {
          "code" : "x",
          "type" : "InlinedCode"
        }, {
          "text" : " we treat the left most 1 or 0 as the most significant bit.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "We can now interrogate the width of this value:",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# width x\n- : int = 5",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "It is always possible to get the width of a Hardcaml vector.",
          "type" : "SimpleText"
        } ]
      } ]
    }, {
      "id" : "binary-constants-and-converting-to-ocaml-ints",
      "additionalIds" : [ ],
      "title" : "Binary Constants and Converting to OCaml Ints",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "of_string",
          "type" : "InlinedCode"
        }, {
          "text" : " takes a string which consists of ",
          "type" : "SimpleText"
        }, {
          "code" : "0",
          "type" : "InlinedCode"
        }, {
          "text" : "s and ",
          "type" : "SimpleText"
        }, {
          "code" : "1",
          "type" : "InlinedCode"
        }, {
          "text" : "s (",
          "type" : "SimpleText"
        }, {
          "code" : "_",
          "type" : "InlinedCode"
        }, {
          "text" : "s are",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "also allowed, and are ignored). The first character in the string",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "becomes the most significant bit (msb) of the vector. The vector width",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "is the sum of the number of ",
          "type" : "SimpleText"
        }, {
          "code" : "0",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "1",
          "type" : "InlinedCode"
        }, {
          "text" : " characters in the string.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# let x = of_string \"100\"\nval x : t = 100",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "A feature of the ",
          "type" : "SimpleText"
        }, {
          "code" : "Bits",
          "type" : "InlinedCode"
        }, {
          "text" : " module (but not ",
          "type" : "SimpleText"
        }, {
          "code" : "Signal",
          "type" : "InlinedCode"
        }, {
          "text" : "s) is the ability to convert",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "back to an OCaml value. We can do so with the ",
          "type" : "SimpleText"
        }, {
          "code" : "to_unsigned_int",
          "type" : "InlinedCode"
        }, {
          "text" : " function.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# to_unsigned_int x\n- : int = 4",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "to_unsigned_int",
          "type" : "InlinedCode"
        }, {
          "text" : " has interpreted ",
          "type" : "SimpleText"
        }, {
          "code" : "x",
          "type" : "InlinedCode"
        }, {
          "text" : " as an unsigned, three-bit integer value.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "code" : "to_signed_int",
          "type" : "InlinedCode"
        }, {
          "text" : " will treat it as a signed, twos-complement integer value.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# to_signed_int x\n- : int = -4",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "If the resulting value cannot fit in an integer then the functions will raise.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "code" : "to_int_trunc",
          "type" : "InlinedCode"
        }, {
          "text" : " may be useful in such cases if used carefully.",
          "type" : "SimpleText"
        } ]
      } ]
    }, {
      "id" : "richer-constants",
      "additionalIds" : [ ],
      "title" : "Richer Constants",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Probably the most useful constant-generating functions are ",
          "type" : "SimpleText"
        }, {
          "code" : "of_unsigned_int",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "of_signed_int",
          "type" : "InlinedCode"
        }, {
          "text" : ":",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# of_unsigned_int ~width:10 514\n- : t = 1000000010",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "If the given value is negative, it will be sign extended to the appropriate width:",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# of_signed_int ~width:10 (-1)\n- : t = 1111111111",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Values too large or too small to be represented in ",
          "type" : "SimpleText"
        }, {
          "code" : "width",
          "type" : "InlinedCode"
        }, {
          "text" : " bits will raise an exception.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "code" : "of_int_trunc",
          "type" : "InlinedCode"
        }, {
          "text" : " will silently truncate the input value. Variants for ",
          "type" : "SimpleText"
        }, {
          "code" : "Int32.t",
          "type" : "InlinedCode"
        }, {
          "text" : " and",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "code" : "Int64.t",
          "type" : "InlinedCode"
        }, {
          "text" : " are also provided.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The function ",
          "type" : "SimpleText"
        }, {
          "code" : "of_string",
          "type" : "InlinedCode"
        }, {
          "text" : " is actually more general than just converting",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "binary values. It can also parse a specification string which roughly",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "follows the Verilog constant format: ",
          "type" : "SimpleText"
        }, {
          "code" : "<width>'<format><value>",
          "type" : "InlinedCode"
        }, {
          "text" : ".",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "Binary (",
          "type" : "SimpleText"
        }, {
          "code" : "b",
          "type" : "InlinedCode"
        }, {
          "text" : "), decimal (",
          "type" : "SimpleText"
        }, {
          "code" : "d",
          "type" : "InlinedCode"
        }, {
          "text" : "), octal (",
          "type" : "SimpleText"
        }, {
          "code" : "o",
          "type" : "InlinedCode"
        }, {
          "text" : "), and hexadecimal (",
          "type" : "SimpleText"
        }, {
          "code" : "h",
          "type" : "InlinedCode"
        }, {
          "text" : ") notations are",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "supported.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# of_string \"5'b1101\"\n- : t = 01101\n# of_string \"5'hd\"\n- : t = 01101\n# of_string \"5'd13\"\n- : t = 01101",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "If the format specifier is capitalized, the leading bit in the given",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "value will be used for sign extension (only relevant for the",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "binary, octal, and hex specifiers).",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# of_string \"5'B1101\"\n- : t = 11101\n# of_string \"5'Hd\"\n- : t = 11101",
        "lineNumber" : "",
        "type" : "Snippet"
      } ]
    }, {
      "id" : "operators-widths-and-their-names",
      "additionalIds" : [ ],
      "title" : "Operators, Widths, and Their Names",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Hardcaml provides a set of operators providing the usual functions",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "such as logical, arithmetic and comparison operations. A key API",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "design point is Hardcaml does not encode signedness into the type of",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "vectors. Instead, the operator suffix indicates how to interpret",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "the operands. For example, there are two \"less than\" operators.",
          "type" : "SimpleText"
        } ]
      }, {
        "bulletMarker" : "-",
        "tight" : true,
        "type" : "BulletList",
        "content" : [ {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "Operators ending with ",
              "type" : "SimpleText"
            }, {
              "code" : "+",
              "type" : "InlinedCode"
            }, {
              "text" : " treat operands as signed",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "Operators ending with ",
              "type" : "SimpleText"
            }, {
              "code" : ":",
              "type" : "InlinedCode"
            }, {
              "text" : " treat operands as unsigned",
              "type" : "SimpleText"
            } ]
          } ]
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "For example, there are two distinct \"less than\" operators:",
          "type" : "SimpleText"
        } ]
      }, {
        "bulletMarker" : "-",
        "tight" : true,
        "type" : "BulletList",
        "content" : [ {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "(<+)",
              "type" : "InlinedCode"
            }, {
              "text" : " for signed less than",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "(<:)",
              "type" : "InlinedCode"
            }, {
              "text" : " for unsigned less than",
              "type" : "SimpleText"
            } ]
          } ]
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Many operators are agnostic to signedness. The addition operator ",
          "type" : "SimpleText"
        }, {
          "code" : "(+:)",
          "type" : "InlinedCode"
        }, {
          "text" : " is an example of",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "this. Addition requires both arguments to have the same bit width (otherwise it raises a",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "runtime exception), and the bit-by-bit addition process produces identical results whether",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "the values are interpreted as signed or unsigned. The carry behavior is the same; only the",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "semantic interpretation of the result differs.",
          "type" : "SimpleText"
        } ]
      } ]
    }, {
      "id" : "api-tour",
      "additionalIds" : [ ],
      "title" : "API Tour",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The following describes several key functions. See the",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "documentation for",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "url" : "https://ocaml.org/p/hardcaml/latest/doc/Hardcaml/Comb/module-type-S/index.html",
          "isFile" : false,
          "type" : "Link",
          "content" : [ {
            "code" : "Comb.S",
            "type" : "InlinedCode"
          } ]
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "for other useful functions.",
          "type" : "SimpleText"
        } ]
      }, {
        "id" : "api-tour-arithmetic",
        "additionalIds" : [ "arithmetic" ],
        "level" : 2,
        "title" : "Arithmetic",
        "type" : "SubHeading"
      }, {
        "bulletMarker" : "-",
        "tight" : true,
        "type" : "BulletList",
        "content" : [ {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "(+:)",
              "type" : "InlinedCode"
            }, {
              "text" : " addition",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "(-:)",
              "type" : "InlinedCode"
            }, {
              "text" : " subtraction",
              "type" : "SimpleText"
            } ]
          } ]
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Both arguments must be the same width. The result will be the width of",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "the arguments.",
          "type" : "SimpleText"
        } ]
      }, {
        "bulletMarker" : "-",
        "tight" : true,
        "type" : "BulletList",
        "content" : [ {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "(*:)",
              "type" : "InlinedCode"
            }, {
              "text" : " unsigned multiplication",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "(*+)",
              "type" : "InlinedCode"
            }, {
              "text" : " signed multiplication",
              "type" : "SimpleText"
            } ]
          } ]
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The arguments can have arbitrary widths. The result will be the sum",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "of the widths of the arguments.",
          "type" : "SimpleText"
        } ]
      }, {
        "id" : "api-tour-logical",
        "additionalIds" : [ "logical" ],
        "level" : 2,
        "title" : "Logical",
        "type" : "SubHeading"
      }, {
        "bulletMarker" : "-",
        "tight" : true,
        "type" : "BulletList",
        "content" : [ {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "(&:)",
              "type" : "InlinedCode"
            }, {
              "text" : " logical and",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "(|:)",
              "type" : "InlinedCode"
            }, {
              "text" : " logical or",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "(^:)",
              "type" : "InlinedCode"
            }, {
              "text" : " logical xor",
              "type" : "SimpleText"
            } ]
          } ]
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Both arguments must be the same width. The result will be the width of",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "the arguments.",
          "type" : "SimpleText"
        } ]
      }, {
        "bulletMarker" : "-",
        "tight" : true,
        "type" : "BulletList",
        "content" : [ {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "(~:)",
              "type" : "InlinedCode"
            }, {
              "text" : " logical not",
              "type" : "SimpleText"
            } ]
          } ]
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The result will be the width of the argument.",
          "type" : "SimpleText"
        } ]
      }, {
        "id" : "api-tour-comparison",
        "additionalIds" : [ "comparison" ],
        "level" : 2,
        "title" : "Comparison",
        "type" : "SubHeading"
      }, {
        "bulletMarker" : "-",
        "tight" : true,
        "type" : "BulletList",
        "content" : [ {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "(==:)",
              "type" : "InlinedCode"
            }, {
              "text" : " equals",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "(<>:)",
              "type" : "InlinedCode"
            }, {
              "text" : " not equals",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "(<:)",
              "type" : "InlinedCode"
            }, {
              "text" : ", ",
              "type" : "SimpleText"
            }, {
              "code" : "(<=:)",
              "type" : "InlinedCode"
            }, {
              "text" : ", ",
              "type" : "SimpleText"
            }, {
              "code" : "(>:)",
              "type" : "InlinedCode"
            }, {
              "text" : ", ",
              "type" : "SimpleText"
            }, {
              "code" : "(>=:)",
              "type" : "InlinedCode"
            }, {
              "text" : " unsigned comparisons",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "(<+)",
              "type" : "InlinedCode"
            }, {
              "text" : ", ",
              "type" : "SimpleText"
            }, {
              "code" : "(<=+)",
              "type" : "InlinedCode"
            }, {
              "text" : ", ",
              "type" : "SimpleText"
            }, {
              "code" : "(>+)",
              "type" : "InlinedCode"
            }, {
              "text" : ", ",
              "type" : "SimpleText"
            }, {
              "code" : "(>=+)",
              "type" : "InlinedCode"
            }, {
              "text" : " signed comparisons",
              "type" : "SimpleText"
            } ]
          } ]
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Both arguments must be the same width. The result will be 1 bit.",
          "type" : "SimpleText"
        } ]
      }, {
        "id" : "api-tour-multiplexers",
        "additionalIds" : [ "multiplexers" ],
        "level" : 2,
        "title" : "Multiplexers",
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "mux2 sel t f",
          "type" : "InlinedCode"
        }, {
          "text" : " selects ",
          "type" : "SimpleText"
        }, {
          "code" : "t",
          "type" : "InlinedCode"
        }, {
          "text" : " when ",
          "type" : "SimpleText"
        }, {
          "code" : "sel",
          "type" : "InlinedCode"
        }, {
          "text" : " is high and ",
          "type" : "SimpleText"
        }, {
          "code" : "f",
          "type" : "InlinedCode"
        }, {
          "text" : " when ",
          "type" : "SimpleText"
        }, {
          "code" : "sel",
          "type" : "InlinedCode"
        }, {
          "text" : " is",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "low. ",
          "type" : "SimpleText"
        }, {
          "code" : "sel",
          "type" : "InlinedCode"
        }, {
          "text" : " should be 1 bit wide. ",
          "type" : "SimpleText"
        }, {
          "code" : "t",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "f",
          "type" : "InlinedCode"
        }, {
          "text" : " must be the same width.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "mux sel lst",
          "type" : "InlinedCode"
        }, {
          "text" : " selects the element in ",
          "type" : "SimpleText"
        }, {
          "code" : "lst",
          "type" : "InlinedCode"
        }, {
          "text" : " at position ",
          "type" : "SimpleText"
        }, {
          "code" : "sel",
          "type" : "InlinedCode"
        }, {
          "text" : ". The range",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "of ",
          "type" : "SimpleText"
        }, {
          "code" : "sel",
          "type" : "InlinedCode"
        }, {
          "text" : " must not exceed the length of ",
          "type" : "SimpleText"
        }, {
          "code" : "lst",
          "type" : "InlinedCode"
        }, {
          "text" : ". ",
          "type" : "SimpleText"
        }, {
          "code" : "lst",
          "type" : "InlinedCode"
        }, {
          "text" : " can be shorter,",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "however, and the last element in the list is logically repeated as",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "much as needed.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# List.init 4 ~f:(fun sel -> mux (of_unsigned_int ~width:2 sel) [ gnd; vdd ]);;\n- : t list = [0; 1; 1; 1]",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "id" : "api-tour-cases",
        "additionalIds" : [ "cases" ],
        "level" : 2,
        "title" : "Cases",
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The ",
          "type" : "SimpleText"
        }, {
          "code" : "cases",
          "type" : "InlinedCode"
        }, {
          "text" : " function is similar to a multiplexer in that it selects one of its inputs to",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "output. It is given a ",
          "type" : "SimpleText"
        }, {
          "code" : "select",
          "type" : "InlinedCode"
        }, {
          "text" : " signal and each case has a corresponding ",
          "type" : "SimpleText"
        }, {
          "code" : "match",
          "type" : "InlinedCode"
        }, {
          "text" : " value.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "The first case where ",
          "type" : "SimpleText"
        }, {
          "code" : "select = match",
          "type" : "InlinedCode"
        }, {
          "text" : " is output.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# let cases select =\n    cases\n        ~default:(of_unsigned_int ~width:8 10)\n        (of_unsigned_int ~width:4 select)\n        [ of_unsigned_int ~width:4 2, of_unsigned_int ~width:8 20\n        ; of_unsigned_int ~width:4 3, of_unsigned_int ~width:8 30\n        ; of_unsigned_int ~width:4 6, of_unsigned_int ~width:8 60\n        ]\n    |> to_unsigned_int\nval cases : int -> int = <fun>\n# cases 3\n- : int = 30\n# cases 6\n- : int = 60",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "If no case matches, the ",
          "type" : "SimpleText"
        }, {
          "code" : "default",
          "type" : "InlinedCode"
        }, {
          "text" : " value is output.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# cases 4\n- : int = 10",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "id" : "api-tour-select",
        "additionalIds" : [ "select" ],
        "level" : 2,
        "title" : "Select",
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "A range of bits can be extracted from the vector using ",
          "type" : "SimpleText"
        }, {
          "code" : "select",
          "type" : "InlinedCode"
        }, {
          "text" : ".",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# select (of_string \"0011000\") ~high:4 ~low:3\n- : t = 11",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The upper and lower indexes are inclusive. Selecting outside the range",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "of the input value raises.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The operator ",
          "type" : "SimpleText"
        }, {
          "code" : "(.:[,])",
          "type" : "InlinedCode"
        }, {
          "text" : " provides a nice syntax for this:",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# (of_string \"001100\").:[3,2]\n- : t = 11",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The operator ",
          "type" : "SimpleText"
        }, {
          "code" : "(.:+[, Some x])",
          "type" : "InlinedCode"
        }, {
          "text" : " can also be used similar to Verilog:",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# (of_string \"001100\").:+[3, Some 2]\n- : t = 01",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Other selection functions include ",
          "type" : "SimpleText"
        }, {
          "code" : "sel_top",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "sel_bottom",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "drop_top",
          "type" : "InlinedCode"
        }, {
          "text" : ",",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "code" : "drop_bottom",
          "type" : "InlinedCode"
        }, {
          "text" : " and a richer set of operators for special circumstances.",
          "type" : "SimpleText"
        } ]
      }, {
        "id" : "api-tour-concatenation",
        "additionalIds" : [ "concatenation" ],
        "level" : 2,
        "title" : "Concatenation",
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Vectors can be concatenated using the following functions.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# vdd @: gnd\n- : t = 10\n# concat_msb [ vdd; gnd ]\n- : t = 10\n# concat_lsb [ gnd; vdd ]\n- : t = 10",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The _msb and _lsb suffix in the functions indicates whether the head of the list",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "holds the most significant bit or least significant bit respectively.",
          "type" : "SimpleText"
        } ]
      } ]
    }, {
      "id" : "integer-arguments",
      "additionalIds" : [ ],
      "title" : "Integer Arguments",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Various operators can take an integer as their right-hand argument.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# of_string \"011\" +:. 1\n- : t = 100",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The right-hand argument will be converted to a vector by inferring the",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "required width from the left-hand argument.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Such operators are suffixed with a ",
          "type" : "SimpleText"
        }, {
          "code" : ".",
          "type" : "InlinedCode"
        }, {
          "text" : ".",
          "type" : "SimpleText"
        } ]
      } ]
    }, {
      "id" : "richer-operations-on-vectors",
      "additionalIds" : [ ],
      "title" : "Richer Operations on Vectors",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The functions on vectors described so far form a small subset of the full API provided by",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "Hardcaml. However, all the other functions are expressed in terms of this subset.",
          "type" : "SimpleText"
        } ]
      }, {
        "id" : "richer-operations-on-vectors-splitting",
        "additionalIds" : [ "splitting" ],
        "level" : 2,
        "title" : "Splitting",
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "split_lsb",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "split_msb",
          "type" : "InlinedCode"
        }, {
          "text" : " split a vector into multiple parts. ",
          "type" : "SimpleText"
        }, {
          "code" : "part_width",
          "type" : "InlinedCode"
        }, {
          "text" : " defines the",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "width of each part. By default the original vector must be exactly divisible by",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "code" : "part_width",
          "type" : "InlinedCode"
        }, {
          "text" : ".",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# split_lsb ~part_width:4 (of_string \"16'H4321\")\n- : t list = [0001; 0010; 0011; 0100]",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "lang" : "ocaml",
        "snippet" : "# split_msb ~part_width:4 ~exact:false (of_string \"15'H4321\")\n- : t list = [1000; 0110; 0100; 001]",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "id" : "richer-operations-on-vectors-shifting",
        "additionalIds" : [ "shifting" ],
        "level" : 2,
        "title" : "Shifting",
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "sll",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "srl",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "sra",
          "type" : "InlinedCode"
        }, {
          "text" : " shift a vector by a constant amount.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "rotr",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "rotl",
          "type" : "InlinedCode"
        }, {
          "text" : " rotate by a constant amount.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "log_shift",
          "type" : "InlinedCode"
        }, {
          "text" : " builds a variable width shift circuit.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# sra (of_string \"10\") ~by:1\n- : t = 11\n# log_shift (of_string \"0100\") ~f:rotl ~by:(of_string \"10\")\n- : t = 0001",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "id" : "richer-operations-on-vectors-resizing",
        "additionalIds" : [ "resizing" ],
        "level" : 2,
        "title" : "Resizing",
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "uresize",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "sresize",
          "type" : "InlinedCode"
        }, {
          "text" : " resize a vector to the given width which may be larger or smaller.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "When growing larger ",
          "type" : "SimpleText"
        }, {
          "code" : "uresize",
          "type" : "InlinedCode"
        }, {
          "text" : " adds 0's at the top while ",
          "type" : "SimpleText"
        }, {
          "code" : "sresize",
          "type" : "InlinedCode"
        }, {
          "text" : " repeats the msb.",
          "type" : "SimpleText"
        } ]
      }, {
        "id" : "richer-operations-on-vectors-reductions",
        "additionalIds" : [ "reductions" ],
        "level" : 2,
        "title" : "Reductions",
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "reduce",
          "type" : "InlinedCode"
        }, {
          "text" : " takes a list of vectors and an operation to perform between them all.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Or reduction:",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# reduce ~f:(|:) (bits_lsb (of_string \"00100\"))\n- : t = 1",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Summation",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# reduce ~f:(+:) (List.map [1;3;5;6] ~f:(of_unsigned_int ~width:6))\n- : t = 001111",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "tree",
          "type" : "InlinedCode"
        }, {
          "text" : " does much the same thing as ",
          "type" : "SimpleText"
        }, {
          "code" : "reduce",
          "type" : "InlinedCode"
        }, {
          "text" : ", except it forms the computation in a tree",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "structure. Additional, the operation it performs can take more than 2 arguments as",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "specified by an ",
          "type" : "SimpleText"
        }, {
          "code" : "arity",
          "type" : "InlinedCode"
        }, {
          "text" : " value.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# tree ~arity:4 (of_string \"111111\" |> bits_lsb)\n    ~f:(function [a] -> a\n               | [a;b] -> a &: b\n               | [a;b;c] -> a &: b &: c\n               | [a;b;c;d] -> a &: b &: c &: d\n               | _ -> failwith \"impossible\")\n- : t = 1",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "We commonly use ",
          "type" : "SimpleText"
        }, {
          "code" : "tree",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "reduce",
          "type" : "InlinedCode"
        }, {
          "text" : " together.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# tree ~arity:4 (of_string \"111111\" |> bits_lsb) ~f:(reduce ~f:(&:))\n- : t = 1",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "id" : "richer-operations-on-vectors-with_valid",
        "additionalIds" : [ "with_valid" ],
        "level" : 2,
        "title" : "With_valid",
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "With_valid",
          "type" : "InlinedCode"
        }, {
          "text" : " is a record type with a 1 bit ",
          "type" : "SimpleText"
        }, {
          "code" : "valid",
          "type" : "InlinedCode"
        }, {
          "text" : " signal and an arbitrary ",
          "type" : "SimpleText"
        }, {
          "code" : "value",
          "type" : "InlinedCode"
        }, {
          "text" : " signal.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "It is meant to work a little like an Option type where ",
          "type" : "SimpleText"
        }, {
          "code" : "valid=0",
          "type" : "InlinedCode"
        }, {
          "text" : " means ",
          "type" : "SimpleText"
        }, {
          "code" : "None ",
          "type" : "InlinedCode"
        }, {
          "text" : "and",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "code" : "valid=1",
          "type" : "InlinedCode"
        }, {
          "text" : " means ",
          "type" : "SimpleText"
        }, {
          "code" : "Some value",
          "type" : "InlinedCode"
        } ]
      }, {
        "id" : "richer-operations-on-vectors-priority-based-selectors",
        "additionalIds" : [ "priority-based-selectors" ],
        "level" : 2,
        "title" : "Priority based selectors",
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "priority_select",
          "type" : "InlinedCode"
        }, {
          "text" : " takes a list of ",
          "type" : "SimpleText"
        }, {
          "code" : "With_valids",
          "type" : "InlinedCode"
        }, {
          "text" : " and returns the first one whose ",
          "type" : "SimpleText"
        }, {
          "code" : "valid",
          "type" : "InlinedCode"
        }, {
          "text" : " is",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "high. It returns a single ",
          "type" : "SimpleText"
        }, {
          "code" : "With_valid",
          "type" : "InlinedCode"
        }, {
          "text" : " whose valid is low if no case was selected.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "priority_select_with_default",
          "type" : "InlinedCode"
        }, {
          "text" : " adds a default value which is output if no case is",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "selected.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# priority_select_with_default \n    ~default:(of_string \"1111\") \n    [ { valid = gnd; value = of_string \"0001\" }\n    ; { valid = gnd; value = of_string \"0100\" }\n    ]\n- : t = 1111\n# priority_select_with_default \n    ~default:(of_string \"1111\") \n    [ { valid = vdd; value = of_string \"0001\" }\n    ; { valid = vdd; value = of_string \"0100\" }\n    ]\n- : t = 0001",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "id" : "richer-operations-on-vectors-counting-bits",
        "additionalIds" : [ "counting-bits" ],
        "level" : 2,
        "title" : "Counting bits",
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "popcount",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "leading_zeros",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "leading_ones",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "trailing_zeros",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "trailing_ones",
          "type" : "InlinedCode"
        }, {
          "text" : " all count",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "some number of bits within a vector. Their implementations are tree based and have ",
          "type" : "SimpleText"
        }, {
          "code" : "log width",
          "type" : "InlinedCode"
        }, {
          "text" : " logic depth.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# popcount (of_string \"1100011\")\n- : t = 100\n# trailing_zeros (of_string \"1110010100\")\n- : t = 0010",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "id" : "richer-operations-on-vectors-onehot-and-gray",
        "additionalIds" : [ "onehot-and-gray" ],
        "level" : 2,
        "title" : "Onehot and Gray",
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "binary_to_onehot",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "onehot_to_binary",
          "type" : "InlinedCode"
        }, {
          "text" : " convert between onehot and binary",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "representations.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Similarly for ",
          "type" : "SimpleText"
        }, {
          "code" : "gray_to_binary",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "binary_to_gray",
          "type" : "InlinedCode"
        }, {
          "text" : ".",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# binary_to_onehot (of_string \"110\")\n- : t = 01000000\n# onehot_to_binary (of_string \"01000\")\n- : t = 011\n# binary_to_gray (of_string \"110\")\n- : t = 101\n# gray_to_binary (of_string \"01000\")\n- : t = 01111",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "id" : "richer-operations-on-vectors-random",
        "additionalIds" : [ "random" ],
        "level" : 2,
        "title" : "Random",
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "random",
          "type" : "InlinedCode"
        }, {
          "text" : " creates a random constant vector of the given width. Mostly useful for",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "testbenches.",
          "type" : "SimpleText"
        } ]
      }, {
        "id" : "richer-operations-on-vectors-bits-set",
        "additionalIds" : [ "bits-set" ],
        "level" : 2,
        "title" : "Bits set",
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "any_bits_set",
          "type" : "InlinedCode"
        }, {
          "text" : " is equivalent to ",
          "type" : "SimpleText"
        }, {
          "code" : "x <>:. 0",
          "type" : "InlinedCode"
        }, {
          "text" : ".",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "all_bits_set",
          "type" : "InlinedCode"
        }, {
          "text" : "is equivalent to ",
          "type" : "SimpleText"
        }, {
          "code" : "x ==:. (-1)",
          "type" : "InlinedCode"
        }, {
          "text" : ".",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "no_bits_set",
          "type" : "InlinedCode"
        }, {
          "text" : " is equivalent to ",
          "type" : "SimpleText"
        }, {
          "code" : "x ==:. 0",
          "type" : "InlinedCode"
        }, {
          "text" : ".",
          "type" : "SimpleText"
        } ]
      }, {
        "id" : "richer-operations-on-vectors-with_zero_width",
        "additionalIds" : [ "with_zero_width" ],
        "level" : 2,
        "title" : "With_zero_width",
        "headingContent" : [ {
          "code" : "With_zero_width",
          "type" : "InlinedCode"
        } ],
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "We disallow zero width vectors in Hardcaml. ",
          "type" : "SimpleText"
        }, {
          "code" : "With_zero_width",
          "type" : "InlinedCode"
        }, {
          "text" : " allows us to represent them.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "The type is ",
          "type" : "SimpleText"
        }, {
          "code" : "Comb.t option",
          "type" : "InlinedCode"
        }, {
          "text" : " where ",
          "type" : "SimpleText"
        }, {
          "code" : "None",
          "type" : "InlinedCode"
        }, {
          "text" : " indicates zero width.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The functions provided try to do sane things with zero width vectors.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "# With_zero_width.(concat_msb [ None; ones 2; zero 0; zero 1; Some (of_string \"1101\") ])\n- : With_zero_width.t = Base.Option.Some 1101101",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "id" : "richer-operations-on-vectors-typedmath",
        "additionalIds" : [ "typedmath" ],
        "level" : 2,
        "title" : "TypedMath",
        "type" : "SubHeading"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "Unsigned",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "Signed",
          "type" : "InlinedCode"
        }, {
          "text" : " are modules with signature ",
          "type" : "SimpleText"
        }, {
          "code" : "TypedMath",
          "type" : "InlinedCode"
        }, {
          "text" : ". They provide arithmetic",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "and comparison operators. Since they know the signedness of the type, they can, for",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "example, add or compare vectors of different widths.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Additionally, addition and subtraction grow their result width by one bit to ensure",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "overflow is impossible. This extra bit captures the carry that might result from the",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "operation.",
          "type" : "SimpleText"
        } ]
      } ]
    } ],
    "lastModifiedTime" : 1750709443497,
    "tocItem" : {
      "chapterTitle" : "Designing Circuits",
      "pageTitle" : "2.1 Combinational Logic",
      "pageMeta" : {
        "parent" : [ "designing_circuits.mdx" ],
        "title" : [ "2.1 Combinational Logic" ],
        "uuid" : [ "c7e1f2e0-5606-347e-65e3-382d91c00c2f" ]
      },
      "dirName" : "designing-circuits",
      "fileName" : "combinational_logic",
      "fileExtension" : "md",
      "viewOnRelativePath" : null,
      "pageSectionIdTitles" : [ {
        "title" : "Vectors and Widths",
        "id" : "vectors-and-widths",
        "customAnchorId" : "vectors-and-widths"
      }, {
        "title" : "Binary Constants and Converting to OCaml Ints",
        "id" : "binary-constants-and-converting-to-ocaml-ints",
        "customAnchorId" : "binary-constants-and-converting-to-ocaml-ints"
      }, {
        "title" : "Richer Constants",
        "id" : "richer-constants",
        "customAnchorId" : "richer-constants"
      }, {
        "title" : "Operators, Widths, and Their Names",
        "id" : "operators-widths-and-their-names",
        "customAnchorId" : "operators-widths-and-their-names"
      }, {
        "title" : "API Tour",
        "id" : "api-tour",
        "customAnchorId" : "api-tour"
      }, {
        "title" : "Integer Arguments",
        "id" : "integer-arguments",
        "customAnchorId" : "integer-arguments"
      }, {
        "title" : "Richer Operations on Vectors",
        "id" : "richer-operations-on-vectors",
        "customAnchorId" : "richer-operations-on-vectors"
      } ]
    }
  }
}), document.getElementById("znai"));
/*-->*/

</script>

</body>
</html>
