<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" /> 
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"> 
<title>Hardcaml: 2.2.2 T Flip Flop</title>
<link rel="stylesheet" type="text/css" href="/hardcaml-docs/static/css/katex.min.css">
<link rel="stylesheet" type="text/css" href="/hardcaml-docs/static/main.css">
<link rel="stylesheet" type="text/css" href="/hardcaml-docs/static/css/global-overrides.css">
</head>
<link rel="shortcut icon" href="/hardcaml-docs/favicon.png"type="image/ico"/>
<body class="znai-theme theme-znai-dark">
<script>(function() {
    var themeNameKey = 'znaiTheme';
    var darkThemeName = 'znai-dark';
    var lightThemeName = 'default';

    var znaiTheme = {
        changeHandlers: [],
        addChangeHandler(handler) {
            this.changeHandlers.push(handler);
        },
        removeChangeHandler(handler) {
            var idx = this.changeHandlers.indexOf(handler);
            this.changeHandlers.splice(idx, 1);
        },
        set(name) {
            this.name = name;
            document.body.className = 'znai-theme theme-' + name;

            var idx = 0;
            var len = this.changeHandlers.length;
            for (; idx < len; idx++) {
                this.changeHandlers[idx](name);
            }
        },
        setExplicitly(name) {
            storeThemeName(name);
            this.set(name);
        },
        setExplicitlyIfNotSetAlready(name) {
            const themeName = getStoredThemeName();
            if (themeName) {
                return
            }

            this.setExplicitly(name)
        },
        toggle() {
            this.setExplicitly(this.name === lightThemeName ? darkThemeName : lightThemeName)
        }
    };

    var mediaThemeName = setLightMatchMediaListenerAndGetThemeName()
    var themeName = getStoredThemeName() || mediaThemeName;
    znaiTheme.set(themeName);

    window.znaiTheme = znaiTheme;

    function getStoredThemeName() {
        return localStorage.getItem(themeNameKey);
    }

    function storeThemeName(name) {
        return localStorage.setItem(themeNameKey, name);
    }

    function setLightMatchMediaListenerAndGetThemeName() {
        if (!window.matchMedia) {
            return darkThemeName;
        }

        var lightQuery = window.matchMedia('(prefers-color-scheme: light)');
        lightQuery.addListener(function (e) {
            const newThemeName = e.matches ? lightThemeName : darkThemeName;
            znaiTheme.setExplicitly(newThemeName);
        });

        return lightQuery.matches ? lightThemeName : darkThemeName;
    }
})()</script>
<div id="znai"><div id="znai-initial-page-loading" style="margin: -20px 0 0 -20px; padding: 0 40px 40px 0; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center">
    <div></div>
</div><section id="page-content" style="max-width: 640px; margin-left: auto; margin-right: auto;">
<article>
<header><h1>T Flip Flop</h1></header>
<p>The T Toggle flip flop changes state based on a single control input When t 0 Maintains current output state When t 1 Toggles inverts the current output state The flip flop updates only on the rising edge of the clock signal This implementation includes an active low asynchronous reset which means When reset 0 Output is forced to 0 immediately regardless of clock When reset 1 Normal operation based on input Verilog VHDL Hardcaml Direct translation Idiomatic Hardcaml t t module t_flip_flop input clock reset_n t output reg q always @ posedge clock negedge reset_n begin if reset_n q &lt; 1 b0 else if t q &lt; q end endmodule library ieee use ieee std_logic_1164 all entity t_flip_flop is port clock reset_n t in std_logic q out std_logic end entity architecture rtl of t_flip_flop is signal q_int std_logic begin q &lt; q_int process clock reset_n begin if reset_n 0 then q_int &lt; 0 elsif rising_edge clock then if t 1 then q_int &lt; not q_int end if end if end process end architecture let t_flip_flop_1 clock reset_n t let q Always Variable reg Reg_spec create clock reset reset_n reset_edge Falling width 1 in Always compile if_ t q &lt; q value q &lt; q value q value let t_flip_flop_2 clock reset_n t reg_fb Reg_spec create clock reset reset_n reset_edge Falling width 1 enable t f</p>
</article>
</section>
<section id="table-of-contents" style="max-width: 640px; margin-left: auto; margin-right: auto;">
<article>
<a href="/hardcaml-docs/introduction/why/">1.1 Why Hardcaml</a>
</article>

<article>
<a href="/hardcaml-docs/introduction/installing_with_opam/">1.2 Installing the Opensource Release</a>
</article>

<article>
<a href="/hardcaml-docs/introduction/quick_overview/">1.3 Quick Overview</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/combinational_logic/">2.1 Combinational Logic</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/rom/">2.1.1 ROM</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/mux4/">2.1.2 Mux4</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/priority_encoder/">2.1.3 Priority Encoder</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/parity/">2.1.4 Parity</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/alu/">2.1.5 ALU</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/sequential_logic/">2.2 Sequential Logic</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/jk_flip_flop/">2.2.1 JK Flip Flop</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/t_flip_flop/">2.2.2 T Flip Flop</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/d_flip_flop/">2.2.3 D Flip Flop</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/ring_counter/">2.2.4 Ring Counter</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/mobius_counter/">2.2.5 Mobius Counter</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/modulo_n_counter/">2.2.6 Modulo N Counter</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/gray_counter/">2.2.7 Gray Counter</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/bidirectional_shift_reg/">2.2.8 Bidirectional Shift Register</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/single_port_ram/">2.2.9 Single Port RAM</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/sync_fifo/">2.2.10 Synchronous FIFO</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/circuits/">2.3 Circuits</a>
</article>

<article>
<a href="/hardcaml-docs/designing-circuits/rtl_generation/">2.4 RTL Generation</a>
</article>

<article>
<a href="/hardcaml-docs/simulating-circuits/simulation/">3.1 Simulating with Cyclesim</a>
</article>

<article>
<a href="/hardcaml-docs/simulating-circuits/waveforms/">3.2 Waveforms</a>
</article>

<article>
<a href="/hardcaml-docs/simulating-circuits/waveterm_interactive_viewer/">3.3 Interactive Viewer</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/naming/">4.1 Naming</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/always/">4.2 Always DSL</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/binary_coded_decimal/">4.2.1 BCD Conversion</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/cylon_eye/">4.2.2 Cylon Eye</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/state_machine_always_api/">4.3 Designing State Machines</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/sequence_detector/">4.3.1 Sequence Detector</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/double_dabble/">4.3.2 Double Dabble</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/instantiation/">4.4 Instantiation</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/structural/">4.5 Working with Structural</a>
</article>

<article>
<a href="/hardcaml-docs/more-on-circuit-design/conversion-to-rtl/">4.6 How Hardcaml Converts Signals</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/hardcaml_interfaces/">5.1 Hardcaml Interfaces</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/interfaces_with_ppx_hardcaml/">5.2 Interfaces with ppx_hardcaml</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/module_interfaces/">5.3 Module Interfaces</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/simulating_with_interfaces/">5.4 Simulating with Interfaces</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/enums_in_hardcaml/">5.5 Enums in Hardcaml</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/typed_alu/">5.5.1 Typed ALU</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/scopes/">5.6 Scopes</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/module_hierarchies/">5.7 Module Hierarchies</a>
</article>

<article>
<a href="/hardcaml-docs/using-interfaces/naming_with_ppx_hardcaml/">5.8 Naming with ppx_hardcaml</a>
</article>

<article>
<a href="/hardcaml-docs/examples/counter/">6.1 Counter</a>
</article>

<article>
<a href="/hardcaml-docs/examples/serial_multiplier/">6.2 Serial Multipler</a>
</article>

<article>
<a href="/hardcaml-docs/examples/fibonacci_numbers/">6.3 Fibonacci Numbers</a>
</article>

<article>
<a href="/hardcaml-docs/examples/fft/">6.4 FFT</a>
</article>

<article>
<a href="/hardcaml-docs/examples/binary_search/">6.5 Binary Search</a>
</article>

<article>
<a href="/hardcaml-docs/examples/quicksort/">6.6 Quicksort</a>
</article>

<article>
<a href="/hardcaml-docs/libraries/high_performance_simulation_backends/">7.1 High Performance Simulation Backends</a>
</article>
</section>
</div>
<script type="text/javascript" src="/hardcaml-docs/footer.js"></script>
<script type="text/javascript" src="/hardcaml-docs/toc.js"></script>
<script type="text/javascript" src="/hardcaml-docs/assets.js"></script>
<script type="module" src="/hardcaml-docs/static/main.js"></script>
<script type="module" src="/hardcaml-docs/search-index.js"></script>
<script type="module">
document.getElementById('znai').innerHTML = '';
/*<!--*/
window.ReactDOM.render(React.createElement(Documentation, {
  "docMeta" : {
    "viewOn" : {
      "link" : "https://github.com/janestreet/hardcaml",
      "title" : "View Source"
    },
    "id" : "hardcaml-docs",
    "title" : "Hardcaml",
    "type" : "",
    "previewEnabled" : false
  },
  "page" : {
    "type" : "Page",
    "content" : [ {
      "id" : "t-flip-flop",
      "additionalIds" : [ ],
      "title" : "T Flip Flop",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The T (Toggle) flip-flop changes state based on a single control input ",
          "type" : "SimpleText"
        }, {
          "code" : "t",
          "type" : "InlinedCode"
        }, {
          "text" : ":",
          "type" : "SimpleText"
        } ]
      }, {
        "bulletMarker" : "-",
        "tight" : true,
        "type" : "BulletList",
        "content" : [ {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "When t=0: Maintains current output state",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "When t=1: Toggles (inverts) the current output state",
              "type" : "SimpleText"
            } ]
          } ]
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The flip-flop updates only on the rising edge of the clock signal. This implementation",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "includes an active low asynchronous reset, which means:",
          "type" : "SimpleText"
        } ]
      }, {
        "bulletMarker" : "-",
        "tight" : true,
        "type" : "BulletList",
        "content" : [ {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "When reset=0: Output is forced to 0 immediately, regardless of clock",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "When reset=1: Normal operation based on ",
              "type" : "SimpleText"
            }, {
              "code" : "t",
              "type" : "InlinedCode"
            }, {
              "text" : " input",
              "type" : "SimpleText"
            } ]
          } ]
        } ]
      }, {
        "id" : "t-flip-flop-verilog",
        "additionalIds" : [ "verilog" ],
        "level" : 2,
        "title" : "Verilog",
        "type" : "SubHeading"
      }, {
        "lang" : "verilog",
        "snippet" : "module t_flip_flop (\n  input clock, reset_n, t,\n  output reg q\n);\n\n  always @(posedge clock, negedge reset_n) begin\n    if (!reset_n)\n      q <= 1'b0;\n    else if (t)\n      q <= ~q;\n  end\n\nendmodule",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "id" : "t-flip-flop-vhdl",
        "additionalIds" : [ "vhdl" ],
        "level" : 2,
        "title" : "VHDL",
        "type" : "SubHeading"
      }, {
        "lang" : "vhdl",
        "snippet" : "library ieee;\nuse ieee.std_logic_1164.all;\n\nentity t_flip_flop is\n  port (\n    clock, reset_n, t : in std_logic;\n    q : out std_logic\n  );\nend entity;\n\narchitecture rtl of t_flip_flop is \n  signal q_int : std_logic;\nbegin\n\n  q <= q_int;\n  \n  process (clock, reset_n) begin\n    if reset_n = '0' then \n      q_int <= '0';\n    elsif rising_edge(clock) then\n      if t = '1' then\n        q_int <= not q_int;\n      end if;\n    end if;\n  end process;\n\nend architecture;",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "id" : "t-flip-flop-hardcaml",
        "additionalIds" : [ "hardcaml" ],
        "level" : 2,
        "title" : "Hardcaml",
        "type" : "SubHeading"
      }, {
        "id" : "t-flip-flop-hardcaml-direct-translation",
        "additionalIds" : [ "direct-translation" ],
        "level" : 3,
        "title" : "Direct translation",
        "type" : "SubHeading"
      }, {
        "lang" : "ocaml",
        "snippet" : "let t_flip_flop_1 ~clock ~reset_n ~t =\n  let q =\n    Always.Variable.reg\n      (Reg_spec.create ~clock ~reset:reset_n ~reset_edge:Falling ())\n      ~width:1\n  in\n  Always.(compile [ if_ t [ q <-- ~:(q.value) ] [ q <-- q.value ] ]);\n  q.value\n;;",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "id" : "t-flip-flop-hardcaml-idiomatic-hardcaml",
        "additionalIds" : [ "idiomatic-hardcaml" ],
        "level" : 3,
        "title" : "Idiomatic Hardcaml",
        "type" : "SubHeading"
      }, {
        "lang" : "ocaml",
        "snippet" : "let t_flip_flop_2 ~clock ~reset_n ~t =\n  reg_fb\n    (Reg_spec.create ~clock ~reset:reset_n ~reset_edge:Falling ())\n    ~width:1\n    ~enable:t\n    ~f:( ~: )\n;;",
        "lineNumber" : "",
        "type" : "Snippet"
      } ]
    } ],
    "lastModifiedTime" : 1750709443963,
    "tocItem" : {
      "chapterTitle" : "Designing Circuits",
      "pageTitle" : "2.2.2 T Flip Flop",
      "pageMeta" : {
        "parent" : [ "sequential_logic.mdx" ],
        "title" : [ "2.2.2 T Flip Flop" ],
        "uuid" : [ "50028be6-12e9-3c32-c0a3-0030dab394af" ]
      },
      "dirName" : "designing-circuits",
      "fileName" : "t_flip_flop",
      "fileExtension" : "md",
      "viewOnRelativePath" : null,
      "pageSectionIdTitles" : [ {
        "title" : "T Flip Flop",
        "id" : "t-flip-flop",
        "customAnchorId" : "t-flip-flop"
      } ]
    }
  }
}), document.getElementById("znai"));
/*-->*/

</script>

</body>
</html>
