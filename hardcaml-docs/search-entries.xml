<znai>
  <entry>
    <url>/hardcaml-docs/introduction/why#ways-to-design-hardware</url>
    <fullTitle>Hardcaml: 1.1 Why Hardcaml, Ways to Design Hardware [Introduction]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Most commonly hardware is designed using System Verilog or VHDL Both are called hardware description languages HDLs and provide features to both write and test a hardware design Each language exposes a subset which is called synthesizable i e able to be turned into hardware The full language can only be used for testing A more recent alternative is High Level Synthesis HLS Here hardware designs are expressed in C or C there may be other hosting languages available but these are by far the most common and a sophisticated compiler generates an equivalent hardware design Notably the exact cycle by cycle timing of the circuit is not specified by the designer and is left up to the compiler The designer can add various pragmas to guide the compiler s choices in order to come up with a suitable hardware design that meets performance area or frequency requirements Finally we come to Hardware Construction Languages HCLs the class to which Hardcaml belongs Chisel Clash MyHDL PyMtl and SpinalHDL are other examples of HCLs Here hardware designs are described at a structural level within a standard software programming language Various tooling is provided to test your designs or convert them to an HDL</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/introduction/why#why-use-hardcaml</url>
    <fullTitle>Hardcaml: 1.1 Why Hardcaml, Why use Hardcaml? [Introduction]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Hardcaml is an OCaml library Hardcaml designs are programs written in OCaml When a Hardcaml program executes it builds a data structure representing the hardware design the user describes From there Hardcaml can convert it to a standard HDL build a simulation model for testing among various other capabilities we will discuss in this documentation In terms of expressing our hardware designs Hardcaml and other HCLs are able to describe the same circuits as normal HDLs like Verilog Similarly if you can express it in Hardcaml then you can also do so in Verilog Hardware architecture and design knowledge is transferable between these worlds When we describe hardware using Hardcaml we are performing a task called meta programming This means we are writing a program to generate something in this case a special representation of hardware that Hardcaml understands There are a number of advantages to this approach here are a few Reuse standard OCaml tooling i e editor integration continuous integration Easily create highly parameterized designs This means we can often write a design once but instantiate it multiple different ways to suit different requirements Leverage the powerful OCaml type system to enforce invariants on our types Use standard software libraries across our hardware designs and testing frameworks Quickcheck for testing is a hugely useful example There are some downsides of course Generated HDL code for use with vendor tooling like Vivado or Quartus is computer generated and nothing like what a human would write Hardcaml makes up names in generated code that look like This isn t very helpful when reading the logs from vendor tools We have some tricks we can play here to make things a bit easier Of course the above is all a matter of opinion and you should make up your own _8277</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/introduction/installing_with_opam</url>
    <fullTitle>Hardcaml: 1.2 Installing the Opensource Release,  [Introduction]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Hardcaml can be installed with opam I recommend the following packages to get started This will install the core Hardcaml library a waveform viewer which is helpful for building tests and the hardcaml ppx To access the latest packages or the most up to date version you may want to try the Jane Street bleeding edge opam repository opam install hardcaml hardcaml_waveterm ppx_hardcaml opam repo add janestreet bleeding https github com janestreet opam repository git</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/introduction/installing_with_opam#basic-usage</url>
    <fullTitle>Hardcaml: 1.2 Installing the Opensource Release, Basic Usage [Introduction]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Hardcaml can be used with utop or another OCaml top level This provides a great environment to learn the API The following utop command makes things nicer to play with #require hardcaml open Hardcaml Bits #install_printer Bits pp</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/introduction/installing_with_opam#dune</url>
    <fullTitle>Hardcaml: 1.2 Installing the Opensource Release, Dune [Introduction]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The following is an example Dune file for linking to Hardcaml library name my_hardcaml_lib libraries base hardcaml preprocess pps ppx_jane ppx_hardcaml</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/introduction/quick_overview</url>
    <fullTitle>Hardcaml: 1.3 Quick Overview,  [Introduction]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Hardcaml is a library for designing and simulating Register Transfer Level RTL hardware designs Hardcaml designs can be converted to Verilog or VHDL for use with vendor synthesis and place and route tools</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/introduction/quick_overview#library-overview</url>
    <fullTitle>Hardcaml: 1.3 Quick Overview, Library Overview [Introduction]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Comb S Bits and Signal The module type defines the combinational logic primitives i e logical operations arithmetic multiplexers etc for Hardcaml It is implemented by both the and modules All operations work over vectors with a given bit width Each operation has rules about allowable argument widths and will raise an exception at run time if violated implements a shallow embedding of the API This means it is used to compute values directly implements a deep embedding This means it records the structure of a computation as a graph Signals also provide functions related to sequential logic registers memories and state machines In summary s are used to construct hardware designs s can be used to model combinational hardware circuits conveniently As we shall see s are also used for input and output ports of hardware simulations Circuit A circuit takes the output signals of a Hardcaml design and performs various sanity checks to ensure that it can be converted to hardware In particular we must provide input and output port names for our designs Hardware generation with Rtl A circuit can be converted to RTL with Verilog or VHDL Simulation with Cyclesim Circuits can be simulated with the module Interfaces with ppx_hardcaml An interface is a grouping of signals with associated names and bit widths A large set of functions are generated which make working with interfaces useful for constructing module ports or interacting with a hardware design in simulation  The term interface is unfortunately a bit overloaded and commonly used to described mli files in OCaml a concept in Object Oriented programming and a type representing a group of signals in SystemVerilog Hardcamls use of interface is most similar to that of SystemVerilog Waveforms image will output waveforms of a simulation run as ASCII text This allows us to integrate them with standard software development style testing workflows In addition an interactive viewer application is provided for detailed analysis Comb S Bits Signal Bits Comb S # open Hardcaml Bits # let adder a b a b val adder t > t > t &lt;fun> # adder of_string 01 of_string 10 t 11 Signal # open Hardcaml Signal # open Hardcaml Signal Unoptimized # let adder a b a b val adder Type t > Type t > Type t &lt;fun> # adder of_string 01 of_string 10 Type t add width 2 arguments 0b01 0b10 Signal t Bits t Bits t # let c output c adder input a 8 input b 8 val c Type t wire names c width 8 data_in add # let circuit Hardcaml Circuit create_exn name my_adder c val circuit Hardcaml Circuit t &lt;abstr> # Hardcaml Rtl print Verilog circuit module my_adder b a c input 7 0 b input 7 0 a output 7 0 c wire 7 0 _4 assign _4 a b assign c _4 endmodule unit Cyclesim let sim Hardcaml Cyclesim create circuit let a Hardcaml Cyclesim in_port sim a let b Hardcaml Cyclesim in_port sim b let c Hardcaml Cyclesim out_port sim c a Hardcaml Bits of_unsigned_int width 8 10 b Hardcaml Bits of_unsigned_int width 8 20 Hardcaml Cyclesim cycle sim # Stdio printf c %i n Hardcaml Bits to_unsigned_int c c 30 unit # type a t a a @bits 8 b a @bits 7 @@deriving hardcaml Hardcaml_waveterm</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/introduction/quick_overview#getting-working-hardware</url>
    <fullTitle>Hardcaml: 1.3 Quick Overview, Getting Working Hardware [Introduction]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Designing hardware in Hardcaml is only part of the complete process of getting a fully working design Let s consider the typical workflow for creating a simple Xilinx FPGA design Design and simulate the circuit with Hardcaml Output a Verilog or VHDL file using Hardcaml s RTL generation functions Create a project in Vivado the Xilinx FPGA synthesis place and route tool Add board level constraints pins timing etc Synthesize place and route the design in Vivado Run static timing analysis If this fails you must correct the Hardcaml design or adjust constraints Generate a bitstream to program the FPGA For steps 1 and 2 we often use a project structure with a and directory a library containing the hardware design a test library with testbenches expect tests etc an application to generate RTL code for the Vivado toolchain bin src test src test bin</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/combinational_logic</url>
    <fullTitle>Hardcaml: 2.1 Combinational Logic,  [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Combinational logic is formed from boolean functions whose outputs are fully determined by their current inputs This is in contrast to sequential logic where the outputs are a function of their current and previous inputs At the lowest level combinational circuits are built from simple primitives such as NAND gates in ASIC designs or LUTs in FPGA designs Building circuits with such low level primitives is tedious so instead we provide a set of higher level primitives with which to design circuits The module type provides these primitives Combinational circuits can be thought of as graphs with nodes representing logic operations and edges representing often also referred to as These graphs are directed and must not contain any cycles Comb S wires signals</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/combinational_logic#vectors-and-widths</url>
    <fullTitle>Hardcaml: 2.1 Combinational Logic, Vectors and Widths [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The fundamental type in Hardcaml is a vector with a specified width The width can be one or more bits There exists a special signal called which has zero width but is rarely used and exists for internal use In Hardcaml the types and are used to represent vectors For now we will consider s The simplest way to create a value is the function Note that in both the specification of the bit vector with and the printing of the value we treat the left most 1 or 0 as the most significant bit We can now interrogate the width of this value It is always possible to get the width of a Hardcaml vector empty Signal t Bits t Bits t Bits t of_string # open Hardcaml Bits # let x of_string 11001 val x t 11001 of_string x # width x int 5</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/combinational_logic#binary-constants-and-converting-to-ocaml-ints</url>
    <fullTitle>Hardcaml: 2.1 Combinational Logic, Binary Constants and Converting to OCaml Ints [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>takes a string which consists of s and s s are also allowed and are ignored The first character in the string becomes the most significant bit msb of the vector The vector width is the sum of the number of and characters in the string A feature of the module but not s is the ability to convert back to an OCaml value We can do so with the function has interpreted as an unsigned three bit integer value will treat it as a signed twos complement integer value If the resulting value cannot fit in an integer then the functions will raise may be useful in such cases if used carefully of_string 0 1 _ 0 1 # let x of_string 100 val x t 100 Bits Signal to_unsigned_int # to_unsigned_int x int 4 to_unsigned_int x to_signed_int # to_signed_int x int 4 to_int_trunc</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/combinational_logic#richer-constants</url>
    <fullTitle>Hardcaml: 2.1 Combinational Logic, Richer Constants [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Probably the most useful constant generating functions are and If the given value is negative it will be sign extended to the appropriate width Values too large or too small to be represented in bits will raise an exception will silently truncate the input value Variants for and are also provided The function is actually more general than just converting binary values It can also parse a specification string which roughly follows the Verilog constant format Binary decimal octal and hexadecimal notations are supported If the format specifier is capitalized the leading bit in the given value will be used for sign extension only relevant for the binary octal and hex specifiers of_unsigned_int of_signed_int # of_unsigned_int width 10 514 t 1000000010 # of_signed_int width 10 1 t 1111111111 width of_int_trunc Int32 t Int64 t of_string &lt;width> &lt;format>&lt;value> b d o h # of_string 5 b1101 t 01101 # of_string 5 hd t 01101 # of_string 5 d13 t 01101 # of_string 5 B1101 t 11101 # of_string 5 Hd t 11101</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/combinational_logic#operators-widths-and-their-names</url>
    <fullTitle>Hardcaml: 2.1 Combinational Logic, Operators, Widths, and Their Names [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Hardcaml provides a set of operators providing the usual functions such as logical arithmetic and comparison operations A key API design point is Hardcaml does not encode signedness into the type of vectors Instead the operator suffix indicates how to interpret the operands For example there are two less than operators Operators ending with treat operands as signed Operators ending with treat operands as unsigned For example there are two distinct less than operators for signed less than for unsigned less than Many operators are agnostic to signedness The addition operator is an example of this Addition requires both arguments to have the same bit width otherwise it raises a runtime exception and the bit by bit addition process produces identical results whether the values are interpreted as signed or unsigned The carry behavior is the same only the semantic interpretation of the result differs &lt; &lt;</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/combinational_logic#api-tour</url>
    <fullTitle>Hardcaml: 2.1 Combinational Logic, API Tour [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The following describes several key functions See the documentation for for other useful functions Arithmetic addition subtraction Both arguments must be the same width The result will be the width of the arguments unsigned multiplication signed multiplication The arguments can have arbitrary widths The result will be the sum of the widths of the arguments Logical logical and logical or logical xor Both arguments must be the same width The result will be the width of the arguments logical not The result will be the width of the argument Comparison equals not equals unsigned comparisons signed comparisons Both arguments must be the same width The result will be 1 bit Multiplexers selects when is high and when is low should be 1 bit wide and must be the same width selects the element in at position The range of must not exceed the length of can be shorter however and the last element in the list is logically repeated as much as needed Cases The function is similar to a multiplexer in that it selects one of its inputs to output It is given a signal and each case has a corresponding value The first case where is output If no case matches the value is output Select A range of bits can be extracted from the vector using The upper and lower indexes are inclusive Selecting outside the range of the input value raises The operator provides a nice syntax for this The operator can also be used similar to Verilog Other selection functions include and a richer set of operators for special circumstances Concatenation Vectors can be concatenated using the following functions The _msb and _lsb suffix in the functions indicates whether the head of the list holds the most significant bit or least significant bit respectively Comb S * * &amp; | ^ &lt;&gt; &lt; &lt; > > &lt; &lt; > > mux2 sel t f t sel f sel sel t f mux sel lst lst sel sel lst lst # List init 4 f fun sel > mux of_unsigned_int width 2 sel gnd vdd t list 0 1 1 1 cases select match select match # let cases select cases default of_unsigned_int width 8 10 of_unsigned_int width 4 select of_unsigned_int width 4 2 of_unsigned_int width 8 20 of_unsigned_int width 4 3 of_unsigned_int width 8 30 of_unsigned_int width 4 6 of_unsigned_int width 8 60 |> to_unsigned_int val cases int > int &lt;fun> # cases 3 int 30 # cases 6 int 60 default # cases 4 int 10 select # select of_string 0011000 high 4 low 3 t 11 # of_string 001100 3 2 t 11 Some x # of_string 001100 3 Some 2 t 01 sel_top sel_bottom drop_top drop_bottom # vdd @ gnd t 10 # concat_msb vdd gnd t 10 # concat_lsb gnd vdd t 10</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/combinational_logic#integer-arguments</url>
    <fullTitle>Hardcaml: 2.1 Combinational Logic, Integer Arguments [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Various operators can take an integer as their right hand argument The right hand argument will be converted to a vector by inferring the required width from the left hand argument Such operators are suffixed with a # of_string 011 1 t 100</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/combinational_logic#richer-operations-on-vectors</url>
    <fullTitle>Hardcaml: 2.1 Combinational Logic, Richer Operations on Vectors [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The functions on vectors described so far form a small subset of the full API provided by Hardcaml However all the other functions are expressed in terms of this subset Splitting and split a vector into multiple parts defines the width of each part By default the original vector must be exactly divisible by Shifting shift a vector by a constant amount rotate by a constant amount builds a variable width shift circuit Resizing and resize a vector to the given width which may be larger or smaller When growing larger adds 0 s at the top while repeats the msb Reductions takes a list of vectors and an operation to perform between them all Or reduction Summation does much the same thing as except it forms the computation in a tree structure Additional the operation it performs can take more than 2 arguments as specified by an value We commonly use and together With_valid is a record type with a 1 bit signal and an arbitrary signal It is meant to work a little like an Option type where means and means Priority based selectors takes a list of and returns the first one whose is high It returns a single whose valid is low if no case was selected adds a default value which is output if no case is selected Counting bits all count some number of bits within a vector Their implementations are tree based and have logic depth Onehot and Gray and convert between onehot and binary representations Similarly for and Random creates a random constant vector of the given width Mostly useful for testbenches Bits set is equivalent to is equivalent to is equivalent to With_zero_width We disallow zero width vectors in Hardcaml allows us to represent them The type is where indicates zero width The functions provided try to do sane things with zero width vectors TypedMath and are modules with signature They provide arithmetic and comparison operators Since they know the signedness of the type they can for example add or compare vectors of different widths Additionally addition and subtraction grow their result width by one bit to ensure overflow is impossible This extra bit captures the carry that might result from the operation split_lsb split_msb part_width part_width # split_lsb part_width 4 of_string 16 H4321 t list 0001 0010 0011 0100 # split_msb part_width 4 exact false of_string 15 H4321 t list 1000 0110 0100 001 sll srl sra rotr rotl log_shift # sra of_string 10 by 1 t 11 # log_shift of_string 0100 f rotl by of_string 10 t 0001 uresize sresize uresize sresize reduce # reduce f | bits_lsb of_string 00100 t 1 # reduce f List map 1 3 5 6 f of_unsigned_int width 6 t 001111 tree reduce arity # tree arity 4 of_string 111111 |> bits_lsb f function a > a | a b > a &amp; b | a b c > a &amp; b &amp; c | a b c d > a &amp; b &amp; c &amp; d | _ > failwith impossible t 1 tree reduce # tree arity 4 of_string 111111 |> bits_lsb f reduce f &amp; t 1 With_valid valid value valid 0 None valid 1 Some value priority_select With_valids valid With_valid priority_select_with_default # priority_select_with_default default of_string 1111 valid gnd value of_string 0001 valid gnd value of_string 0100 t 1111 # priority_select_with_default default of_string 1111 valid vdd value of_string 0001 valid vdd value of_string 0100 t 0001 popcount leading_zeros leading_ones trailing_zeros trailing_ones log width # popcount of_string 1100011 t 100 # trailing_zeros of_string 1110010100 t 0010 binary_to_onehot onehot_to_binary gray_to_binary binary_to_gray # binary_to_onehot of_string 110 t 01000000 # onehot_to_binary of_string 01000 t 011 # binary_to_gray of_string 110 t 101 # gray_to_binary of_string 01000 t 01111 random any_bits_set x &lt;&gt; 0 all_bits_set x 1 no_bits_set x 0 With_zero_width Comb t option None # With_zero_width concat_msb None ones 2 zero 0 zero 1 Some of_string 1101 With_zero_width t Base Option Some 1101101 Unsigned Signed TypedMath</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/rom#rom</url>
    <fullTitle>Hardcaml: 2.1.1 ROM, Rom [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>8 entry ROM Outputs the address times 10 Verilog VHDL Hardcaml module rom input 2 0 address output reg 6 0 q always @* begin case address 3 d0 q &lt; 7 d0 3 d1 q &lt; 7 d10 3 d2 q &lt; 7 d20 3 d3 q &lt; 7 d30 3 d4 q &lt; 7 d40 3 d5 q &lt; 7 d50 3 d6 q &lt; 7 d60 default q &lt; 7 d70 endcase end endmodule library ieee use ieee std_logic_1164 all use ieee numeric_std all entity rom is port address in std_logic_vector 2 downto 0 q out std_logic_vector 6 downto 0 end entity architecture rtl of rom is type rom_t is array 0 to 7 of integer constant rom rom_t 0 10 20 30 40 50 60 70 begin q &lt; std_logic_vector to_unsigned rom to_integer unsigned address q length end architecture let rom address mux address List init 8 f fun i > of_unsigned_int width 7 i * 10</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/mux4#mux-4-to-1</url>
    <fullTitle>Hardcaml: 2.1.2 Mux4, Mux 4 to 1 [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>4 input multiplexer Verilog VHDL Hardcaml module mux4 input 1 0 address input 7 0 a b c d output reg 7 0 q always @* begin case address 3 d0 q &lt; a 3 d1 q &lt; b 3 d2 q &lt; c default q &lt; d endcase end endmodule library ieee use ieee std_logic_1164 all use ieee numeric_std all entity mux4 is port address in std_logic_vector 1 downto 0 a b c d in std_logic_vector 7 downto 0 q out std_logic_vector 7 downto 0 end entity architecture rtl of mux4 is signal q_int std_logic_vector 7 downto 0 begin q &lt; q_int process address a b c d is begin case to_integer unsigned address is when 0 > q_int &lt; a when 1 > q_int &lt; b when 2 > q_int &lt; c when others > q_int &lt; d end case end process end architecture let mux4 address a b c d mux address a b c d</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/priority_encoder#priority-encoder</url>
    <fullTitle>Hardcaml: 2.1.3 Priority Encoder, Priority Encoder [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Verilog VHDL Hardcaml Direct translation Idiomatic Hardcaml module priority_encoder input 3 0 sel input 7 0 a b c d output reg 7 0 q always @* begin if sel 3 q &lt; d else if sel 2 q &lt; c else if sel 1 q &lt; b else q &lt; a end endmodule library ieee use ieee std_logic_1164 all entity priority_encoder is port sel in std_logic_vector 3 downto 0 a b c d in std_logic_vector 7 downto 0 q out std_logic_vector 7 downto 0 end entity architecture rtl of priority_encoder is begin q &lt; d when sel 3 1 else c when sel 2 1 else b when sel 1 1 else a end architecture let priority_encoder_1 sel a b c d let out Always Variable wire default zero 8 in Always compile if_ sel 3 out &lt; d @@ elif sel 2 out &lt; c @@ elif sel 1 out &lt; b @@ out &lt; a out value let priority_encoder_2 sel a b c d priority_select_with_default default a With_valid valid sel 3 value d valid sel 2 value c valid sel 1 value b</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/parity#parity</url>
    <fullTitle>Hardcaml: 2.1.4 Parity, Parity [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>This module calculates odd parity for a 4 bit input Given a 4 bit input it outputs if it contains an odd number of s and otherwise Implemented by XORing all the bits together Verilog VHDL Hardcaml Direct translation of Verilog Direct translation of Vhdl Idiomatic Hardcaml When performing reductions in Hardcaml we will often use the tree function This rearranges the computation from into d 1 1 0 module parity input 3 0 d output q assign q ^d endmodule library ieee use ieee std_logic_1164 all use ieee numeric_std all entity parity is port d in std_logic_vector 3 downto 0 q out std_logic end entity architecture rtl of parity is begin process d is variable parity std_logic begin parity 0 for i in d range loop parity parity xor d i end loop q &lt; parity end process end architecture let parity_1 d reduce bits_lsb d f ^ let parity_2 d let parity ref gnd in for i 0 to width d 1 do parity parity ^ d i done parity let parity_3 d tree arity 2 bits_lsb d f reduce f ^ a ^ b ^ c ^ d a ^ b ^ c ^ d</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/alu#a-simple-8-bit-alu</url>
    <fullTitle>Hardcaml: 2.1.5 ALU, A Simple 8-bit ALU [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>A simple arithmetic logic unit It takes two 8 bit operands and and computes an 8 bit output according to the value of the operation select signal as described in the table below op fn text 0 type SimpleText text A AND B type SimpleText text 1 type SimpleText text A SUB B type SimpleText text 2 type SimpleText text A MUL B type SimpleText text 3 type SimpleText text A SHIFTLEFT 1 type SimpleText text 4 type SimpleText text A SHIFTRIGHT 1 type SimpleText text 5 type SimpleText text A AND B type SimpleText text 6 type SimpleText text A OR B type SimpleText text 7 type SimpleText text A XOR B type SimpleText text 8 type SimpleText text NOT A type SimpleText text 9 type SimpleText text 1 if A LESSTHAN B else 0 type SimpleText text 10 type SimpleText text 1 if A EQUAL B else 0 type SimpleText text otherwise type SimpleText text 0 type SimpleText Verilog VHDL Hardcaml A B q op module alu input 3 0 op input 7 0 a b output reg 7 0 q always @* begin case op 0 q &lt; a b 1 q &lt; a b 2 q &lt; a * b 3 q &lt; a &lt;&lt; 1 4 q &lt; a >> 1 5 q &lt; a &amp; b 6 q &lt; a | b 7 q &lt; a ^ b 8 q &lt; a 9 q &lt; a &lt; b 10 q &lt; a b default q &lt; 0 endcase end endmodule library ieee use ieee std_logic_1164 all use ieee numeric_std all entity alu is port op in std_logic_vector 3 downto 0 a b in std_logic_vector 7 downto 0 q out std_logic_vector 7 downto 0 end entity architecture rtl of alu is signal q_int std_logic_vector 7 downto 0 begin process op a b is variable mul std_logic_vector 15 downto 0 begin case to_integer unsigned op is when 0 > q_int &lt; std_logic_vector unsigned a unsigned b when 1 > q_int &lt; std_logic_vector unsigned a unsigned b when 2 > mul std_logic_vector unsigned a * unsigned b q_int &lt; mul 7 downto 0 when 3 > q_int &lt; std_logic_vector shift_left unsigned a 1 when 4 > q_int &lt; std_logic_vector shift_right unsigned a 1 when 5 > q_int &lt; a and b when 6 > q_int &lt; a or b when 7 > q_int &lt; a xor b when 8 > q_int &lt; not a when 9 > if unsigned a &lt; unsigned b then q_int &lt; 00000001 else q_int &lt; 00000000 end if when 10 > if a b then q_int &lt; 00000001 else q_int &lt; 00000000 end if when others > q_int &lt; others > 0 end case end process end architecture let alu op a b mux op a b a b a * b sll a by 1 srl a by 1 a &amp; b a | b a ^ b a a &lt; b a b zero 8 |> List map f uresize width 8</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/sequential_logic</url>
    <fullTitle>Hardcaml: 2.2 Sequential Logic,  [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Sequential logic is built from primitives such as registers and memories A key concept in sequential logic is the Sequential logic updates on the rising or less commonly falling edge of the clock and holds its value throughout the clock cycle clock</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/sequential_logic#reg_spec</url>
    <fullTitle>Hardcaml: 2.2 Sequential Logic, Reg_spec [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The clock and related reset and clear signals are grouped together in a type called a Multiple sequential elements are then able to refer to the same Reg_spec t # open Hardcaml # let clock Signal input clock 1 val clock Signal t wire names clock width 1 # let clear Signal input clear 1 val clear Signal t wire names clear width 1 # let spec Signal Reg_spec create clock clear val spec Signal Reg_spec t &lt;abstr> Reg_spec t</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/sequential_logic#registers-pipelines</url>
    <fullTitle>Hardcaml: 2.2 Sequential Logic, Registers, Pipelines [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>A simple register takes a signal as input and basically delays it for one cycle The pipeline function will delay its input for multiple cycles # let d_in Signal input d_in 8 val d_in Signal t wire names d_in width 8 # let q_out Signal reg spec enable Signal vdd d_in val q_out Signal t register width 8 clock clock clock_edge Rising clear clear clear_to 0b00000000 data_in d_in # let q_out_after_3_clocks Signal pipeline spec enable Signal vdd n 3 d_in val q_out_after_3_clocks Signal t register width 8 clock clock clock_edge Rising clear clear clear_to 0b00000000 data_in register</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/sequential_logic#registers-with-feedback</url>
    <fullTitle>Hardcaml: 2.2 Sequential Logic, Registers with Feedback [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>We noted previously that combinational logic could not contain cycles We can lift this restriction with sequential logic so long as the cycle passes through a register or memory The function encodes a simple example of this pattern For example to build a counter we need to access the current value to produce the next one reg_fb # let counter Signal reg_fb spec enable Signal vdd width 8 f fun d > Signal d 1 val counter Signal t register width 8 clock clock clock_edge Rising clear clear clear_to 0b00000000 data_in wire</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/sequential_logic#wires</url>
    <fullTitle>Hardcaml: 2.2 Sequential Logic, Wires [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>In Hardcaml a is a signal which can be declared before providing its input driver Logically it does nothing it just passes its input through to its output Wires can later be assigned an input driver Apart from the fact they logically do nothing they are really useful It is how the function is implemented Without wires we cannot express the above function since the input to refers to its own output Two words of caution when using wires Combinational cycles We can t stop you from creating them but we can throw an exception when you do It s worth repeating cycles must pass through a sequential primitive The hairy unassigned wire exception Hardcaml will detect when you forget to assign a value to a wire but the error will not be especially useful in finding out where You can enable an extra level of debugging information by setting the following value which will help track down where the wire was originally defined wire # let w Signal wire 1 val w Signal t wire width 1 # Signal w &lt; vdd unit # w Signal t wire width 1 data_in 0b1 reg_fb # let reg_fb spec enable w f let d Signal wire w in let q Signal reg spec enable f d in Signal d &lt; q q val reg_fb Signal Reg_spec t > enable Signal t > w int > Signal t > Signal t > Signal t &lt;fun> reg Caller_id set_mode Top_of_stack</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/sequential_logic#state-machines</url>
    <fullTitle>Hardcaml: 2.2 Sequential Logic, State Machines [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>State machines are just a complex combination of registers and multiplexers so it is possible to build them directly with the primitives described here but not very conveniently Rather we recommend using the Always DSL</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/sequential_logic#memories</url>
    <fullTitle>Hardcaml: 2.2 Sequential Logic, Memories [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Core asynchronous memory primitive Hardcaml provides the primitive for describing memory structures They are synchronously written using Each write port can have a different clock The memory is read asynchronously using The read data is returned as an array one for each read port RAMs On their own s are not that useful Instead we provide the module which can target the physical RAM blocks in FPGAs i e BlockRAM or UltraRAM in Xilinx devices This is done by instantiating a multiport_memory and a register placed on either the read address or output data Note that this means the read ports are now synchronous and read data is returned one cycle later Each read port can have a different clock For this to work we use a feature of FPGA synthesizers called RTL RAM inference This process is notoriously finicky so read the tool reports to ensure it is doing what you expect I m looking at you Vivado Practical considerations The RAM structures provided with Hardcaml are very flexible regarding the number of read and write ports they can provide Physically however FPGAs provide RAMs with 1 or 2 ports If you specify more than this you will probably not get the results you intended The library offers a more targeted solution for Xilinx FPGAs and may be more suitable for applications where precise control of the Vendor RAM primitive is required multiport_memory write_ports let clock Signal input clock 1 let address Signal input address 8 let write_enable Signal input write_enable 1 let data Signal input data 32 # let write_port Write_port write_clock clock write_address address write_enable write_enable write_data data val write_port Signal t Write_port t Hardcaml Write_port write_clock wire names clock width 1 write_address wire names address width 8 write_enable wire names write_enable width 1 write_data wire names data width 32 read_addresses # let read_address address val read_address Signal t wire names address width 8 # let q Signal multiport_memory 256 write_ports |write_port| read_addresses |read_address| val q Signal t array | memory_read_port width 32 memory multiport_memory read_addresses address | multiport_memory Ram # let read_port Read_port read_clock clock read_address read_enable Signal input read_enable 1 val read_port Signal t Read_port t Hardcaml Read_port read_clock wire names clock width 1 read_address wire names address width 8 read_enable wire names read_enable width 1 # let q Ram create collision_mode Read_before_write size 256 write_ports |write_port| read_ports |read_port| val q Signal t array | register width 32 clock clock clock_edge Rising enable read_enable data_in memory_read_port | hardcaml_xilinx</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/jk_flip_flop#jk-flip-flop</url>
    <fullTitle>Hardcaml: 2.2.1 JK Flip Flop, JK Flip Flop [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The JK flip flop is a basic sequential element with two inputs and that control its behavior Hold Mode Maintains the current output value when j 0 k 0 Set Mode Sets the output value to 1 when j 1 k 0 Reset Mode Sets the output value to 0 when j 0 k 1 Toggle Mode Inverts the current output value when j 1 k 1 The flip flop updates its state on the rising edge of the clock Verilog VHDL Hardcaml Direct translation Idiomatic Hardcaml j k module jk_flip_flop input clock j k output reg q always @ posedge clock begin case j k 2 b00 q &lt; q 2 b01 q &lt; 1 b0 2 b10 q &lt; 1 b1 2 b11 q &lt; q endcase end endmodule library ieee use ieee std_logic_1164 all entity jk_flip_flop is port clock j k in std_logic q out std_logic end entity architecture rtl of jk_flip_flop is signal q_int std_logic signal jk std_logic_vector 1 downto 0 begin jk &lt; j &amp; k q &lt; q_int process clock is begin if rising_edge clock then case jk is when 01 > q_int &lt; 0 when 10 > q_int &lt; 1 when 11 > q_int &lt; not q_int when others > null end case end if end process end architecture let jk_flip_flop_1 clock j k let q Always Variable reg Reg_spec create clock width 1 in Always compile switch j @ k of_string 00 q &lt; q value of_string 01 q &lt; gnd of_string 10 q &lt; vdd of_string 11 q &lt; q value q value let jk_flip_flop_2 clock j k reg_fb Reg_spec create clock width 1 f fun q > mux j @ k q gnd vdd q</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/t_flip_flop#t-flip-flop</url>
    <fullTitle>Hardcaml: 2.2.2 T Flip Flop, T Flip Flop [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The T Toggle flip flop changes state based on a single control input When t 0 Maintains current output state When t 1 Toggles inverts the current output state The flip flop updates only on the rising edge of the clock signal This implementation includes an active low asynchronous reset which means When reset 0 Output is forced to 0 immediately regardless of clock When reset 1 Normal operation based on input Verilog VHDL Hardcaml Direct translation Idiomatic Hardcaml t t module t_flip_flop input clock reset_n t output reg q always @ posedge clock negedge reset_n begin if reset_n q &lt; 1 b0 else if t q &lt; q end endmodule library ieee use ieee std_logic_1164 all entity t_flip_flop is port clock reset_n t in std_logic q out std_logic end entity architecture rtl of t_flip_flop is signal q_int std_logic begin q &lt; q_int process clock reset_n begin if reset_n 0 then q_int &lt; 0 elsif rising_edge clock then if t 1 then q_int &lt; not q_int end if end if end process end architecture let t_flip_flop_1 clock reset_n t let q Always Variable reg Reg_spec create clock reset reset_n reset_edge Falling width 1 in Always compile if_ t q &lt; q value q &lt; q value q value let t_flip_flop_2 clock reset_n t reg_fb Reg_spec create clock reset reset_n reset_edge Falling width 1 enable t f</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/d_flip_flop#d-flip-flop</url>
    <fullTitle>Hardcaml: 2.2.3 D Flip Flop, D Flip Flop [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The D Data flip flop loads the input value to the output on the rising edge of the clock When enable 1 Output takes the value of input on the clock edge When enable 0 Output maintains its current value This implementation includes two reset mechanisms Active high asynchronous reset Immediately sets to 0 regardless of clock Synchronous clear Sets to 0 on the next clock edge when clear is high The enable acts as a clock enable allowing or preventing state changes on the clock edge Verilog VHDL Hardcaml q d q q q module d_flip_flop input clock clear reset enable d output reg q always @ posedge clock posedge reset begin if reset q &lt; 1 b1 else if clear q &lt; 1 b0 else if enable q &lt; d end endmodule library ieee use ieee std_logic_1164 all entity d_flip_flop is port clock reset clear enable d in std_logic q out std_logic end entity architecture rtl of d_flip_flop is signal q_int std_logic begin q &lt; q_int process clock reset begin if reset 1 then q_int &lt; 1 elsif rising_edge clock then if clear 1 then q_int &lt; 0 elsif enable 1 then q_int &lt; d end if end if end process end architecture let d_flip_flop clock reset clear enable d reg Reg_spec create clock reset clear enable d</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/ring_counter#ring-counter</url>
    <fullTitle>Hardcaml: 2.2.4 Ring Counter, Ring Counter [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>An N bit right shift register that circularly shifts one bit through all positions On each clock cycle the least significant bit shifts into the most significant bit Initialized with a single bit i e binary 00 01 which then circulates through all bit positions creating a one hot encoding pattern Verilog VHDL Hardcaml 1 module ring_counter # parameter N 4 input clock clear output reg N 1 0 q always @ posedge clock begin if clear q &lt; 1 else q &lt; q 0 q N 1 1 end endmodule library ieee use ieee std_logic_1164 all use ieee numeric_std all entity ring_counter is generic N integer 4 port clock clear in std_logic q out std_logic_vector N 1 downto 0 end entity architecture rtl of ring_counter is signal q_int std_logic_vector N 1 downto 0 begin q &lt; q_int process clock is begin if rising_edge clock then if clear 1 then q_int &lt; std_logic_vector to_unsigned 1 q_int length else q_int &lt; q_int 0 &amp; q_int N 1 downto 1 end if end if end process end architecture let ring_counter n clock clear reg_fb Reg_spec create clock clear width n clear_to one n f rotr by 1</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/mobius_counter#mobius-counter</url>
    <fullTitle>Hardcaml: 2.2.5 Mobius Counter, Mobius Counter [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Mobius counter is a really cool name for this but it s probably more commonly known as a Johnson counter It is similar to a ring counter except the least significant bit is inverted before being placed into the most significant bit This inversion creates a 2N state counter from an N bit register as the counter cycles through both normal and complemented patterns before repeating Verilog VHDL Hardcaml module mobius_counter # parameter N 4 input clock clear output reg N 1 0 q always @ posedge clock begin if clear q &lt; 0 else q &lt; q 0 q N 1 1 end endmodule library ieee use ieee std_logic_1164 all entity mobius_counter is generic N integer 4 port clock clear in std_logic q out std_logic_vector N 1 downto 0 end entity architecture rtl of mobius_counter is signal q_int std_logic_vector N 1 downto 0 begin q &lt; q_int process clock is begin if rising_edge clock then if clear 1 then q_int &lt; others > 0 else q_int &lt; not q_int 0 &amp; q_int N 1 downto 1 end if end if end process end architecture let mobius_counter n clock clear reg_fb Reg_spec create clock clear width n f fun d > lsb d @ msbs d</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/modulo_n_counter#modulo-n-counter</url>
    <fullTitle>Hardcaml: 2.2.6 Modulo N Counter, Modulo N Counter [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>On each clock cycle this counter adds to the current value if the signal is high If the current value equals it wraps around to Verilog VHDL Hardcaml Direct translation Idiomatic Hardcaml In this implementation the function provided by performs the increment function It is a little smarter than the other versions in that it will detect if and rely on natural binary overflow to wrap to eliding the comparison 1 increment n 1 0 module modulo_n_counter # parameter width 4 parameter n 12 input clock clear increment output reg width 1 0 q always @ posedge clock begin if clear q &lt; 0 else if increment if q n 1 q &lt; 0 else q &lt; q 1 end endmodule library ieee use ieee std_logic_1164 all use ieee numeric_std all entity modulo_n_counter is generic width integer 4 n integer 12 port clock clear increment in std_logic q out std_logic_vector width 1 downto 0 end entity architecture rtl of modulo_n_counter is signal q_int std_logic_vector width 1 downto 0 begin q &lt; q_int process clock is begin if rising_edge clock then if clear 1 then q_int &lt; others > 0 elsif increment 1 then if q_int std_logic_vector to_unsigned n 1 q length then q_int &lt; others > 0 else q_int &lt; std_logic_vector unsigned q_int 1 end if end if end if end process end architecture let modulo_n_counter_1 config width n clock clear increment let spec Reg_spec create clock clear in let out Always Variable reg spec width in Always compile when_ increment if_ out value n 1 out &lt; 0 out &lt; out value 1 out value let modulo_n_counter_2 config width n clock clear increment reg_fb Reg_spec create clock clear enable increment width f mod_counter max n 1 mod_counter Comb S 2**width n 0</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/gray_counter#gray-counter</url>
    <fullTitle>Hardcaml: 2.2.7 Gray Counter, Gray Counter [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>A Gray code is a binary number system in which each successive code differs by a single bit This property makes Gray codes useful for reducing switching noise error detection and rotary encoders Although sequential examples in this section focus on examples with a single clock domain Gray codes are also fundamental for safely transferring counters across multiple clock domains Here we implement a Gray code counter It is done by using a binary counter and converting the value to a gray code Binary to Gray code conversion To convert a binary number to Gray code The most significant bit remains unchanged Each remaining bit is XORed with the bit to its left Verilog VHDL Hardcaml Direct translation Idiomatic Hardcaml module gray_counter # parameter N 4 input clock clear output reg N 1 0 q reg N 1 0 count always @ posedge clock begin if clear begin count &lt; 0 q &lt; 0 end else begin count &lt; count 1 q &lt; count N 1 count N 1 1 ^ count N 2 0 end end endmodule library ieee use ieee std_logic_1164 all use ieee numeric_std all entity gray_counter is generic N integer 4 port clock clear in std_logic q out std_logic_vector N 1 downto 0 end entity architecture rtl of gray_counter is signal count std_logic_vector N 1 downto 0 signal q_int std_logic_vector N 1 downto 0 begin q &lt; q_int process clock begin if rising_edge clock then if clear 1 then count &lt; others > 0 q_int &lt; others > 0 else count &lt; std_logic_vector unsigned count 1 q_int &lt; count N 1 &amp; count N 1 downto 1 xor count N 2 downto 0 end if end if end process end architecture let gray_counter_1 n clock clear let spec Reg_spec create clock clear in let q Always Variable reg spec width n in let out Always Variable reg spec width n in Always compile q &lt; q value 1 out &lt; q value n 1 @ q value n 1 1 ^ q value n 2 0 out value let gray_counter_2 n clock clear let spec Reg_spec create clock clear in let q reg_fb spec width n f fun q > q 1 in reg spec msb q @ msbs q ^ lsbs q</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/bidirectional_shift_reg#bidirectional-shift-register</url>
    <fullTitle>Hardcaml: 2.2.8 Bidirectional Shift Register, Bidirectional Shift Register [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>A shift register that can move data in either direction based on a control signal If shift the register left and add at the least significant bit If shift the register right and add at the most significant bit Verilog VHDL Hardcaml Direct translation Idiomatic Hardcaml dir 0 d dir 1 d module bidirectional_shift_reg # parameter N 4 input clock clear enable dir d output reg N 1 0 q always @ posedge clock begin if clear q &lt; 0 else if enable if dir q &lt; d q N 1 1 else q &lt; q N 2 0 d end endmodule library ieee use ieee std_logic_1164 all entity bidirectional_shift_reg is generic N integer 4 port clock clear enable dir d in std_logic q out std_logic_vector N 1 downto 0 end entity architecture rtl of bidirectional_shift_reg is signal q_int std_logic_vector N 1 downto 0 begin q &lt; q_int process clock is begin if rising_edge clock then if clear 1 then q_int &lt; others > 0 else if enable 1 then if dir 1 then q_int &lt; d &amp; q_int N 1 downto 1 else q_int &lt; q_int N 2 downto 0 &amp; d end if end if end if end if end process end architecture let bidirectional_shift_reg_1 n clock clear enable dir d let out Always Variable reg Reg_spec create clock clear width n in Always compile when_ enable if_ dir out &lt; d @ out value n 1 1 out &lt; out value n 2 0 @ d out value let bidirectional_shift_reg_2 n clock clear enable dir d reg_fb Reg_spec create clock clear width n enable f fun out > mux2 dir d @ msbs out lsbs out @ d</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/single_port_ram#single-port-ram</url>
    <fullTitle>Hardcaml: 2.2.9 Single Port RAM, Single Port RAM [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>This is a synchronous single port RAM with the following specifications Memory Size 8 words  8 bits 64 bits total Address width 3 bits 2^3^ 8 addresses Data width 8 bits each memory location stores a byte Port Configuration Single port design One shared address bus for both reads and writes One data input bus One data output bus Timing Behavior Synchronous operation All operations occur on the rising edge of the clock Write operations happen when is active Read operations happen on every clock cycle regardless of Read behavior during simultaneous write is consistent reads the previous value not the new one Verilog VHDL Hardcaml write_enable write_enable module single_port_ram input clock write_enable input 2 0 address input 7 0 write_data output reg 7 0 read_data reg 7 0 mem 0 7 always @ posedge clock begin if write_enable mem address &lt; write_data read_data &lt; mem address end endmodule library ieee use ieee std_logic_1164 all use ieee numeric_std all entity single_port_ram is port clock write_enable in std_logic address in std_logic_vector 2 downto 0 write_data in std_logic_vector 7 downto 0 read_data out std_logic_vector 7 downto 0 end entity architecture rtl of single_port_ram is type mem_t is array 0 to 7 of std_logic_vector 7 downto 0 signal mem mem_t signal read_data_int std_logic_vector 7 downto 0 begin read_data &lt; read_data_int process clock is begin if rising_edge clock then if write_enable 1 then mem to_integer unsigned address &lt; write_data end if read_data_int &lt; mem to_integer unsigned address end if end process end architecture let single_port_ram clock address write_enable write_data let spec Reg_spec create clock in multiport_memory Int pow 2 width address write_ports | write_clock clock write_enable write_address address write_data | read_addresses | address | 0 |> reg spec</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/sync_fifo#synchronous-fifo</url>
    <fullTitle>Hardcaml: 2.2.10 Synchronous FIFO, Synchronous FIFO [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>A synchronous FIFO First In First Out buffer provides temporary storage between circuits that process data at different rates but share the same clock domain It allows a producer to write data when ready and a consumer to read it later while maintaining the original order of the data Verilog VHDL Hardcaml module sync_fifo input clock clear write read input 15 0 data_in output reg 15 0 data_out output full empty reg 2 0 wptr rptr reg 15 0 mem 0 7 assign full wptr 1 rptr assign empty wptr rptr wire write_incr write &amp; full wire read_incr read &amp; empty always @ posedge clock begin if clear begin rptr &lt; 0 wptr &lt; 0 end else begin if write_incr wptr &lt; wptr 1 if read_incr rptr &lt; rptr 1 end if write_incr mem wptr &lt; data_in if read_incr data_out &lt; mem rptr end endmodule library ieee use ieee std_logic_1164 all use ieee numeric_std all entity sync_fifo is port clock clear write read in std_logic data_in in std_logic_vector 15 downto 0 data_out out std_logic_vector 15 downto 0 full empty out std_logic end entity architecture rtl of sync_fifo is type mem_t is array 0 to 7 of std_logic_vector 15 downto 0 signal mem mem_t signal wptr rptr unsigned 2 downto 0 signal write_incr std_logic signal read_incr std_logic signal full_int std_logic signal empty_int std_logic begin full_int &lt; 1 when wptr 1 rptr else 0 empty_int &lt; 1 when wptr rptr else 0 full &lt; full_int empty &lt; empty_int write_incr &lt; write and not full_int read_incr &lt; read and not full_int process clock begin if rising_edge clock then if clear 1 then rptr &lt; others > 0 wptr &lt; others > 0 else if write_incr 1 then wptr &lt; wptr 1 end if if read_incr 1 then rptr &lt; rptr 1 end if end if if write_incr 1 then mem to_integer wptr &lt; data_in end if if read_incr 1 then data_out &lt; mem to_integer rptr end if end if end process end architecture type t data_out Signal t full Signal t empty Signal t let sync_fifo clock clear write read data_in let spec Reg_spec create clock clear in let wptr wire log_depth in let wptr_next wptr 1 in let rptr wire log_depth in let full wptr_next rptr in let empty wptr rptr in let write_enable write &amp; full in let read_enable read &amp; empty in let mem Ram create collision_mode Write_before_read size depth write_ports | write_clock clock write_data data_in write_enable write_address wptr | read_ports | read_clock clock read_enable read_address rptr | in wptr &lt; reg spec enable write_enable wptr_next rptr &lt; reg spec enable read_enable rptr 1 data_out mem 0 full empty</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/circuits</url>
    <fullTitle>Hardcaml: 2.3 Circuits,  [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>A Hardcaml encodes both the RTL logic for a hardware design along with named input and output ports Circuits can be converted into various different forms Verilog or VHDL Simulation models Verification models Circuit t</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/circuits#creating-a-circuit</url>
    <fullTitle>Hardcaml: 2.3 Circuits, Creating a Circuit [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Circuits are created from a list of outputs and a module name When generating Verilog or VHDL will be used as the module or entity name in the RTL design When generating a circuit combinational loops are by default detected and will cause an exception Inputs and outputs To create a circuit we must label the inputs and outputs Inputs are specified by giving a name and the required bit width Outputs are specified by giving a name and a signal When generating Verilog or VHDL inputs and outputs correspond to module or entity ports For simulation inputs are set by a testbench and outputs are calculated by the simulation models and read by a testbench The names given for inputs and outputs are special in that Hardcaml will never try to change them If it decides they are not valid for some reason an error is raised What gets included Circuits are defined by their output ports Hardcaml traverses the design from the outputs and discovers all internal nodes and input ports which are connected to the outputs This can sometimes be confusing why is some part of my design not getting included The answer almost always is that it is not connected to an output Config There are a few configuration options used when generating circuits automatically check the circuit for combinational loops and raise if found rewrite internal unique identifiers helps to make the output rtl more stable to changes Both are true by default and generally should be kept as is There are a few other options but they are mainly used internally by Hardcaml # let circuit let foo input foo 8 in let bar input bar 8 in let baz output baz foo bar in Circuit create_exn name adder baz val circuit Circuit t &lt;abstr> name let input_a Signal input a width let output_b Signal output b some_logic input_a detect_combinational_loops normalize_uids</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/rtl_generation</url>
    <fullTitle>Hardcaml: 2.4 RTL Generation,  [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>You can convert a Hardcaml to either Verilog or VHDL The following is a trivial example We also provide basic Systemverilog support the generated RTL is basically the same as Verilog mode except we use the Systemverilog reserved words to correctly perform name mangling Circuit let circuit Circuit create_exn name test output b input a 1 # let Rtl print Verilog circuit module test a b input a output b assign b a endmodule # let Rtl print Vhdl circuit library ieee use ieee std_logic_1164 all use ieee numeric_std all entity test is port a in std_logic b out std_logic end entity architecture rtl of test is begin b &lt; a end architecture</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/rtl_generation#instantiations</url>
    <fullTitle>Hardcaml: 2.4 RTL Generation, Instantiations [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>In Hardcaml a corresponds to a single module in Verilog or entity in VHDL s can contain s which reference some other module or entity within a hierarchical design The Hardcaml RTL generator is aware of the s and can recursively generate the RTL for them if they are provided in a A stores the implementation of s that can be instantiated It is essentially a mapping between circuit names and their implementations If a circuit implementation is not found in the Hardcaml will still generate the appropriate instantiation in the RTL output This allows for integration with external modules such as vendor IP that will be added later in the design flow or for module hierarchy to be described in Hardcaml Circuit Circuit Instantiation Instantiation Circuit_database Circuit_database Circuit Circuit_database</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/rtl_generation#printing-circuits</url>
    <fullTitle>Hardcaml: 2.4 RTL Generation, Printing Circuits [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The function will output the RTL for a design and optionally any instantiations defined through a to It is simple and usable in most cases Rtl print Circuit_database stdout</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/designing-circuits/rtl_generation#low-level-control</url>
    <fullTitle>Hardcaml: 2.4 RTL Generation, Low Level Control [Designing Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The RTL API provides a way for the Hardcaml to discover the full design hierarchy and for the user to decide how to write it out It starts with the function the which contains implementations of found within the hierarchy of s Some configuration options for how to generate the RTL either Verilog or VHDL a list of top level circuits to generate returns a list which represent the design hierarchy Hierarchical circuits The returned by can be factored into the full design hierarchy using and These both return a list of s which contain functions to output a module implementation It should be noted that if a module is instantiated in multiple places it will still only be represented once within the design hierarchy Blackboxes A blackbox is a module or entity which describes just its interface and does not include its implementation The RTL generator can create black boxes if required Outputting RTL Hardcaml predefines 4 ways to output the hierarchy of modules generate full rtl for everything recursively This is the most common option and what uses only generate the given top levels and do not recuse into the hierarchy the top levels will be generated along with blackboxes for all modules in the hierarchy the top levels will be generated as blackboxes Each of these functions returns a Ropes Ropes are used by Hardcaml to generate code and are a fancy type of string All you need to know is they can be converted to a standard string with Example This creates a hierarchy where instantiates which in turn instantiates We now need to create a containing the inner circuits Now we can print the RTL for in various ways Find within the hierarchy and print that directly create # Rtl create database Circuit_database t > config Rtl Config t > Rtl Language t > Circuit t list > Rtl Hierarchical_circuits t list &lt;fun> database Circuit_database Instantiations Circuit config Rtl Langauge t Circuit t list create Hierarchical_circuits Hierarchical_circuits create subcircuits top_level_circuits Circuit_instance Hierarchical_circuits full_hierarchy Rtl print top_levels_only top_levels_and_blackboxes top_levels_as_blackboxes Rope t Rope to_string let inner1 Circuit create_exn name inner1 output b input a 1 let inner2 let x input x 1 in let inst Instantiation create name inner1 inputs a x outputs b 1 in Circuit create_exn name inner2 output y Instantiation output inst b let top let s input s 1 in let inst Instantiation create name inner2 inputs x s outputs y 1 in Circuit create_exn name top output t Instantiation output inst y top inner1 inner2 Circuit_database let database Circuit_database create Circuit_database insert database inner1 Circuit_database insert database inner2 top let rtl Rtl create database Verilog top # Rtl top_levels_and_blackboxes rtl |> Rope to_string |> Stdio print_endline module inner1 a b input a output b endmodule module inner2 x y input x output y endmodule module top s t input s output t wire _4 wire _2 inner2 the_inner2 x s y _4 assign _2 _4 assign t _2 endmodule unit # Rtl top_levels_as_blackboxes rtl |> Rope to_string |&gt; Stdio print_endline module top s t input s output t endmodule unit inner2 # let inner2 Rtl Hierarchical_circuits subcircuits rtl |> List find_exn f fun sub > String equal Rtl Circuit_instance module_name sub inner2 |> Rtl Circuit_instance rtl |> Rope to_string |> Stdio print_endline module inner2 x y input x output y wire _4 wire _2 inner1 the_inner1 a x b _4 assign _2 _4 assign y _2 endmodule val inner2 unit</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/simulating-circuits/simulation</url>
    <fullTitle>Hardcaml: 3.1 Simulating with Cyclesim,  [Simulating Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The simplest way to simulate a Hardcaml circuit is to use the module This will take a and perform various transformations in order to produce an executable model of the design A testbench is used to control the design by Performing a reset Stepping the simulation forward by 1 cycle Setting inputs ports Reading output ports Cyclesim Circuit t</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/simulating-circuits/simulation#working-with-simulators</url>
    <fullTitle>Hardcaml: 3.1 Simulating with Cyclesim, Working with Simulators [Simulating Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>A simulation is built from a circuit as follows First we will create a trivial circuit Now we can build a simulator for this circuit Once we have the simulator we can query its input and output ports These functions use the input and output port names given when we constructed the circuit Note that looking up a non existent port will produce an exception The functions and control the simulator sets all registers to their default initial value reads the values on the current input ports updates the internal combinational and sequential logic and calculates the new values of the circuit outputs Input and output ports are of type We set an input as follows and read an output like so The simulation algorithm Cyclesim performs the following steps when is called Based on the current value of the inputs update in the correct order all the combinational nodes in the circuit Nodes which read a register or memory read port use their current value Update all registers and memory writes The previous step will have defined the new values to load Perform a final update of the subset of combinational nodes that depend on the new register memory values Before and After outputs When we look up an output port there is an optional argument It defaults to which means the output value after all 3 steps of the simulation algorithm have run samples the values after step 1 that is before the sequential nodes update # open Base # open Hardcaml # let circuit Circuit create_exn name test Signal output y input x 1 val circuit Circuit t &lt;abstr> # let simulator _ Cyclesim t Cyclesim create circuit val simulator Cyclesim Port_list t Cyclesim Port_list t Cyclesim t &lt;abstr> # let x Cyclesim in_port simulator x val x Bits t ref Base Ref contents 0 # let y Cyclesim out_port simulator y val y Bits t ref Base Ref contents 0 # let foo Cyclesim in_port simulator foo Exception Couldn t find input port foo reset cycle reset cycle # Cyclesim reset simulator unit # Cyclesim cycle simulator unit Bits t ref # x Bits vdd unit # y Bits t 1 # Bits width y int 1 # Bits to_unsigned_int y int 1 # Cyclesim cycle simulator unit # Bits to_unsigned_int y int 0 cycle clock_edge After Before</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/simulating-circuits/simulation#limitations</url>
    <fullTitle>Hardcaml: 3.1 Simulating with Cyclesim, Limitations [Simulating Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Cyclesim implements a cycle accurate simulation algorithm This is in contrast to the more complex event driven simulators often used for RTL design Verilator is an example of a popular cycle accurate simulator while Icarus Verilog and Modelsim are examples of event driven simulators While event driven simulators are more powerful for testing standard synchronous designs cycle accurate simulators are generally good enough simpler to write testbenches for and easier to make run reasonably fast The Hardcaml Cyclesim simulator also add some further restrictions We only support 1 clock In designs with more that 1 clock they are all assumed to be the same We don t model different clock edges we assume everything is rising edge triggered We only support 2 state logic The Hardcaml toolset provides an event driver simulator framework with the library This is rather more complex to use but provides more accurate modeling possibilities Hardcaml_event_driven_sim</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/simulating-circuits/waveforms</url>
    <fullTitle>Hardcaml: 3.2 Waveforms,  [Simulating Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text></text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/simulating-circuits/waveforms#hardcaml-waveterm</url>
    <fullTitle>Hardcaml: 3.2 Waveforms, Hardcaml Waveterm [Simulating Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The library can capture and print waveforms from Hardcaml simulations Printing results as waveforms We can make a waveform with It takes as an argument a simulator and returns a waveform and modified simulator that captures the input and output port values The waveform can be displayed with Capturing in expect tests Waveforms can be captured as expect test output are a form of automated testing where the expected output of a function or component is directly embedded in the test file and automatically compared against actual results With waveforms we get presented with a diff as we develop or change code Alongside good editor integration using expect tests can be a surprisingly convenient way to iterate on a hardware implementation Configuration options The function takes optional arguments which control the rendering of the waveform first cycle to display width and height of the waveform The height is inferred if not specified scale at which the waveform is shown negative values allowed configuration of the signals to show left or right align the name in the signal pane width of signal pane configure what signals to show and in what format Display rules The signals are shown in the order of the first matching A display rule matches one or more signal names matches the given name matches any name in the given list matches the signal name against a regular expression defined using the OCaml RE library The way the value is shown is configured by a Standard formatting includes and is like binary but renders a single bit value like the clear signal in the previous example will render as a bit if the width is 1 or X which may be Hex or Int for example otherwise takes a list of strings and looks it up based on the runtime value of the signal passes the runtime value to a function which returns the string to display is like index but looks up the the runtime value in a map Saving a waveform Hardcaml waveforms can be saved to file using It takes a waveform and file name and saves it Note that it also compresses the waveform data using which must be available will load the waveform The hardcaml waveterm library includes an executable which runs an interactive waveform viewer on saved waveform files hardcaml_waveterm Waveform create Waveform print # let test let sim Simulator create create in let waves sim Waveform create sim in testbench sim waves val test unit > Waveform t &lt;fun> # let waves test val waves Waveform t &lt;abstr> # Waveform print waves SignalsWaves clock                 clear        incr           dout  00 01 02 00      unit let%expect_test counter let waves test Waveform print waves %expect | SignalsWaves clock                 clear        incr           dout  00 01 02 00         | expect tests Waveform print start_cycle display_width display_height wave_width display_rules signals_alignment signals_width display_rules # Waveform print display_height 10 display_rules Display_rule port_name_is dout wave_format Unsigned_int port_name_matches Re Posix compile re cl * wave_format Bit waves SignalsWaves    dout  0 1 2 0     clear        clock                     unit Display_rule t port_name_is port_name_is_one_of port_name_matches wave_format Binary Hex Unsigned_int Int Bit Bit_or X Index Custom Map Serialize marshall gzip Serialize unmarshall</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/simulating-circuits/waveforms#generating-vcds</url>
    <fullTitle>Hardcaml: 3.2 Waveforms, Generating VCDs [Simulating Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>VCDs are a common hardware design file format for storing waveforms They can be used with standard waveform viewers like Gtkwave To generate a VCD call the function It takes an to write to and a simulator and returns a modified simulator to use during simulation The VCD will be generated as the simulation runs The being written to may need to be flushed This VCD file can subsequently be opened with a GUI based waveform viewer tool such as Surfer or GTKWave image Vcd wrap Out_channel Out_channel let test let sim Simulator create create in let filename tmp waves vcd in let oc Out_channel open_text filename in let sim Vcd wrap oc sim in testbench sim * Closing the out channel will ensure the file is flushed to disk * Out_channel close oc Stdio print_endline Saved waves to ^ filename let%expect_test vcd generation test %expect | Saved waves to tmp waves vcd |</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/simulating-circuits/waveterm_interactive_viewer</url>
    <fullTitle>Hardcaml: 3.3 Interactive Viewer,  [Simulating Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Writing waveforms in expect tests can be very useful but does come with it s limitations In particular it is not really possible to print very long traces and designs with lots and lots of signals can become unwieldy As an alternative we can use the terminal based interactive waveform viewer</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/simulating-circuits/waveterm_interactive_viewer#building-a-simulation-application</url>
    <fullTitle>Hardcaml: 3.3 Interactive Viewer, Building a Simulation Application [Simulating Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The interactive waveform viewer should be built as a top level application It should be linked with the library Waveforms are created in the normal way by wrapping a simulator with and then running a testbench The following function is used to run the viewer hardcaml_waveterm_interactive Hardcaml_waveterm Wavform create # Hardcaml_waveterm_interactive run waves</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/simulating-circuits/waveterm_interactive_viewer#using-the-waveform-viewer</url>
    <fullTitle>Hardcaml: 3.3 Interactive Viewer, Using the Waveform Viewer [Simulating Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>quits or scroll waveform horizontally or scroll waveform vertically decrease increase waveform scale will find the next prev transition on the highlighted signal save or load the current waveform configuration move the cursor increase decrease the signals pane size increase decrease the values pane size increase decrease the waves pane size Left clicking on the waveform will position a cursor and show the value of signals at that cycle in the values window All windows also have scroll bars that can be clicked on q escape left right ctrl mouse wheel up down mouse wheel e b s S h j k l 9 0 _</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/simulating-circuits/waveterm_interactive_viewer#interactive-waveforms-from-expect-tests</url>
    <fullTitle>Hardcaml: 3.3 Interactive Viewer, Interactive Waveforms from Expect Tests [Simulating Circuits]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Waveform based expect tests are very information limited We often either run very small simulations show a small portion of a larger simulation or zoom far out to capture general behavior Often we can see the behavior of control signals but not the detailed values on data buses To help with this the library can optionally serialize a waveform to disk It provides an function which is very similar to This provides an optional argument called which specifies the filename to which the waveform will be saved The suffix will be added By default waveforms are not saved To do so execute the tests with the following environment variable set Which will output a file in the same directory called To view the waveform a tool called is provided with in the directory Hardcaml_waveterm expect Hardcaml_waveterm Waveform print Hardcaml_waveterm Waveform expect serialize_to filename waves serialize_to hardcamlwaveform EXPECT_TEST_WAVEFORM 1 filename hardcamlwaveform waveform_viewer hardcaml_waveterm bin waveform_viewer exe show filename hardcamlwaveform</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/naming#naming-signals</url>
    <fullTitle>Hardcaml: 4.1 Naming, Naming Signals [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Names pop up in a couple of places First a circuit s input and output ports must have properly defined names Internal nodes within a circuit also need a name which Hardcaml will automatically create unless provided Judicious use of names becomes very important for debugging simulations or understanding reports from vendor tools like Vivado Port names Port names are specified with the and functions Hardcaml checks the following rules Port names must be unique No input or output may share a name The names must be legal for the RTL language you use For Hardcaml simulation this doesn t matter but if we write the design to Verilog the names must not clash with a Verilog reserved word Hardcaml will never try to alter a port name Instead it will raise an exception if it deems it illegal Internal names When we create vectors in Hardcaml they are labeled with a unique ID Without further information hardcaml will implicitly name the vector as It is possible to manually label any vector with a new name using the operator There are no rules on what internal names are OK to use Hardcaml will legalize them for you when generating RTL The rules for Verilog generation are Any non alphanumeric character except $ is rewritten with an Internal names cannot start with a number a prefix is added Internal names cannot be reserved words the name gets mangled Internal names need to be unique the name gets mangled if not Mangling means adding a numeric suffix and checking against the rules again The VHDL rules are somewhat similar and Hardcaml will make them legal and perform mangling as appropriate Auto names provides a shortcut syntax for specifying names How this works will be explained later after introducing and input output _&lt;uid> # let foo Hardcaml Signal of_unsigned_int width 8 7 foo val foo Hardcaml Signal t const names foo width 8 value 0b00000111 _ ppx_hardcaml let%hw c a b Interfaces Hierarchy</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/always</url>
    <fullTitle>Hardcaml: 4.2 Always DSL,  [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The DSL in Hardcaml lets one describe circuits in a similar style to a Verilog block Always blocks allow hardware multiplexer structures to be described in a somewhat imperative manner using variable assignments if else conditions switches and a simple procedural macro construct This programming model often makes complicated logic such as state machines easier to reason about Always always</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/always#the-always-dsl</url>
    <fullTitle>Hardcaml: 4.2 Always DSL, The Always DSL [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>There are two key components when using the Always DSL 1 Variable Declarations There are two kinds of variable declarations namely wires and registers A is one whose value is sequentially updated on the edge of the clock signal provided within a type A is one whose value is updated combinationally meaning that the new value is visible at the same clock cycle as when it is assigned The new value will not persist to the next cycle If no such assignment exists the variable will possess the value Both kinds of variable will return the same type namely an Variables may be assigned within an Always block To read the value of a variable access the field which provides a that can be used to form expressions 2 Writing an Always Program Having declared the variables we can now write the actual procedural blocks An program comprises assignments to variables optionally guarded by or conditional statements For example Notice the call to the function surrounding the procedural block Two things going on here Notice that returns a unit This is because variable declarations create unassigned wires and the compile function assigns them to the appropriate multiplexers Notice that the Always DSL is just a list of This means we can play with various meta programming and abstraction tricks within these program blocks Example The following is an example of these pieces put together Differences to Verilog Always blocks The semantics are similar to Verilog with a few caveats Assignments are non blocking Hardcaml does not support blocking assignments In Verilog an Always block can describe either registers or combinational logic but not both With the Always DSL both can be defined in a single block Hardcaml Always blocks do not require a sensitivity list the clocks driving the registers are bound to the register variable themselves How values update The reader might be surprised by the following example The rule is the last assignment executed will set the next value open Base open Hardcaml reg Reg_spec t # * Creates a register variable * Always Variable reg width int > Always Variable t Signal with_register_spec &lt;fun> wire default # * Creates a wire register that is the value of the wire * Always Variable wire default Signal t > unit > Always Variable t &lt;fun> Always Variable t # let foo Always Variable wire default Signal gnd val foo Always Variable t Hardcaml Always Variable value wire width 1 internal &lt;abstr> value Signal t # foo value Signal t wire width 1 Always if_ when switch let something let open Signal in let a input a 1 in let b input b 1 in let c Always Variable wire default gnd in let d Always Variable wire default gnd in let e Always Variable wire default gnd in Always compile * Assignments * c &lt; a ^ b * if_ statements * if_ a b d &lt; vdd d &lt; gnd * when_ is like if_ with an empty else * when_ c value e &lt; 1 compile # Always compile Always t list > unit &lt;fun> compile Always t let clock Signal input clock 1 let clear Signal input clear 1 let a Signal input a 8 let b Signal input b 8 let r_sync Signal Reg_spec create clock clear let create let open Signal in * wire and register variable declarations * let c_wire Always Variable wire default Signal zero 8 in let c_reg Always Variable reg enable Signal vdd r_sync width 8 in * The program block with a call to compile * Always compile if_ a b c_wire &lt; sll a by 1 c_reg &lt; sll a by 1 c_wire &lt; a b c_reg &lt; a b * The c_wire value are assigned appropriately by the Always compiler * output c_wire c_wire value output c_reg c_reg value let counter_thing enable let open Signal in let a Always Variable reg enable vdd r_sync width 8 in Always compile * Here we might expect a to take the values 10 or 11 depending on enable But that is not the case While enable is high a will increment by one every clock cycle When enable is low a is set to 10 * a &lt; 10 when_ enable a &lt; a value 1</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/binary_coded_decimal</url>
    <fullTitle>Hardcaml: 4.2.1 BCD Conversion,  [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>In the Binary Coded Decimal BCD system we represent decimal numbers in a binary format The format uses 4 bits per decimal digit to encode the numbers 0 through 9 For example the number 971 would be represented in BCD as 9 7 1 |1001|0111|0001|</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/binary_coded_decimal#converting-to-binary</url>
    <fullTitle>Hardcaml: 4.2.1 BCD Conversion, Converting to Binary [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>To convert a BCD number to a binary number we need to do some multiplications by powers of 10 First we split the input vector into parts of width 4 then compute We can do something a little more efficient by starting with the top most digit and computing 9*100 7*10 1 9*10 7 * 10 1</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/binary_coded_decimal#implementing-in-hardware</url>
    <fullTitle>Hardcaml: 4.2.1 BCD Conversion, Implementing in Hardware [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>We start by figuring out how many digits we need to process and a counter from is created An accumulator is also created wide enough to hold the largest result value  An assertion is raised if num_digits is equal to 1 This is because the register has width which you aren t allowed to do It is not unusual for otherwise generic hardcaml circuit generators to fall down on the smallest example in this way though it often tends to be a trivial case here the circuit literally does nothing if there is only 1 digit and can often be worked around While is 0 we are waiting for to be raised Then for cycles we will add each digit starting from the top most to When we have computed the result and set back to 0 let create clock start bcd let spec Reg_spec create clock in * Find the number of digits to convert and create a counter * let digits split_msb part_width 4 bcd in let num_digits List length digits in * We only support multiple digits for a single digit the output equals the input anyway * assert num_digits > 1 let count Always Variable reg spec width Int ceil_log2 num_digits in * Create an accumulator large enough to hold the final result * let max_result Int pow 10 num_digits 1 in let acc Always Variable reg spec width num_bits_to_represent max_result in * Select the current digit being processed Note that when we split bcd into digits we did so from the top most digit * let digit mux count value digits |> uresize width width acc value in Always compile if_ count value 0 * Wait for start When applied set the accumulator with the top most digit * when_ start count &lt; count value 1 acc &lt; digit * Add each succesive digit to the accumulator times 10 * count &lt; count value 1 acc &lt; drop_top acc value * of_unsigned_int width 4 10 width 4 digit * Finished processing digits * when_ count value num_digits 1 count &lt; 0 acc value count value 0 0 num_digits 1 count Int ceil_log2 num_digits 0 count start num_digits acc * 10 count num_digits 1 count</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/binary_coded_decimal#testbench</url>
    <fullTitle>Hardcaml: 4.2.1 BCD Conversion, Testbench [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The following steps are performed Create the BCD design Create a Create a simulator Get the simulator ports Return a function which performs a single test start the circuit with a BCD value wait for it to complete and return the result The function doesn t actually compute a BCD but it does do all the setup stuff which can be time consuming for larger designs It returns a function that allows us to run multiple conversions one after the other let bcd_of_string v String to_list v |> List map f fun c > Char to_int c Char to_int 0 |> Bits of_unsigned_int width 4 |> Bits concat_msb let test num_digits * Create the simulator * let sim let result done_ create clock input clock 1 start input start 1 bcd input bcd num_digits * 4 in Circuit create_exn name bcd output result result output done done_ |> Cyclesim create in * Query the input and output ports * let start Cyclesim in_port sim start in let bcd Cyclesim in_port sim bcd in let done_ Cyclesim out_port sim done in let result Cyclesim out_port sim result in * Start the circuit running and wait for it to be done Return the computed result * let run v start Bits vdd bcd bcd_of_string v Cyclesim cycle sim start Bits gnd Cyclesim cycle sim while not Bits to_bool done_ do Cyclesim cycle sim done Bits to_unsigned_int result in run Circuit Cyclesim test</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/binary_coded_decimal#tests</url>
    <fullTitle>Hardcaml: 4.2.1 BCD Conversion, Tests [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>let%expect_test let run test 5 in Stdio print_s %message run 00000 int Stdio print_s %message run 12345 int Stdio print_s %message run 99999 int %expect | run 00000 0 run 12345 12345 run 99999 99999 | let run test 2 in Stdio print_s %message run 00 int Stdio print_s %message run 21 int Stdio print_s %message run 55 int Stdio print_s %message run 99 int %expect | run 00 0 run 21 21 run 55 55 run 99 99 |</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/cylon_eye</url>
    <fullTitle>Hardcaml: 4.2.2 Cylon Eye,  [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>In this example we will simulate the scanning effect of a Cylons eye as seen in Battlestar Galactica We will assume we have an array of 16 LEDs that we can drive with a 3 bit intensity value where 0 is off and 7 is full brightness</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/cylon_eye#implementation</url>
    <fullTitle>Hardcaml: 4.2.2 Cylon Eye, Implementation [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The circuit takes 2 inputs the clock and an enable The enable is wired into every register We will see why later The implementation has 3 parts First we go through every and decrease it s intensity by one to a minimum of 0 We then find the current eye located at and set it to maximum intensity Together these processes create a eye with a tail Because it looks cooler Finally we have some logic which updates the eye position When is zero we move left and when it is one we move right At the boundaries we switch direction let cylon_eye clock enable let spec Reg_spec create clock in let eye_pos Always Variable reg spec enable width 4 in let eye_dir Always Variable reg spec enable width 1 in let eye_bar List init 16 f fun _ > Always Variable reg spec enable width 3 in Always compile * Decrease intensity * proc List map eye_bar f fun eye > proc eye &lt; eye value 1 when_ eye value 0 eye &lt; 0 * Set current eye to max intensity * proc List mapi eye_bar f fun idx eye > when_ eye_pos value idx eye &lt; 7 * Scan left and right * if_ eye_dir value eye_pos &lt; eye_pos value 1 when_ eye_pos value 1 eye_dir &lt; gnd eye_pos &lt; eye_pos value 1 when_ eye_pos value 14 eye_dir &lt; vdd List map eye_bar f fun eye > eye value eye eye_pos eye_dir</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/cylon_eye#testing</url>
    <fullTitle>Hardcaml: 4.2.2 Cylon Eye, Testing [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Testing is pretty trivial The only input is which we set to 1 and otherwise all we have to do is print the outputs enable let test let sim Circuit create_exn name cylon_eye cylon_eye clock input clock 1 enable input enable 1 |> List mapi f fun i > output %string eye% i#Int |> Cyclesim create in let eyes List init 16 f fun i > Cyclesim out_port sim %string eye% i#Int in Cyclesim in_port sim enable Bits vdd for _ 1 to 40 do Cyclesim cycle sim List iter eyes f fun e > printf %i Bits to_unsigned_int e printf n done let%expect_test test %expect | 7000000000000000 6700000000000000 5670000000000000 4567000000000000 3456700000000000 2345670000000000 1234567000000000 0123456700000000 0012345670000000 0001234567000000 0000123456700000 0000012345670000 0000001234567000 0000000123456700 0000000012345670 0000000001234567 0000000000123476 0000000000012765 0000000000007654 0000000000076543 0000000000765432 0000000007654321 0000000076543210 0000000765432100 0000007654321000 0000076543210000 0000765432100000 0007654321000000 0076543210000000 0765432100000000 7654321000000000 6743210000000000 5672100000000000 4567000000000000 3456700000000000 2345670000000000 1234567000000000 0123456700000000 0012345670000000 0001234567000000 |</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/cylon_eye#real-world-considerations</url>
    <fullTitle>Hardcaml: 4.2.2 Cylon Eye, Real World Considerations [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Lets say we clock this circuit at 100Mhz It takes 30 cycles to scan left to right and back again so that means we will do something like 3 33 million scans per second That s obviously not something we could actually see This is why we included the enable signal We can use it to slow down the scanning process by only enabling it every so often The simplest way to do this is to define another counter and only enable the scan when the counter equals some value If we want the scan to take 1 second we want to count to 3 33 million so we will need a 22 bit counter The second issue is that LEDs are driven by a single on off value So how do we show intensity For this we need to use a technique called Pulse Width Modulation PWM The idea is that we will turn the LED on and off much faster than we can perceive and in proportion to the intensity we want to show Here is our final design We made the rate at which the enable toggles a parameter called We would want to set this to when generating hardware For testing we set it to so that we can see the PWM happening  There is sometimes a maximum rate at which we should drive a PWM signal I am not sure it applies to LEDs but it is easily adjustable by changing the PWM code as follows This will slow down the toggling but will still drive the same average power let cylon_eye_top scope enable_rate clock let spec Reg_spec create clock in let%hw_var enable Always Variable reg spec width 1 in let eyes cylon_eye clock enable enable value in let%hw_var count Always Variable reg spec width 22 in let leds List init List length eyes f fun _ > Always Variable reg spec width 1 in Always compile * Control the enable * enable &lt; gnd count &lt; count value 1 when_ count value enable_rate 1 count &lt; 0 enable &lt; vdd * PWM for each LED * proc List map2_exn leds eyes f fun led eye > led &lt; eye > count value 2 0 List map leds f fun led > led value enable_rate 3_333_333 8 let test let sim let scope Scope create flatten_design true in let leds cylon_eye_top scope enable_rate 8 clock input clock 1 in Circuit create_exn name cylon_eye List mapi leds f fun i > output Printf sprintf led% 2i i |> Cyclesim create config Cyclesim Config trace_all in let waves sim Waveform create sim in for _ 1 to 120 do Cyclesim cycle sim done Waveform expect_exact waves wave_width 2 let%expect_test test %expect_exact | SignalsWaves clock    enable                    led00                     led01                     led02                     led03                     led04                     led05                     led06                     led07                     led08                     led09                    led10                    led11                    led12                   led13                    led14                    led15                       count      gnd      vdd       23a1bb8cebaa916241e49f8dd3880407 | led &lt; eye > count value 12 10</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/state_machine_always_api</url>
    <fullTitle>Hardcaml: 4.3 Designing State Machines,  [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text></text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/state_machine_always_api#writing-state-machines</url>
    <fullTitle>Hardcaml: 4.3 Designing State Machines, Writing State Machines [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The Always DSL is most commonly used to construct state machines or non trivial sequential logic Hardcaml is shipped with an module to help create state machines A state machine is constructed with the following function The value returned can be used within an Always block Let s look at an example Defining the state type The type must use the and derivers when defining a state machine This state machine will begin in the state and wait for an external signal It will then transition to and back to Just before transitioning back to it will pulse a done signal Although nothing useful is actually implemented here we could imagine the processing states were waiting for network data accessing a RAM or performing some multi step computation Implementing the state machine Notice the function call surrounding the Always DSL Let s look at its type signature What It returns a unit type so how do we retrieve the variable s values Under the hood the always DSL creates regular Hardcaml wires with an empty assignment The call to will assign these wires with the appropriate signals according to the conditions specified in the always block For more information about wires see the Sequential Logic section In particular unassigned wires are fairly common if you miss a variable assignment Simulation Simulating a state machine is no different from simulating any other Hardcaml circuit Let s walk through an example to see the Always DSL in action Always State_machine # open Base # open Hardcaml # open Signal # Always State_machine create encoding Always State_machine Encoding t > auto_wave_format bool > attributes Hardcaml Rtl_attribute t list > enable t > unreachable a list > module Hardcaml Always State_machine State with type t a > Reg_spec t > a Always State_machine t &lt;fun> module States struct type t | Wait_for_start | Process_something | Process_something_else @@deriving sexp_of compare enumerate end States sexp_of compare enumerate Wait_for_start start Process_something Process_something_else Wait_for_start Wait_for_start let clock Signal input clock 1 let clear Signal input clear 1 let r_sync Reg_spec create clock clear let start Signal input start 1 let outputs let open Signal in let sm Always State_machine create module States enable vdd r_sync in let done_ Always Variable wire default gnd in Always compile sm switch Wait_for_start when_ start sm set_next Process_something Process_something sm set_next Process_something_else Process_something_else done_ &lt; 1 sm set_next Wait_for_start Signal output done done_ value * We output the state to help with visualizing in the simulation examples that follows * Signal output state sm current Always compile # Always compile Always t list > unit &lt;fun> Always compile # let let circuit Circuit create_exn name test_statemachine outputs in let sim Cyclesim create circuit in let print_state_and_outputs let state List nth_exn States all Bits to_unsigned_int Cyclesim out_port sim state in let done_ Bits to_bool Cyclesim out_port sim done in Stdio print_s %message state States t done_ bool in Cyclesim reset sim Cyclesim in_port sim clear Bits vdd Cyclesim cycle sim print_state_and_outputs Cyclesim in_port sim clear Bits gnd Cyclesim in_port sim start Bits vdd Cyclesim cycle sim print_state_and_outputs Cyclesim in_port sim start Bits gnd Cyclesim cycle sim print_state_and_outputs Cyclesim cycle sim print_state_and_outputs state Wait_for_start done_ false state Process_something done_ false state Process_something_else done_ true state Wait_for_start done_ false</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/state_machine_always_api#metaprogramming-with-the-always-dsl</url>
    <fullTitle>Hardcaml: 4.3 Designing State Machines, Metaprogramming with the Always DSL [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>As mentioned above the Always DSL is simply an The gives room for several creative behaviors Function abstractions Since we are really just generating lists from OCaml code we can simply split out some parts of the DSL into different functions For example A few interesting things are happening here We can call as many times as we want Every call to creates a new instance of an accumulator register The caller doesn t know and doesn t care that created a new variable under the hood This is akin to function closures in functional programming a powerful concept made possible in the Always DSL Bearing in mind that we are still generating hardware so all variables in functions are really more like static variables in C this function abstraction is a powerful way of making repetitive complicated state machines much more comprehensible Advanced High order blocks What if we want to create functional blocks that are only executed under a set of non trivial preconditions For example processing data received from some hand shaking protocol In this example we consider a trivial case where only an signal is required The beauty in this approach is that the repetitive hand shaking code is replaced with a high order function call On top of that if the handshaking protocol is modified we can simply update the function without having to rewrite it everywhere it is used Always t list Always t * A useful mental model above is to treat `foo_branch` as a C void function that takes a pointer to write its output value to * let foo_branch o_value Hardcaml Always Variable t let open Signal in let foo Always Variable reg enable vdd width 32 r_sync in Always foo &lt; foo value 1 o_value &lt; foo value let main Always t list let cond Signal input cond 1 in let o_value Always Variable wire default Signal zero 32 in Always if_ cond * proc turns a Always t list to an Always t without changing any semantic meaning of the program * proc foo_branch o_value o_value &lt; 0 foo_branch foo_branch foo_branch accept type stream valid Signal t data Signal t accept Always Variable t let handshake stream callback Always proc when_ stream valid stream accept &lt; 1 proc callback stream data let main stream_a stream stream_b stream let foo Always Variable wire default Signal gnd in let bar Always Variable wire default Signal gnd in Always compile handshake stream_a fun data > Always foo &lt; data handshake stream_b fun data > Always foo &lt; 0 bar &lt; data handshake</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/sequence_detector</url>
    <fullTitle>Hardcaml: 4.3.1 Sequence Detector,  [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>In this example we will explore the implementation of a sequence detector The hardware will take in one bit per cycle and raise a signal when it sees a specific sequence of bits Below we have implemented an example in Verilog VHDL and Hardcaml for comparison The sequence detected is Verilog VHDL Hardcaml In each state we transition to the next matching state if the input data is expected or return to if not When we are in the final state we check the input is correct and set the output detect 101 module sequence_detector input clock clear d output reg detect localparam S1 0 S10 1 S101 2 reg 1 0 state always @ posedge clock if clear begin state &lt; S1 detect &lt; 0 end else begin case state S1 if d state &lt; S10 else state &lt; S1 S10 if d state &lt; S1 else state &lt; S101 S101 state &lt; S1 endcase detect &lt; state S101 &amp; d end endmodule library ieee use ieee std_logic_1164 all entity sequence_detector_vhdl is port clock clear d in std_logic detect out std_logic end entity architecture rtl of sequence_detector_vhdl is type state_t is S1 S10 S101 signal state state_t begin process clock begin if rising_edge clock then if clear 1 then state &lt; S1 detect &lt; 0 else case state is when S1 > if d 1 then state &lt; S10 else state &lt; S1 end if when S10 > if d 1 then state &lt; S1 else state &lt; S101 end if when S101 > state &lt; S1 end case if state S101 and d 1 then detect &lt; 1 else detect &lt; 0 end if end if end if end process end architecture module State struct type t | S1 | S10 | S101 @@deriving sexp_of compare localize enumerate end let create clock clear d let spec Reg_spec create clock clear in let sm Always State_machine create module State spec in Always compile sm switch S1 if_ d sm set_next S10 sm set_next S1 S10 if_ d sm set_next S1 sm set_next S101 S101 sm set_next S1 reg spec sm is S101 &amp; d S1 S101 detect</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/sequence_detector#testing</url>
    <fullTitle>Hardcaml: 4.3.1 Sequence Detector, Testing [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>As we see the first two test sequences are correctly detected However the third one is not Can you see why # let test bits let sim create_sequence_detector_sim in let waves sim Waveform create sim in let d Cyclesim in_port sim d in List iter Bits bits_lsb bits f fun bit > d bit Cyclesim cycle sim Cyclesim cycle sim Waveform print waves wave_width 1 display_width 40 val test Bits t > unit &lt;fun> # test Bits of_string 101 SignalsWaves clock                  clear      d        detect        unit # test Bits of_string 1010 SignalsWaves clock                  clear      d         detect        unit # test Bits of_string 1011 SignalsWaves clock                  clear      d        detect       unit</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/sequence_detector#parameterizing-over-the-sequence</url>
    <fullTitle>Hardcaml: 4.3.1 Sequence Detector, Parameterizing over the Sequence [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>In the following code we make the circuit parameterized over the sequence we wish to detect The code is pretty similar to before the interesting bit is that the number states required is determined by the sequence length we need to match against The module specifies a number of states equal to the length of This is done in the definition of the value The implementation of each state is built dynamically They are all of the form The function returns the states to transition to if the input is valid or invalid Note we swap them depending on if we expect to match a or a let next_states sequence cur_state let sequence_length Bits width sequence in cur_state 1 % sequence_length 0 let create sequence clock clear d let sequence_length Bits width sequence in let module State struct type t int @@deriving compare localize sexp_of * Valid states are integers in the range 0 sequence_length 1 * let all List init sequence_length f Fn id end in let spec Reg_spec create clock clear in let sm Always State_machine create module State spec in Always compile sm switch List init sequence_length f fun cur_state > cur_state let t f next_states sequence cur_state in let t f * Swap the states if the match bit is 0 * if Bits to_bool sequence Bits cur_state then t f else f t in if_ d sm set_next t sm set_next f * Decode the detect result we are in the final state and the last bit matches * reg spec sm is sequence_length 1 &amp; if Bits to_bool sequence Bits sequence_length 1 then d else d State sequence all if_ d sm set_next t sm set_next f next_states 0 1</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/sequence_detector#fixing-the-matching-problem</url>
    <fullTitle>Hardcaml: 4.3.1 Sequence Detector, Fixing the Matching Problem [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>We noted a problem that we don t match all sequences properly The problem is caused by the state machine always returning to the initial state if the current input bit doesn t match It is possible however that we should return to some earlier state which partially matches the input sequence In the previous example we input the sequence and it didn t match Consider what happens We get the first and transition to We get a and transition to We get a and stay in We get a and transition to We didn t match What we should do is We get the first and transition to We get a and stay in We get a and transition to We get a and set To this fix we need to find the state which matches the longest prefix of our sequence when the input bit does not match We can do this by modifying our function There is actually a further problem when we get a sequence match that may actually form a prefix for the next match i e consider matching against there are two matches adjacent to each other So there are two cases in which we must find the longest partial match and move to the state that represents it If the current input bit doesn t match the sequence or if we are in the last state and the bit does match It is important to note that we are not actually generating any hardware here we are performing calculations to define what hardware we should generate 1 >1 >0 >1 1 S10 1 S1 0 S1 1 S10 1 S10 1 S10 0 S101 1 detect next_states 111 1111 let find_prev_match match_bit sequence cur_state let open Bits in if cur_state 0 then 0 else let sequence sequence cur_state 1 0 in let rec find cur_state sequence match_ if cur_state 0 then 0 else if Bits equal sequence match_ then cur_state else if cur_state 1 then 0 else find cur_state 1 lsbs sequence msbs match_ in find cur_state sequence msbs match_bit @ sequence let next_states sequence cur_state let open Bits in let sequence_length width sequence in let on_match if cur_state sequence_length 1 then find_prev_match sequence cur_state sequence cur_state else cur_state 1 % sequence_length in let no_match find_prev_match sequence cur_state sequence cur_state in on_match no_match</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/sequence_detector#building-a-test-harness</url>
    <fullTitle>Hardcaml: 4.3.1 Sequence Detector, Building a Test Harness [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>We now want to show that the fixes we made have actually worked To do this we will create a self checking testbench The idea is we will run a sequence of bits through the detector module and record every place it finds a match We will compare this against a software reference model and compare the two results We can then run a bunch of random tests and make sure everything is correct Lets start off by creating the software reference model We can now write a testbench that runs the sequence detector and collects all the matches it sees It compares against the software model and raises if they do not agree Now we can run some random tests across different sequences let software_reference sequence bits let open Bits in List init width bits width sequence 1 f fun pos > if to_bool bits width sequence pos 1 pos sequence then Some pos else None |> List filter_opt * We find the first bit of the match but the hardware will find the last bit so offset it by the length of the sequence * |> List map f fun d > d width sequence 1 let test sequence data_in let sim create_sequence_detector_sim sequence in let d Cyclesim in_port sim d in let detect Cyclesim out_port sim detect in let open Bits in let cycles width data_in in let results ref in for i 0 to cycles 1 do d data_in i Cyclesim cycle sim if Bits to_bool detect then results i results done let results List rev results in let expected software_reference sequence data_in in if not List equal Int equal results expected then raise_s %message sequence Bits t data_in Bits t results int list expected int list let%expect_test check random sequences for _ 0 to 10 do let sequence Bits random width 1 Random int 5 in for _ 0 to 100 do let data_in Bits random width Bits width sequence Random int 100 in test sequence data_in done done</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/double_dabble</url>
    <fullTitle>Hardcaml: 4.3.2 Double Dabble,  [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>We previously saw how to convert a BCD value to binary using a simple multiply by 10 scheme We d now like to convert the other way from binary to BCD Conceptually this is a bit harder to achieve we could do division by 10 with remainder to calculate the result but we tend to shy away from dividers where possible in hardware to be fair an iterative divider would probably work It turns out there is a clever way of doing this called the Double Dabble algorithm no really</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/double_dabble#double-then-dabble</url>
    <fullTitle>Hardcaml: 4.3.2 Double Dabble, Double, then Dabble [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The idea is we form a large shift register with the BCD values at the MSB and the binary value at the LSB We shift the whole thing left by one bit this is the double part then run through each of the 4 bit BCD values and if it is greater then 4 add 3 Repeat for all the bits in the input binary value One way to think of this is we are bypassing the carry logic of a normal binary number and adding a special value which upon doubling will correctly overflow into the next BCD digit The algorithm is shown below while the idea is not complicated there is a bunch of annoying bit fiddling going on in order to pack and then extract the appropriate bits from an int value BCDN BCD1 BCD0 BINARY let double_dabble value let digits String length Int to_string value in let num_bits Int ceil_log2 value 1 in let value ref value in for _ 0 to num_bits 1 do for j 0 to digits 1 do let digit value lsr num_bits j * 4 land 0xf in if digit > 5 then value value 3 lsl num_bits j * 4 done value value lsl 1 done let bcd value lsr num_bits in List init digits f fun i > bcd lsr i * 4 land 0xf |> List rev |> List map f fun i > Char of_int_exn i Char to_int 0 |> String of_char_list let%expect_test Test algorithm for i 0 to 1000 do assert String equal Int to_string i double_dabble i done %expect | |</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/double_dabble#implementing-the-hardware</url>
    <fullTitle>Hardcaml: 4.3.2 Double Dabble, Implementing the Hardware [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>A state machine will implement the algorithm There are 3 states wait for a signal to be valid along with the binary value to convert shift the binary value and all the BCD digits up by 1 bits Go to if all the input bits are processed otherwise go to iterate through the BCD digits if the value is greater than 4 then add 3 Go back to In we need to shift up the BCD values This is done by selecting the msb of the previous bcd register and shifting it in expect for index 0 where we select the msb of the input binary value In we iterate through each BCD digit if we have 3 digits it will take 3 cycles On each cycle we use to enable the write to the appropriate BCD digit register This is created using the function which converts values as follows > > > > We could have implemented the write enable check as but the onehot version is a bit more efficient Finally note that we write the value to every BCD digit register guarded by the write enable This value is created by multiplexing the BCD registers based on then performing the dabble check This is important there is only one instantiation of the check not one per digit Start start Double Start Dabble Dabble Double module Make Digits sig val num_digits int end struct open Digits * Bits required to represent 999 999 * let binary_bits num_bits_to_represent Int pow 10 num_digits 1 module State struct type t | Start | Double | Dabble @@deriving sexp_of compare localize enumerate end let create clock start binary_in let spec Reg_spec create clock in * Registers to latch the input binary value and count through it s bits * let binary Always Variable reg spec width binary_bits in let bit_count Always Variable reg spec width Int ceil_log2 binary_bits in * Register to count through digits while dabbling * let digit_count Always Variable reg spec width Int ceil_log2 num_digits in * One digit count to use as a register write enable for the BCD digits * let digit_count_one_hot binary_to_onehot digit_count value in * Registers for the BCD digit * let bcd Array init num_digits f fun _ > Always Variable reg spec width 4 in * Dabbling logic look up the current BCD digit and perform dabble operation if greater than 4 * let bcd_dabbled let digit mux digit_count value List map Array to_list bcd f fun bcd > bcd value in mux2 digit > 4 digit 3 digit in * Statemachine * let sm Always State_machine create module State spec in Always compile sm switch Start * Wait for start * bit_count &lt; 0 binary &lt; binary_in proc List init num_digits f fun digit > bcd digit &lt; 0 when_ start sm set_next Double Double * Shift in the next binary bit through all the BCD registers * binary &lt; sll binary value by 1 proc List init num_digits f fun digit > bcd digit &lt; lsbs bcd digit value @ if digit 0 then msb binary value else msb bcd digit 1 value digit_count &lt; 0 bit_count &lt; bit_count value 1 * Count through all the input binary bits * if_ bit_count value binary_bits 1 sm set_next Start sm set_next Dabble Dabble * Iterate through each digit and perform the dabble operation * digit_count &lt; digit_count value 1 proc List init num_digits f fun digit > when_ digit_count_one_hot digit bcd digit &lt; bcd_dabbled when_ digit_count value num_digits 1 sm set_next Double sm is Start Array map bcd f fun bcd > bcd value end Double Dabble digit_count_one_hot binary_to_onehot 00 0001 01 0010 10 0100 11 1000 digit_count value index bcd_dabbled digit_count</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/double_dabble#testing</url>
    <fullTitle>Hardcaml: 4.3.2 Double Dabble, Testing [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>We need to create a a simulator and provide access to the input and output ports The following code does this We will soon learn about which makes a lot of this boilerplate code go away There is nothing interesting going on here just definition of string names for circuit ports then constructing a simulator and looking up the ports Below we write exhaustive testbenches for 2 3 and 4 digit conversions Circuit Cyclesim Interfaces module Make_sim Digits sig val num_digits int end struct open Digits include Make Digits let circuit let done_ bcd create clock input clock 1 start input start 1 binary_in input binary binary_bits in Circuit create_exn name double_dabble output done done_ Array to_list Array mapi bcd f fun i > output %string bcd% i#Int type ports start Bits t ref binary_in Bits t ref done_ Bits t ref bcd Bits t ref array let sim let sim Cyclesim create circuit in sim start Cyclesim in_port sim start binary_in Cyclesim in_port sim binary done_ Cyclesim out_port sim done bcd Array init num_digits f fun i > Cyclesim out_port sim %string bcd% i#Int end let create_test num_digits let module Bcd Make_sim struct let num_digits num_digits end in let open Bits in let sim ports Bcd sim in Cyclesim cycle sim let test value * Start the statemachine * ports start Bits vdd ports binary_in &lt; value Cyclesim cycle sim ports start Bits gnd * Wait for it to complete * while not Bits to_bool ports done_ do Cyclesim cycle sim done * Convert the BCD output to a string * Array map ports bcd f fun bcd > Char of_int_exn Bits to_unsigned_int bcd Char to_int 0 |> Array to_list |> List rev |> String of_list in test let%expect_test 2 digits let num_digits 2 in let test create_test num_digits in for i 0 to Int pow 10 num_digits 1 do assert Int of_string test i i done %expect | | let%expect_test 3 digits let num_digits 3 in let test create_test num_digits in for i 0 to Int pow 10 num_digits 1 do assert Int of_string test i i done %expect | | let%expect_test 4 digits let num_digits 4 in let test create_test num_digits in for i 0 to Int pow 10 num_digits 1 do assert Int of_string test i i done %expect | |</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/instantiation</url>
    <fullTitle>Hardcaml: 4.4 Instantiation,  [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>An instantiation creates a placeholder for a named sub circuit with specified input and output ports This placeholder can be later filled in with an implementation it could be a Verilog design a vendor macro or even another Hardcaml circuit Three arguments must be supplied of the sub circuit a list of port names and the signal they should attach to a list of port names and the width of the port The returned type can be queried using to retrieve a signal for an output port returns a map of output name to signal Parameters External hardware designs are often configured using parameters in Verilog or generics in VHDL The optional argument allows them to be specified It takes a list of s Each parameter is specified using a and a with a value Various types are supported including and various bit and vector types associated with Verilog and VHDL etc Instantiation control The optional parameter can provide a label for the specific instantiation of a sub circuit Note that a sub circuit can be instantiated multiple times and each one must have a different label Hardcaml will appropriately mangle labels so they are unique but a human can usually come up with better names and are concepts related to library management in VHDL Hardcaml instantiates in VHDL using the syntax to avoid writing out component declarations By default and are used External IP Instantiations can reference hardware designs written in another hardware description language HDL such as Verilog or VHDL and connect them to a Hardcaml design Such designs contain a hole from Hardcaml s point of view As such it will no longer be possible to simulate them with They can be linked with the external design by an HDL simulator or the Vendor implementation tools In some cases you may be able to leverage to convert a Verilog design to a Hardcaml circuit which can be simulated Hardcaml sub circuits We can also instantiate sub circuits that we actually do have a Hardcaml implementation of This approach is used to describe module hierarchies in Hardcaml Hardcaml can link such designs together allowing them to be simulated # Instantiation create lib string > arch string > instance string > parameters Parameter t list > attributes Hardcaml Rtl_attribute t list > unit > name string > inputs string * Signal t list > outputs string * int list > Instantiation t &lt;fun> name inputs outputs Instantiation output # let the_instantiation let a Signal input a_in 2 in let b Signal input b_in 4 in Instantiation create name my_sub_circuit_name inputs a a b b outputs x 5 y 10 val the_instantiation Instantiation t &lt;abstr> # Instantiation output the_instantiation x Signal t select width 5 range 4 0 data_in instantiation # Instantiation output the_instantiation y Signal t select width 10 range 14 5 data_in instantiation Instantiation outputs # Instantiation outputs the_instantiation Signal t Base Map M Base String t &lt;abstr> parameters Parameter t # let parameter Parameter create name bus_width value Int 3 val parameter Parameter t Hardcaml Parameter name &lt;abstr> value Hardcaml Parameter Value Int 3 name type Int String Bool Real Bit Std_logic_vector instance lib arch entity &lt;lib> module_name &lt;arch> ` work rtl Cyclesim hardcaml_of_verilog</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/structural</url>
    <fullTitle>Hardcaml: 4.5 Working with Structural,  [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text></text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/structural#what-is-it</url>
    <fullTitle>Hardcaml: 4.5 Working with Structural, What is it? [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Structural provides functions to generate hardware circuits In fact its functionality is very similar to right down to supporting the standard Comb S API That said there are some difference with respect the s and s Introducing tristates Structural is not quite as silly as it seems There is something that Hardcaml s do not support that we sometimes need tristate values A tristate value also called a three state value is a digital signal that can exist in one of three possible states Logic high 1 Logic low 0 High impedance Z First of all why don t s support tristates They could but it would make many internal parts of the library much more complicated to do so Indeed all the backend generators simulators and so on would need to be updated to support them and we would also have to use a multi value logic type to do this properly So instead we provide a cut down version of which supports tristates instantiation writing to Verilog and nothing else Why do we need tristates Most of the time we don t They are not generally used inside most logic designs However when we interact with the outside world ie via the pins on a chip we quite often DO need to support tristates Some chips will use tristate signals to daisy chain multiple devices or reduce pin count If we didn t provide a way to describe tristates the top level most module of a full hardware design would still need to be described in a traditional HDL like Verilog This is what is for describing a design top level where we need support for tristates Hardcaml Signal instantiation wire Signal Signal Structural Signal Structural</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/structural#api</url>
    <fullTitle>Hardcaml: 4.5 Working with Structural, API [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Circuits In structural signals are recorded into a database rather than discovered dynamically as with s To do this we must first call and when done call Ports Input ports are created with Output ports are created with Tristate ports are created with Instantiation Instantiations work a little differently than with s The inputs outputs and tristate ports of the instantiated circuit are all passed to the function Basic example Circuits must have unique names API functions A small set of functions are natively supported by and In addition assignment is performed with Using Lib The complete API be provided by instantiating the functor note this must be done within a started circuit This uses hardcaml to create implementations for each operation and allows them to be instantiated within circuits We have used a new function here called It will automatically call and and return the generated structural circuit The and functions have created instantiations for the operators We can get their implementations as follows Describing a tristate mux Tristate logic can also be generated by rather than just passing through wires Signal start_circuit name end_circuit mk_input mk_output mk_tristate Signal inst # open Hardcaml Structural # let gen start_circuit example let i mk_input i 1 in let o mk_output o 1 in let t mk_tristate t 1 in inst inner i i > i o o > o t t > t end_circuit to_verilog find_circuit example |> Rope to_string |> print_string val gen unit > unit &lt;fun> # gen module example input i output o inout t inner _4 i i o o t t endmodule unit # gen Exception Hardcaml__Structural Circuit_already_exists example Structural of_bit_string mux concat_msb select &lt; # let gen start_circuit example2 let i mk_input i 3 in let o mk_output o 2 in o &lt; concat_msb of_bit_string 1 mux select i high 0 low 0 select i high 1 low 1 select i high 2 low 2 end_circuit to_verilog find_circuit example2 |> Rope to_string |> print_string val gen unit > unit &lt;fun> # gen module example2 input 2 0 i output 1 0 o wire _3 wire _4 wire _5 wire _6 wire _7 wire 1 0 _8 assign _3 i 2 2 assign _4 i 1 1 assign _5 i 0 0 assign _6 _5 0 _4 _3 assign _7 1 b1 assign _8 _7 _6 assign o _8 endmodule unit Comb Structural Lib Structural # let circuit create_circuit example3 fun > let open Lib in let a mk_input a 3 in let b mk_input b 3 in let addsub mk_input addsub 1 in let c mk_output c 3 in c &lt; mux2 addsub a b a b val circuit circuit &lt;abstr> # to_verilog circuit |> Rope to_string |> print_string module example3 input 2 0 a input 2 0 b input addsub output 2 0 c wire _1 wire _2 wire 2 0 _7 wire 2 0 _9 wire 2 0 _11 assign _1 1 b1 assign _2 1 b0 assign _11 addsub 0 _7 _9 assign c _11 hardcaml_lib_sub_3 _8 i0 a i1 b o _7 hardcaml_lib_add_3 _10 i0 a i1 b o _9 endmodule unit create_circuit start_circuit end_circuit # let components structural_rtl_components circuit val components Base Set M Hardcaml Structural Structural_rtl_component t &lt;abstr> # Set iter components f fun subcircuit > let subcircuit Structural_rtl_component rtl_circuit subcircuit in Hardcaml Rtl print Verilog subcircuit module hardcaml_lib_add_3 i1 i0 o input 2 0 i1 input 2 0 i0 output 2 0 o wire 2 0 _4 assign _4 i0 i1 assign o _4 endmodule module hardcaml_lib_sub_3 i1 i0 o input 2 0 i1 input 2 0 i0 output 2 0 o wire 2 0 _4 assign _4 i0 i1 assign o _4 endmodule unit Structural # let circuit create_circuit example4 fun > let d mk_input d 1 in let sel mk_input sel 1 in let t mk_tristate t 1 in t &lt; mux sel d z 1 val circuit circuit &lt;abstr> # to_verilog circuit |> Rope to_string |> print_string module example4 input d input sel inout t wire _4 wire _5 assign _4 1 bz assign _5 sel 0 d _4 assign t _5 endmodule unit</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/conversion-to-rtl</url>
    <fullTitle>Hardcaml: 4.6 How Hardcaml Converts Signals,  [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Hardcaml defines an OCaml variant type called which expresses the RTL structures it can describe How this is converted to RTL explains a lot about the various choices we make in the Hardcaml API Below we will show how every variant in is converted to Verilog Conversion to VHDL is very similar Note that this really is all of the primitives in Hardcaml There are not very many and all other features of Hardcaml are built atop them The correctness of the generated code will depend on rules that Hardcaml enforces and we will highlight where that is the case The following rules are applied in order to try to make the resulting Verilog constructs trivial to understand Widths of arguments are restricted so we do not have to understand any weird Verilog auto conversion rules The width of the LHS and RHS of assignments are nearly always the same comparison and multiplication being exceptions Assignments are complete which generally means where we generate a Verilog construct we will include a branch Signal Type t Signal Type t case default</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/conversion-to-rtl#simple-operations</url>
    <fullTitle>Hardcaml: 4.6 How Hardcaml Converts Signals, Simple Operations [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>We will quickly go through a number of simple operations which convert trivially to RTL Constants Constants are always written in binary form Concatenation The width of the result is the sum of the width of all the elements in the concatenation Wires Wires just make a copy The only interesting thing in the generated RTL is that wires are declared before they are assigned which is a requirement to allow them to perform cyclic references Select The rules of the Hardcaml function ensure that the Verilog selection cannot access out of range bits wire 4 0 _123 assign _123 5 b10001 wire 23 0 _123 assign _123 _33 _87 _43 wire 3 0 a_wire assign a_wire _123 wire 2 0 _123 assign _123 _55 3 1 select</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/conversion-to-rtl#arithmetic-operators</url>
    <fullTitle>Hardcaml: 4.6 How Hardcaml Converts Signals, Arithmetic Operators [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Addition and subtraction The Hardcaml rules are that the arguments and result must all be of the same width Thus we write Given and are the same size as the result it doesn t matter if we consider them to be signed or unsigned the resulting bit pattern is the same The same is true of subtraction Multiplication We must differentiate between signed and unsigned multiplication For unsigned we write By default Verilog performs unsigned multiplication The result width is the sum of the width of the arguments To perform signed multiplication we write wire 7 0 _123 assign _123 a b a b wire 8 0 _123 assign _123 a * b wire 8 0 _123 assign _123 $signed a * $signed b</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/conversion-to-rtl#logical-operators</url>
    <fullTitle>Hardcaml: 4.6 How Hardcaml Converts Signals, Logical Operators [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The and logical operations are defined similarly to addition and subtraction in that the result and arguments must have the same width is also similar except that it only has one argument and or xor wire 7 0 _123 assign _123 a ^ b not wire 7 0 _123 assign _123 a</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/conversion-to-rtl#comparison-operators</url>
    <fullTitle>Hardcaml: 4.6 How Hardcaml Converts Signals, Comparison Operators [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Hardcaml provides 2 comparison operators equals and unsigned less than The result of both is a single bit The arguments are the same width And less than Hardcaml synthesizes the full set of comparison operators for both signed and unsigned arguments using these two primitives and the operator wire _123 assign _123 a b wire _123 assign _123 a &lt; b not</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/conversion-to-rtl#mux</url>
    <fullTitle>Hardcaml: 4.6 How Hardcaml Converts Signals, Mux [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>A Hardcaml mux takes a select signal and some number of data inputs The final data input is repeated enough times to create a complete mux structure For example our select could be 3 bits and we provide 5 data inputs The last value will be repeated and used for indices 5 6 and 7 These rules are encoded by using a case statement with a default branch Even if the case is complete a default branch is written case select 0 _123 &lt; _1 1 _123 &lt; _2 2 _123 &lt; _3 3 _123 &lt; _4 default _123 &lt; _5 endcase case select 0 _123 &lt; _1 1 _123 &lt; _2 2 _123 &lt; _3 3 _123 &lt; _4 4 _123 &lt; _5 5 _123 &lt; _6 6 _123 &lt; _7 default _123 &lt; _8 endcase</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/conversion-to-rtl#cases</url>
    <fullTitle>Hardcaml: 4.6 How Hardcaml Converts Signals, Cases [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The Hardcaml variant also generates a Verilog case statement but the branch match values do not have to be successively incrementing constants starting at 0 as with a mux We do however need to provide a default value As with muxes we ensure that no matter what select value is provided the result value must be driven Cases case select 3 _123 &lt; _1 7 _123 &lt; _2 9 _123 &lt; _4 default _123 &lt; _5 endcase</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/conversion-to-rtl#registers</url>
    <fullTitle>Hardcaml: 4.6 How Hardcaml Converts Signals, Registers [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Register are written using the following general template The asynchronous reset synchronous clear and enable are all optional If they are not present Hardcaml will not write out that part of the template reset clear and enable must all be 1 bit wide The register input value reset to value and clear to value are all the same width as the result value Hardcaml further supports negative edge clocks always @ posedge clock posedge reset if reset 1 b1 q &lt; 1 b0 else if clear 1 b1 q &lt; 1 b0 else if enable 1 b1 q &lt; d</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/conversion-to-rtl#memories</url>
    <fullTitle>Hardcaml: 4.6 How Hardcaml Converts Signals, Memories [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Hardcaml memories are defined in two parts the memory array itself along with its write logic and one or more read ports These memory structures describe asynchronous read memories that may be converted to synchronous by registering the address es or output port s Hardcaml memories may have multiple read and or write ports though only specific instances will be inferred into actual hardware memories otherwise we describe potentially inefficient register banks The above may be written once for each provided write port Read ports are written as Again we will get similar code for each read port reg 7 0 mem 0 3 always @ posedge clock if write_enable mem write_address &lt; write_data assign q mem read_address</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/more-on-circuit-design/conversion-to-rtl#instantiations</url>
    <fullTitle>Hardcaml: 4.6 How Hardcaml Converts Signals, Instantiations [More On Circuit Design]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Instantiations are written into the RTL following the specification of inputs and outputs given in Hardcaml Note that there is a single output vector defined for all the output ports from which each individual output will then be selected This makes the traversal of the Hardcaml signal graph simpler at the cost of slightly more verbose RTL foo the_foo i i o1 _123 3 0 o2 _123 5 3</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/hardcaml_interfaces</url>
    <fullTitle>Hardcaml: 5.1 Hardcaml Interfaces,  [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Abstractly Hardcaml interfaces are made up of a polymorphic type with a single polymorphic variable and a set of functions which can manipulate that type In addition they contain a field which specifies for each contained in a string name which can be used to label the value and the bit width of it s representation as hardware Most commonly an interface will be of type where it will represent a set of Hardcaml signals within a hardware design or where it is used to interact with a Hardcaml simulator Interfaces actually contain many more convenience functions though they can all be derived from the functions shown above Record interfaces The most common form of interface is a record Below we implement an interface by hand for a record containing two fields and In the value we gave a 32 bit width to foo and a 1 bit width to bar Note also the names we specified were not the same as the record field name although much of the time it makes most sense if they are To reduce the amount of boilerplate code to write we provide a ppx called which can generate the above code for you from the type definition The type definition derives Hardcaml and various annotations exist to customize the names and widths of each field Note that each field in the record must be of type Some simple setup is required to use Hardcaml interfaces namely installing and adding it as a preprocessor in the build system Using interfaces Lets say defined the outputs of some hardware module Generally we would write something like Instead we can write Now lets say we have built a simulator over this module and want access to the output ports Other types of interface There are various use cases for interfaces where the outer type is not a record are one example and will be described later s are another where we abstract a Hardcaml value by restricting access to it s implementation They often come with a specialized API for manipulating the value type a t @@deriving sexp_of val iter a t > f a > unit > unit val iter2 a t > b t > f a > b > unit > unit val map a t > f a > b > b t val map2 a t > b t > f a > b > c > c t val to_list a t > a list val port_names_and_widths string * int t a a t Signal t t Bits t t foo bar module Explicit_interface_record_implementation struct module T struct type a t foo a bar a @@deriving equal localize sexp_of let map t f foo f t foo bar f t bar let map2 s t f foo f s foo t foo bar f s bar t bar let iter t f f t foo f t bar let iter2 s t f f s foo t foo f s bar t bar let to_list t t foo t bar let port_names_and_widths foo FOO_FOO 32 bar BAR_BAR 1 end include T include Hardcaml Interface Make T end port_names_and_widths ppx_hardcaml a module Simple_interface struct type a t foo a @bits 32 * Where a bit width is not specified it defaults to 1 * bar a @@deriving hardcaml end ppx_hardcaml Simple_interface let circuit Circuit create_exn name test output foo outputs foo output bar outputs bar let circuit Circuit create_exn name test Simple_interface map2 port_names outputs f Signal output |> to_list let outputs Simple_interface map port_names f Cyclesim out_port sim Enums Scalar</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/hardcaml_interfaces#complete-interface-api</url>
    <fullTitle>Hardcaml: 5.1 Hardcaml Interfaces, Complete Interface API [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Map and Iter and functions are provided with up to 5 arguments Zip Between 2 and 5 interfaces can be combined using zip The result is an interface of tuples Fold and Scan passes each field of an interface along with an accumulator to the given function For example we can compute the total width of an interface as follows note this is also provided by the value is similar except it returns an interface The function returns the next value of the accumulator and the value of the result field We can compute the offset of each field in an interface as follows note this is also provide by the function and are also defined Association lists and Tags An interface can be converted to and from an association list with and Note that we do not choose to use the string name of fields as keys rather we define and abstract type and value which uniquely represent each fields in an interface Lists of Interfaces and convert between a list of interfaces and interface of lists The signatures should make the operation clearer Misc functions and provide direct access to the names and widths of fields in an interface sets each field to the value Of_signal and Of_bits Both these modules implement the signature They provides functions specialized to the types and respectively Converting from Ints and set each field to the given value by converting from a given integer and also convert from integers but each field may be specified individually Pack and Unpack flattens an interface into a single vector by concatenating all the fields reverses the operation Muxs selects between 2 interfaces and selects between an arbitrary number of interfaces Selection and all work the same way as the corresponding versions on normal signals expect they operate on all fields at once Of_signal specifics A few further functions apply only to the type creates an interface of wires performs wire assignment should be an interface of wires and apply registers or a pipeline of registers to the given interface and create the input and output ports for circuits will apply names to each field based on and a given prefix and suffix Of_always operates on interfaces of type converts an interface of variables to an interface of signals assigns variables with values It results in an always statement and define interfaces of variables will apply names to each field based on and a given prefix and suffix map iter # map5 a Simple_interface t > b Simple_interface t > c Simple_interface t > d Simple_interface t > e Simple_interface t > f a > b > c > d > e > f > f Simple_interface t &lt;fun> # zip port_names port_widths string * int Simple_interface t foo foo 32 bar bar 1 fold f # fold port_widths init 0 f fun total width > total width int 33 sum_of_port_widths scan f # scan port_widths init 0 f fun acc width > acc width acc int Simple_interface t foo 0 bar 32 offsets fold2 scan2 to_alist of_alist tag tags of_interface_list to_interface_list # of_interface_list a Simple_interface t list > a list Simple_interface t &lt;fun> # to_interface_list a list Simple_interface t > a Simple_interface t list &lt;fun> port_names string t port_widths int t const c c Interface Comb Signal t t Bits t t of_unsigned_int of_signed_int of_int_trunc of_unsigned_ints of_signed_ints of_ints_trunc pack unpack mux2 mux priority_select priority_select_with_default onehot_select Signal t t wires assign a b a reg pipeline inputs outputs apply_names port_names Of_always Always Variable t t value assign reg wire apply_names port_names</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/interfaces_with_ppx_hardcaml</url>
    <fullTitle>Hardcaml: 5.2 Interfaces with ppx_hardcaml,  [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text></text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/interfaces_with_ppx_hardcaml#interfaces-with-ppx_hardcaml</url>
    <fullTitle>Hardcaml: 5.2 Interfaces with ppx_hardcaml, Interfaces with ppx_hardcaml [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>By default the ppx uses the field name for the string name and attribute to specify the field width if not provided it defaults to The ppx supports nesting arrays lists and various tools to manage port naming Nesting Interfaces can contain other interfaces Nesting can go as deep as required Arrays and lists For s and s the lengths must be specified with an attribute Arrays of nested interfaces are also supported Options Fields in an interface may be optional Simple and nested fields are supported The attribute controls if they are included in the interface or not and must be specified Such fields can arise when describing a circuit generator where some configuration option may require extra inputs or outputs module Simple_interface struct type a t foo a @bits 32 bar a * Where a bit width is not specified it defaults to 1 * @@deriving hardcaml end # print_s %message Simple_interface port_names_and_widths string * int Simple_interface t Simple_interface port_names_and_widths foo foo 32 bar bar 1 unit @bits N 1 module Nested_interfaces struct type a t clock a clear a hello a Simple_interface t world a Simple_interface t @@deriving hardcaml end array list module Array_and_list_interfaces struct type a t my_array a array @length 2 my_list a list @length 10 @bits 10 @@deriving hardcaml end module Interface_with_option struct type a t maybe_x a option @exists true @bits 3 maybe_y a Simple_interface t option @exists false @@deriving hardcaml end exists</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/interfaces_with_ppx_hardcaml#naming</url>
    <fullTitle>Hardcaml: 5.2 Interfaces with ppx_hardcaml, Naming [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Naming simple fields By default the field name is used to derive a port name Port names will be used during RTL generation This can be modified with attributes overrides the fields name with the given string apply the given prefix and or suffix to the name and attributes may also be used with nested interfaces though will not work Naming nested interfaces and can be applied to nested interfaces and will apply the given prefix or suffix to each field within the nested interface By default we automatically mangle nested interface names by prefixing them with the field name and a separator to avoid name clashes This functionality can be disabled with or customized by specifying a different separator Global attributes The naming attributes can be specified for all fields as follows and are supported rtlname rtlprefix rtlsuffix module Unmodified_port_names struct type a t a a b a c a @@deriving hardcaml end module Modified_port_names struct type a t a a @rtlname aaa b a @rtlprefix x_ c a @rtlsuffix _x @@deriving hardcaml end # Unmodified_port_names port_names string Unmodified_port_names t Unmodified_port_names a a b b c c # Modified_port_names port_names string Modified_port_names t Modified_port_names a aaa b x_b c c_x rtlprefix rtlsuffix rtlmangle rtlname rtlprefix rtlsuffix $ # Nested_interfaces port_names string Nested_interfaces t Nested_interfaces clock clock clear clear hello Simple_interface foo hello$foo bar hello$bar world Simple_interface foo world$foo bar world$bar rtlmangle false module Nested_interfaces_mangled struct type a t clock a clear a hello a Simple_interface t world a Simple_interface t @@deriving hardcaml rtlmangle _ end # Nested_interfaces_mangled port_names string Nested_interfaces_mangled t Nested_interfaces_mangled clock clock clear clear hello Simple_interface foo hello_foo bar hello_bar world Simple_interface foo world_foo bar world_bar module Global_suffix struct type a t a a b a c a @@deriving hardcaml rtlsuffix _i end rtlprefix rtlsuffix rtlmangle</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/module_interfaces</url>
    <fullTitle>Hardcaml: 5.3 Module Interfaces,  [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text></text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/module_interfaces#module-interfaces</url>
    <fullTitle>Hardcaml: 5.3 Module Interfaces, Module Interfaces [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The primary use of interfaces is to define a general pattern to describe a Hardcaml module We will specify two interfaces called and which represent the input and output signals of a module along with a function called to generate the logic Hardcaml provides various functors usually called that will generate circuits simulators hierarchical instantiations and more if we follow this pattern  The type of the create function does not have to precisely follow this signature It is fine to have further arguments i e some configuration parameters so long as it ends with Example With_interface Hardcaml supports this pattern by providing a number of functors usually called They take the and interfaces as parameters and will provide a function which takes For example we can create a circuit as follows In contrast this is what we would write without interfaces As the number of signals into and out of a module grows and 100 s or even 1000 s is not infeasible the utility of interfaces to deal with boilerplate grows Configuration When we define an interface we specify things like bit widths field existence using options and array or list lengths However we often want to write something more generic To do this we can use functors Taking the previous example lets make the register width configurable We can now instantiate the functor and generate a circuit as before Interface type in equality Consider the following 2 instantiations of our design Inside each instantiation we have records of type and They have exactly the same definition so are the types equal No Because they are created inside a functor distinct types are generated On the other hand would we like them to be equal I would argue no Because they represent interfaces with different bitwidths I would like the type system to differentiate them On occasion it is useful to expose the type equality and it can still be done takes an existing interface and redefines the names and bitwidths of the fields The type constraint exposes the desired equality As shown below the types of and are compatible I O create module I Interface S module O Interface S val create Signal t I t > Signal t O t With_interface Signal t I t > Signal t O t module I struct type a t clock a d a @bits 8 @@deriving hardcaml end module O struct type a t q a @bits 8 q_n a @bits 8 @@deriving hardcaml end # let create i _ I t let q reg Reg_spec create clock i clock i d in O q q_n q val create t I t > t O t &lt;fun> With_interface I O create # module My_circuit Circuit With_interface I O module My_circuit sig type create Hardcaml Interface Create_fn I O t val create_exn config Circuit Config t > input_attributes Rtl_attribute t list I t > output_attributes Rtl_attribute t list O t > name string > create > Circuit t end # My_circuit create_exn name reg create Circuit t &lt;abstr> # let create2 clock d let q reg Reg_spec create clock d in q q val create2 clock t > d t > t * t &lt;fun> # let q q_n create2 clock input clock 1 d input d 8 val q t register width 8 clock clock clock_edge Rising data_in d val q_n t not width 8 arguments register # Circuit create_exn name reg output q q output q_n q_n Circuit t &lt;abstr> module Make Config sig val register_width int end struct module I struct type a t clock a d a @bits Config register_width @@deriving hardcaml end module O struct type a t q a @bits Config register_width q_n a @bits Config register_width @@deriving hardcaml end let create i _ I t let q reg Reg_spec create clock i clock i d in O q q_n q end module My_design Make struct let register_width 4 end module My_circuit2 Circuit With_interface My_design I My_design O # My_circuit2 create_exn name reg My_design create Circuit t &lt;abstr> module My_design16 Make struct let register_width 16 end module My_design32 Make struct let register_width 32 end I t O t module X struct type a t x a @@deriving hardcaml end module Make_X Config sig val width int end Interface S with type a t a X t struct include Interface Update X struct let port_names_and_widths X x x Config width end end Interface Update with type a t a X t module Y Make_X struct let width 10 end module Z Make_X struct let width 20 end Y t Z t # Y port_names Z port_names string Z t list X x x X x x</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/simulating_with_interfaces</url>
    <fullTitle>Hardcaml: 5.4 Simulating with Interfaces,  [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>With standard Hardcaml simulations we are forced to manage input and output ports manually using the strings Interfaces allow us to automate much of this work and are particularly useful as circuits get more complex The following is a common pattern for specifying a hardware circuit It consists of an input and output interface and a function over these interfaces which constructs the logic To simulate this we can use the functor This will automatically create a circuit with the input and output ports labeled build a simulator and then construct input and output records for driving the simulator All this and we never have to worry about the underlying string names of ports Notice the type signature of The parametric type arguments to encode the types returned when retrieving the inputs and output values from the simulator object Driving the inputs and reading outputs can be performed via the convenience of record fields open Base open Hardcaml * Input interface * module I struct type a t clock a foo a @bits 8 bar a @bits 8 @@deriving hardcaml end * Output interface * module O struct type a t baz a @bits 8 baz_delayed a @bits 8 @@deriving hardcaml end let create i Signal t I t Signal t O t let open Signal in let spec Reg_spec create clock i clock in let baz i foo i bar in let baz_delayed reg enable vdd spec baz in O baz baz_delayed Cyclesim With_interface # let create_sim let module Sim Cyclesim With_interface I O in Sim create create val create_sim unit > Bits t ref I t Bits t ref O t Cyclesim t &lt;fun> _ _ Cyclesim t Cyclesim t # let run_sim let sim create_sim in let inputs Cyclesim inputs sim in let outputs Cyclesim outputs sim in let print_outputs Stdio print_s %sexp_of int O t O map outputs f fun p > Bits to_unsigned_int p in inputs foo Bits of_unsigned_int width 8 1 inputs bar Bits of_unsigned_int width 8 2 Cyclesim cycle sim print_outputs inputs foo Bits of_unsigned_int width 8 7 inputs bar Bits of_unsigned_int width 8 9 Cyclesim cycle sim print_outputs val run_sim unit > unit &lt;fun> # run_sim baz 3 baz_delayed 3 baz 16 baz_delayed 16 unit</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/enums_in_hardcaml</url>
    <fullTitle>Hardcaml: 5.5 Enums in Hardcaml,  [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Hardcaml provides support for enumerations with a finite number of instances through the Enum module An Enum type declares a finite ie non recursive set of variants and requires a deriving specification as follows The variant cases defining an enum may in turn have arguments which are also Enums The functor creates two modules called and Each of these modules conforms to the signature so they can be treated as regular Hardcaml interfaces The parameter specifies the underlying type of the enum ie in designing circuits it would be and in simulations it will be Both variants have a similar API differing only in their encoding as a bit vector From here on we will demonstrate the API The generated modules contain functions to transform statically known enums into arbitrary desired so long the provided satisfied the interface Both and shipped with Hardcaml support them You get several enum specific features for defining circuits in the regular Signal like API notably the function for multiplexing on the enum value Note that this differs from which creates a multiplexer that returns a value of the type enum The function is also defined for the Always API which makes it really clean to write pattern match like applications on enums Similar to there is an optional argument for non exhaustive matches This generated enum module implements the so you get access to the various convenient functions defined in and For example The generated enum can even be used as part of regular Hardcaml interfaces This makes Hardcaml Enums powerful since the circuit interfaces can simply use it without nasty type conversions For example For more advanced usage you can convert to the underlying or value The function only performs checks on widths It is the caller s responsibility to ensure that when it s the provided raw value is always one hot when it s the provided raw value should be strictly less than the number of possible cases Enums are well supported in simulations too Let s make a little state machine that increments or decrements a counter based on an enum s input value The module simulation will also output the previous clock cycle s enum input Since these enum files are not simply of type we need to opt for special APIs for getting setting them in simulations Using those functions we can drive a Hardcaml Cyclesim t similar to regular Hardcaml sims module Simple_enum_example struct module Enum struct type t | Foo | Bar @@deriving sexp_of compare localize enumerate end include Hardcaml Enum Make_enums Enum end open Base open Hardcaml module Foo struct type t | Foo_a | Foo_b @@deriving sexp_of compare localize enumerate end module Bar struct type t | Bar_a | Bar_b | Bar_c @@deriving sexp_of compare localize enumerate end module Hello struct module Enum struct type t | Foo of Foo t | Bar of Bar t @@deriving sexp_of compare localize enumerate end include Hardcaml Enum Make_enums Enum end Make_enums One_hot Binary Hardcaml Interface S a Signal t Bits t ref Binary of_enum a t a Comb S module Bits module Signal # let x Signal t Hello Binary t Hello Binary of_enum module Signal Foo Foo_a val x Signal t Hello Binary t &lt;abstr> # let y Hello Binary Of_signal of_enum Bar Bar_a val y Signal t Hello Binary t &lt;abstr> # let z Hello Binary Of_signal x y val z Signal t const width 1 value 0b0 # let a Hello Binary Of_signal is x Foo Foo_a val a Signal t const width 1 value 0b1 match_ mux let non_exhaustive_matching let open Signal in Hello Binary match_ module Signal * default needs to be specified when the match cases are not exhaustive * default zero 10 x Foo Foo_a ones 10 Bar Bar_a zero 10 * Of_signal match_ is similar to match_ except it does not require an explicit a first class module argument * let exhaustive_matching let open Signal in Hello Binary Of_signal match_ y Foo Foo_a of_unsigned_int width 10 55 Foo Foo_b of_unsigned_int width 10 44 Bar Bar_a of_unsigned_int width 10 66 Bar Bar_b of_unsigned_int width 10 88 Bar Bar_c of_unsigned_int width 10 77 match_ Of_signal match_ default # Hello Binary Of_always match_ default Always t list > Signal t Hello Binary t > Hello Enum t * Always t list list > Always t &lt;fun> # let exhaustive_matching case Hello Binary Of_always match_ default * The default case here * case Foo Foo_a * Some logic here * Bar Bar_a * Even more logic here * val exhaustive_matching Signal t Hello Binary t > Always t &lt;fun> Hardcaml Interface S Of_signal Of_always Of_bits * A multiplexer that returns value of the enum as opposed to multiplexing on the enum itself as match_ does * let multiplexers let selector Signal input selector 2 in Hello Binary Of_signal mux selector of_enum Foo Foo_a of_enum Bar Bar_a of_enum Bar Bar_b of_enum Foo Foo_b let clock Signal input clock 1 let spec Signal Reg_spec create clock * Registers that stores the enum value * let registers Signal t Hello Binary t let wires Hello Binary Of_signal wires in Hello Binary Of_signal reg enable Signal vdd spec wires * Usage in always blocks You can almost seamlessly assign values to them * let _ Always t list let cond Signal input cond 1 in let var Hello Binary Of_always reg enable Signal vdd spec in let assign_hello Hello Binary Of_always assign in Always if_ cond assign_hello var Hello Binary Of_signal of_enum Foo Foo_a @@ * This doesn t make much sense in practice This is just to the value function * assign_hello var Hello Binary Of_always value var module I struct type a t clock a clear a hello a Hello Binary t @@deriving hardcaml end Bits t Signal t of_raw One_hot Binary # let this_will_raise_due_to_a_width_mismatch Hello Binary Of_signal of_raw Signal of_unsigned_int width 30 10 Exception Failure Width mismatch Enum expects 3 but obtained 30 # let this_is_valid_and_fine Hello Binary Of_signal of_raw Signal of_unsigned_int width 3 0 val this_is_valid_and_fine Signal t Hello Binary t &lt;abstr> # let this_is_undefined_and_will_not_raise Hello Binary Of_signal of_raw Signal of_unsigned_int width 3 6 val this_is_undefined_and_will_not_raise Signal t Hello Binary t &lt;abstr> module O struct type a t counter a @bits 32 prev_hello a Hello Binary t @rtlmangle true @@deriving hardcaml end # let create i _ I t let open Signal in let spec Signal Reg_spec create clock i clock clear i clear in let ctr Always Variable reg spec width 32 enable vdd in let prev_hello Hello Binary Of_always reg enable vdd spec in Always compile Hello Binary Of_always match_ i hello * Foo increments * Foo Foo_a ctr &lt; ctr value 1 Foo Foo_b ctr &lt; ctr value 2 * Bar decrements * Bar Bar_a ctr &lt; ctr value 1 Bar Bar_b ctr &lt; ctr value 2 Bar Bar_c ctr &lt; ctr value 3 Hello Binary Of_always assign prev_hello i hello O counter ctr value prev_hello Hello Binary Of_always value prev_hello val create Signal t I t > Signal t O t &lt;fun> Bits t ref # Hello Binary sim_set Bits t ref Hello Binary t > Hello Enum t > unit &lt;fun> # Hello Binary sim_set_raw Bits t ref Hello Binary t > Bits t > unit &lt;fun> # Hello Binary sim_get Bits t ref Hello Binary t > Hello Enum t Or_error t &lt;fun> # Hello Binary sim_get_raw Bits t ref Hello Binary t > Bits t &lt;fun> let sim let module Sim Cyclesim With_interface I O in Sim create create let inputs Cyclesim inputs sim let outputs Cyclesim outputs sim let print let prev_hello Or_error ok_exn Hello Binary sim_get outputs prev_hello in let counter Bits to_unsigned_int outputs counter in Stdio print_s %message prev_hello Hello Enum t counter int # Hello Binary sim_set inputs hello Foo Foo_a unit # Cyclesim cycle sim unit # print prev_hello Foo Foo_a counter 1 unit # Hello Binary sim_set inputs hello Foo Foo_b unit # Cyclesim cycle sim unit # print prev_hello Foo Foo_b counter 3 unit # Hello Binary sim_set inputs hello Bar Bar_a unit # Cyclesim cycle sim unit # Cyclesim cycle sim unit # print prev_hello Bar Bar_a counter 1 unit</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/typed_alu</url>
    <fullTitle>Hardcaml: 5.5.1 Typed ALU,  [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>We saw a simple implementation of an 8 bit ALU before With interfaces and enums we can now express it as follows module Op struct module Enum struct type t | Add | Sub | Mul | Sll | Srl | And | Or | Xor | Not | Less | Equal @@deriving sexp_of compare localize enumerate end include Hardcaml Enum Make_enums Enum end module I struct type a t op a Op Binary t a a @bits 8 b a @bits 8 @@deriving hardcaml end module O struct type a t q a @bits 8 @@deriving hardcaml end let typed_alu op a b _ I t O q Op Binary match_ module Signal default zero 8 op Add a b Sub a b Mul a * b 7 0 Srl srl a by 1 Sll sll a by 1 And a &amp; b Or a | b Xor a ^ b Not a Less uresize a &lt; b width 8 Equal uresize a b width 8</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/scopes</url>
    <fullTitle>Hardcaml: 5.6 Scopes,  [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>A is a mutable object passed between the circuits that form a complete Hardcaml design It performs a number of roles Track the current position within a design hierarchy Control how we elaborate a design Provide a means to generate hierarchy aware names Record sub circuits within a database Capture side band data such as properties and assertions We will shortly learn how to generate hierarchical designs in Hardcaml and s play a key role in that Creating Scopes s take a few interesting arguments which control how a design is elaborated if the entire circuit is flattened or inlined If it will retain hierarchy a useful option when using the Hardcaml waveform viewer that allows it to show the hierarchical structure of a design control how names are generated The defaults are set up to work with the value of but can be overridden Flattening a Design By default s set to This is generally what you want when generating RTL For simulation this wont work our simulators do not support hierarchical designs so this argument should be set to Sub scopes A new sub scope can be created from a scope This is how we record a design hierarchy Sub scopes are just s placed at the appropriate point in the hierarchy Naming signals with Scopes We can define a scope aware naming function with And this is what we should do within hierarchical Hardcaml designs Note that name of is aware of its position within Using Scopes The main thing we need to do is pass a scope argument to every function we define Sub scopes are then created when we create other circuits This is how they track the current hierarchy position However you shouldn t really ever need to actually do anything much with scopes except Create them with set to true or false depending on whether you want to generate RTL or run a simulation Pass them to your create functions Scope t Scope # let scope Scope create val scope Scope t &lt;abstr> Scope flatten_design true false auto_label_hierarchical_ports naming_scheme flatten_design Scope flatten_design false true # let scope Scope create flatten_design true auto_label_hierarchical_ports true val scope Scope t &lt;abstr> let scope Scope sub_scope scope foo Scope # let Scope naming scope val loc %call_pos > Signal t > string > Signal t &lt;fun> # let x Signal of_string 0 x val x Signal t const names foo$x width 1 value 0b0 x foo create let create scope Scope t i _ I t let foo Foo create Scope sub_scope scope foo in flatten_design</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/module_hierarchies</url>
    <fullTitle>Hardcaml: 5.7 Module Hierarchies,  [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Prerequisite Hardcaml interfaces In Hardcaml module hierarchy allows us to partition a design into a tree of sub circuits each generated as its own Verilog or VHDL module when producing RTL output This builds upon instantiation circuit databases s and the design pattern for defining circuits using and interfaces along with a function Module hierarchies provide several important benefits Controls the naming of signals within the design hierarchy Timing reports logic utilization reports from backend vendor tools will be much easier to comprehend Allows better organization of waveforms which can group signals according to the module hierarchy Reduces the size of the generated RTL file where there is substantial logic duplication Provides some options for controlling the backend process of building the final hardware design with vendor tools Scope I O create</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/module_hierarchies#a-design-pattern-for-circuits</url>
    <fullTitle>Hardcaml: 5.7 Module Hierarchies, A Design Pattern for Circuits [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>We extend our previous design pattern for circuits to now include a The and interfaces and the function we already know about is new and is what we use to generate structured multi level Hardcaml designs It s mechanically derived as follows The function is built using the functor It provides a function called that takes and and elaborates it according to whether setting of the root scope Flattened Mode The function calls the function of your submodule directly which inlines all the logic into the parent circuit This results in a single flat module with no hierarchy Hierarchical Mode The function generates an instantiation for our subcircuit then elaborates it separately and stores its implementation in a This maintains proper module hierarchy in the generated RTL Scope t open Hardcaml module type Module_design_pattern sig module I Interface S module O Interface S val create Scope t > Signal t I t > Signal t O t val hierarchical Scope t > Signal t I t > Signal t O t end I O create module I struct type a t clock a clear a foo a @bits 8 @@deriving hardcaml end module O struct type a t foo_d a @bits 8 @@deriving hardcaml end # let create _scope Scope t input Signal t I t let spec_with_clear Signal Reg_spec create clock input clock clear input clear in let foo_d Signal reg spec_with_clear enable Signal vdd input foo in O foo_d val create Scope t > Signal t I t > Signal t O t &lt;fun> hierarchical # let hierarchical scope Scope t input Signal t I t let module H Hierarchy In_scope I O in H hierarchical scope name module_name instance module_instance_2 create input val hierarchical Scope t > Signal t I t > Signal t O t &lt;fun> hierarchical Hierarchy In_scope H hierarchical scope create flatten_design flatten_design true create flatten_design false Circuit_database t</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/module_hierarchies#summary</url>
    <fullTitle>Hardcaml: 5.7 Module Hierarchies, Summary [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>If we follow the design pattern here we must pass a scope to our functions We then use the functor to derive the function When we want to instantiate a subcircuit we call instead of To elaborate a full design we call the top level function with a scope that will set as appropriate As the design is elaborated by calling the functions of subcircuits we will either build a single large fully inlined design or just the top level circuit along with a database containing all the instantiated subcircuits Simulation Here s an example of how we would simulate a hierarchical design RTL generation For RTL generation we need to do a couple of things Create the scope with set to false Construct a Get the circuit database from the scope Pass the circuit database to the function create Hierarchy In_scope hierarchical hierarchical create create flatten_design hierarchical # let create_sim let module Sim Cyclesim With_interface I O in let scope Scope create flatten_design true in Sim create create scope val create_sim unit > Bits t ref I t Bits t ref O t Cyclesim t &lt;fun> flatten_design Circuit Rtl print # let write_verilog let module Circuit Circuit With_interface I O in let scope Scope create flatten_design false in let circuit Circuit create_exn name top create scope in let database Scope circuit_database scope in Rtl print database Verilog circuit val write_verilog unit > unit &lt;fun></text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/naming_with_ppx_hardcaml</url>
    <fullTitle>Hardcaml: 5.8 Naming with ppx_hardcaml,  [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text></text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/naming_with_ppx_hardcaml#naming-with-ppx_hardcaml</url>
    <fullTitle>Hardcaml: 5.8 Naming with ppx_hardcaml, Naming with ppx_hardcaml [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>We have seen the operator which applies a simple string name to a signal We have also seen which creates a naming operator appropriate for the current level in a design hierarchy The Hardcaml ppx provides a syntax which makes it very convenient to apply scoped names to Hardcaml signals Basic use The syntax can be applied to let bindings whose name will then be applied to the expression A must be excuse me for this in scope for the ppx to work An additional syntax allows the naming of s Naming interfaces Interfaces can be named with the ppx Similarly interfaces containing s are named thus Naming with a module path Interface naming is actually done via a more general framework When we write the ppx finds a function called This is given the thing to name and a prefix derived from the scope and binding name and sets the names This can be applied to specialized Hardcaml types and in particular is implemented for Scope naming # let create scope x let%hw y x in y val create Scope t > t > t &lt;fun> # create Scope create of_string 111 t const names y width 3 value 0b000 %hw scope Always Variable # let create scope let%hw_var x Always Variable wire default gnd in x value val create Scope t > t &lt;fun> # create Scope create t wire names x width 1 # let create scope x let%hw X Of_signal foo x in foo val create Scope t > X Of_signal t > X Of_signal t &lt;fun> # create Scope create X x of_string 111 X Of_signal t X x const names foo$x width 3 value 0b111 Always Variable # let create scope x let%hw X Of_always foo X Of_always wire Signal zero in X Of_always value foo val create Scope t > a > t X t &lt;fun> # create Scope create X x of_string 111 t X t X x wire names foo$x width 1 let%hw Module Path Module Path __ppx_auto_name Always State_machine # let create scope let%hw Always State_machine my_state_machine Always State_machine create module State spec in my_state_machine val create Scope t > State t Always State_machine t &lt;fun> # create Scope create State t Always State_machine t Hardcaml Always State_machine current register names my_state_machine width 1 clock 0b0 clock_edge Rising data_in wire is &lt;fun> set_next &lt;fun> switch &lt;fun></text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/naming_with_ppx_hardcaml#tuples</url>
    <fullTitle>Hardcaml: 5.8 Naming with ppx_hardcaml, Tuples [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Bindings which describe a tuple are also supported We can use and with this form also however all components must be of the appropriate and same type ie or or # let create scope x let%hw y z x x 1 in y z val create Scope t > t > t * t &lt;fun> # create Scope create of_string 111 t * t const names y width 3 value 0b000 const names z width 3 value 0b000 %hw_var %hw Module Path Signal t Always Variable t Some_interface t</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/using-interfaces/naming_with_ppx_hardcaml#lists-arrays-and-iarrays</url>
    <fullTitle>Hardcaml: 5.8 Naming with ppx_hardcaml, Lists, Arrays, and Iarrays [Using Interfaces]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The final supported form allows lists arrays and iarrays to be named As might be expected it applies the name along with an index for each element is used for lists of signals and is similarly for arrays and iarrays respectively and expect the list array iarray to contain s These forms may also include a module path for use with interfaces and so on # let create scope x let%hw_list foo x in foo val create Scope t > t list > t list &lt;fun> # create Scope create of_string 111 of_string 101 t list const names foo$0 width 3 value 0b111 const names foo$1 width 3 value 0b101 %hw_list %hw_array %hw_iarray %hw_var_list %hw_var_array %hw_var_iarray Always Variable t</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/counter</url>
    <fullTitle>Hardcaml: 6.1 Counter,  [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The following is a simple 8 bit counter It resets back to 0 when the clear signal is high and counts up when the incr signal is high Otherwise it holds its previous value Design This design although simple shows the usual pattern for defining a circuit in Hardcaml The inputs and outputs of the circuit are specified using interfaces and the circuit is built using a function which takes an input interface and returns an output interface The implementation uses the function This constructs a register with feedback Let s look at each argument in turn packages up the and synchronous clear There are various other arguments which can control an asynchronous reset rising or falling clock edge and so on when high the register will load a new value Otherwise it holds its previous value is the bit width of the register this function receives the current value of the register and computes the next value In this case it increments it by one Testbench The following is a simple testbench for the counter which shows its behavior for different values of and The purpose of a testbench is to set values for the inputs of a circuit and check what values this causes the outputs to take over time Two other implementations With a wire The following implementation shows what is actually happening within the function First a wire is created that can be read when we construct a register It is assigned after we have the register output Wires allow us to describe cyclic logic structures in Hardcaml Note that all such cycles in a hardware design must pass through a sequential element such as a register or memory Cyclic paths that do not are called combinational loops and Hardcaml will detect and raise an error if one is found With the Always DSL We can also describe the counter with the Always DSL Note that we could have encoded the clear and increment logic when we constructed the The Always fragment would then have only consisted of an assignment to open Hardcaml open Hardcaml Signal open Hardcaml_waveterm module I struct type a t clock a clear a incr a @@deriving hardcaml end module O struct type a t dout a @bits 8 @@deriving hardcaml end # let create i _ I t O dout reg_fb Reg_spec create clock i clock clear i clear enable i incr width 8 f fun d > d 1 val create t I t > t O t &lt;fun> reg_fb Reg_spec t clock signal enable width f clear incr module Simulator Cyclesim With_interface I O # let testbench create_design_fn t I t > t O t * Construct the simulation and get its input and output ports * let sim Simulator create create_design_fn in let inputs _ I t Cyclesim inputs sim in let outputs _ O t Cyclesim outputs sim in * Perform a clock cycle Apply the given values to incr and clear Printf the current values of dout * let step clear incr inputs clear if clear 1 then Bits vdd else Bits gnd inputs incr if incr 1 then Bits vdd else Bits gnd Stdio printf dout %s n Bits to_string outputs dout Cyclesim cycle sim in * Run the counter for 6 clock cycles * step clear 0 incr 0 step clear 0 incr 1 step clear 0 incr 1 step clear 1 incr 0 step clear 0 incr 0 step clear 0 incr 0 val testbench t I t > t O t > unit &lt;fun> # testbench create dout 00000000 dout 00000000 dout 00000001 dout 00000010 dout 00000000 dout 00000000 unit reg_fb # let counter_with_wire i _ I t let w wire 8 in let dout reg Reg_spec create clock i clock clear i clear enable i incr w 1 in w &lt; dout O dout val counter_with_wire t I t > t O t &lt;fun> # testbench counter_with_wire dout 00000000 dout 00000000 dout 00000001 dout 00000010 dout 00000000 dout 00000000 unit Always Variable reg dout # let counter_with_always i _ I t let dout Always Variable reg Reg_spec create clock i clock enable vdd width 8 in Always compile if_ i clear dout &lt; 0 when_ i incr dout &lt; dout value 1 O dout dout value val counter_with_always t I t > t O t &lt;fun> # testbench counter_with_always dout 00000000 dout 00000000 dout 00000001 dout 00000010 dout 00000000 dout 00000000 unit</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/serial_multiplier</url>
    <fullTitle>Hardcaml: 6.2 Serial Multipler,  [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>We now show a complete example which implements a bit serial unsigned multiplier We will both implement the design and show how to test it</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/serial_multiplier#algorithm</url>
    <fullTitle>Hardcaml: 6.2 Serial Multipler, Algorithm [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Given two input numbers of bit widths and a bit serial multiplier will produce a result of size every M clock cycles Given two input values and we consider each bit of in turn and form a partial product This then gets added to a running sum Let s start with a simple OCaml implementation of this algorithm Note that we do not explicitly track the iteration number Rather we detect when to stop by shifting down on each iteration and checking if it is Similarly the partial product term is computed by shifting up by one each iteration A similar set of tricks will be used to define an efficient hardware implementation Before we turn fully to the hardware implementation let s try to port the above code to the Hardcaml type The reason this hasn t worked is we are computing the running sum and partial product terms using the bit width of We need to also include the width of N M M N a b b if b i then a &lt;&lt; i else 0 # open Base # let rec umul a b if b 0 then 0 else let partial_product if b land 1 1 then a else 0 in partial_product umul a lsl 1 b lsr 1 val umul int > int > int &lt;fun> # umul 3 5 int 15 # umul 100 99 int 9900 b 0 a &lt;&lt; i Bits # open Hardcaml # open Hardcaml Bits # let rec umul a b if to_unsigned_int b 0 then zero width a else let partial_product mux2 b 0 0 a zero width a in partial_product umul sll a by 1 srl b by 1 val umul t > t > t &lt;fun> # to_unsigned_int umul of_unsigned_int width 2 3 of_unsigned_int width 3 5 int 3 a b # let umul a b umul uresize a width width a width b b val umul t > t > t &lt;fun> # to_unsigned_int umul of_unsigned_int width 2 3 of_unsigned_int width 3 5 int 15 # to_unsigned_int umul of_unsigned_int width 7 100 of_unsigned_int width 7 99 int 9900</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/serial_multiplier#hardware-implementation</url>
    <fullTitle>Hardcaml: 6.2 Serial Multipler, Hardware implementation [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>We start by implementing functions for the partial product and running sum The function takes a new argument called This is used to indicate when we are processing bit of and clears the initial sum to The inputs to the addition in are of and are zero extended by the function to produce a result of Didn t we need more precision than this in the implementation We will avoid this by outputting a fully computed bit at each iteration We also need to store the computed bits in a register The final implementation just needs to put these functions together # open Hardcaml Signal # let partial_product a b0 mux2 b0 a zero width a val partial_product Type t > Type t > Type t &lt;fun> # let running_sum first sum a b0 let sum mux2 first zero width sum sum in ue sum ue partial_product a b0 val running_sum Type t > Type t > Type t > Type t > Type t &lt;fun> running_sum first 0 b 0 running_sum width a ue width a 1 Bits # let running_sum_reg spec first a b0 let sum_w wire width a running_sum in let running_sum running_sum first sum_w a b0 running_sum_next in * Split the sum into it s least significant bit and the rest * let running_sum_bit_out lsb running_sum in let running_sum msbs running_sum in * Register the sum * let sum reg spec enable vdd running_sum in sum_w &lt; sum sum running_sum_bit_out val running_sum_reg Reg_spec t > Type t > Type t > Type t > Type t * Type t &lt;fun> # let computed_bits spec width bit reg_fb spec width f fun d > bit @ msbs d val computed_bits Reg_spec t > int > Type t > Type t &lt;fun> # let umul_sequential clock first a b_width b0 let spec Reg_spec create clock in let running_sum computed_bit running_sum_reg spec first a b0 in let computed_bits computed_bits spec b_width computed_bit in running_sum @ computed_bits val umul_sequential Type t > Type t > Type t > int > Type t > Type t &lt;fun></text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/serial_multiplier#testbench</url>
    <fullTitle>Hardcaml: 6.2 Serial Multipler, Testbench [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>We will now test our multiplier First let s create the required We can now create a simulation and waveform and get a handle on the input and output ports The following testbench will take and and create a circuit adapted to their bit widths It will then perform iterations and return the final result Let s test our running examples of multiplying and Circuit t # let create_circuit a_width b_width let clock input clock 1 in let first input first 1 in let a input a a_width in let b0 input b0 1 in let result umul_sequential clock first a b_width b0 in Circuit create_exn name umul output result result val create_circuit int > int > Circuit t &lt;fun> # module Waveform Hardcaml_waveterm Waveform module Waveform Hardcaml_waveterm Waveform # let create_sim circuit let sim Cyclesim create config Cyclesim Config trace_all circuit in let waves sim Waveform create sim in let first Cyclesim in_port sim first in let a Cyclesim in_port sim a in let b0 Cyclesim in_port sim b0 in let result Cyclesim out_port sim result in waves sim first a b0 result val create_sim Circuit t > Waveform t * Cyclesim Port_list t Cyclesim Port_list t Cyclesim t * Binary t ref * Binary t ref * Binary t ref * Binary t ref &lt;fun> a b width b # let test a_in b_in let open Bits in let waves sim first a b0 result create_circuit width a_in width b_in |> create_sim in let step iteration first if iteration 0 then vdd else gnd b0 b_in iteration iteration Cyclesim cycle sim in a a_in for i 0 to width b_in 1 do step i done * grab the result and perform 1 more cycle so we can see the result in the waveform * let result result in Cyclesim cycle sim waves result val test Binary t > Binary t > Waveform t * Binary t &lt;fun> 3*5 100*99 # let waves result test Bits of_unsigned_int width 2 3 Bits of_unsigned_int width 3 5 val waves Waveform t &lt;abstr> val result Binary t 01111 # Stdio printf %i Bits to_unsigned_int result 15 unit # Waveform print waves SignalsWaves clock                    a  3     b0        first          result  00 0C 06 0F     gnd         running_sum  0 1 0 1        running_sum_nex 3 1 3 4      unit # let _ result test Bits of_unsigned_int width 7 100 Bits of_unsigned_int width 7 99 val result Binary t 10011010101100 # Stdio printf %i Bits to_unsigned_int result 9900 unit</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/fibonacci_numbers</url>
    <fullTitle>Hardcaml: 6.3 Fibonacci Numbers,  [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>In the following example we design a state machine which computes the n th Fibonacci number Defining the circuit interfaces Note that we must use the field name in the output interface as it is a reserved word in OCaml but can use the ppx to give it our preferred name Defining the State type The circuit will wait for a start signal in and capture the input value to compute the Fibonacci number for The computation will happen over multiple cycles in state and the result will be output in the state Implementing the logic Testing the logic Lets now write a testbench which traces the sequence of states and the computed result Seeing the computation in a waveform Lets set up some display rules so the waveform prints nicely A useful pattern when defining is to over the and use the default If the width of the port is 1 it will show as a bit otherwise it will show as the type For the state value we use the type which allows us to show the value symbolically Showing the waveform module I struct type a t clock a clear a start a n a @bits 8 @@deriving hardcaml end module O struct type a t done_ a @rtlname done result a @bits 32 state a @bits 2 @@deriving hardcaml end done_ open Base open Hardcaml module Waveform Hardcaml_waveterm Waveform module States struct type t | S_wait | S_counting | S_write_result @@deriving sexp_of compare enumerate end S_wait n S_counting S_write_result let create i _ I t let r_sync Signal Reg_spec create clock i clock clear i clear in let sm Always State_machine create module States enable vdd r_sync in let done_ Always Variable wire default gnd in let result Always Variable wire default zero 32 in let f0 Always Variable reg width 32 enable Signal vdd r_sync in let f1 Always Variable reg width 32 enable Signal vdd r_sync in let remaining Always Variable reg width 8 enable Signal vdd r_sync in Always compile sm switch S_wait * The a &lt; b is semantically equivalent to a &lt; Signal of_unsigned_int width Signal width a value b Similar syntactic sugar exists for and * f0 &lt; 1 f1 &lt; 1 remaining &lt; i n 1 when_ i start if_ i n 0 sm set_next S_write_result sm set_next S_counting S_counting if_ remaining value 0 sm set_next S_write_result remaining &lt; remaining value 1 * Recall that all hardcaml assignments are synchronous so the f1 assignment below will make use of the old f0 value * f0 &lt; f1 value f1 &lt; f0 value f1 value * Output the computation result to the user * S_write_result done_ &lt; 1 result &lt; f1 value sm set_next S_wait O done_ done_ value result result value state * We output the state to help tracing in the simulation example that follows * sm current let fibonacci_testbench sim _ I t _ O t Cyclesim t let inputs outputs Cyclesim inputs sim Cyclesim outputs sim in let print_state_and_outputs let state List nth_exn States all Bits to_unsigned_int outputs state in let done_ Bits to_bool outputs done_ in let result Bits to_unsigned_int outputs result in Stdio print_s %message state States t done_ bool result int in * Start by resetting simulation and clearing the circuit * Cyclesim reset sim inputs clear Bits vdd Cyclesim cycle sim inputs clear Bits gnd * Cycle 0 * print_state_and_outputs * Cycle 1 * inputs start Bits vdd inputs n Bits of_unsigned_int width 8 4 Cyclesim cycle sim print_state_and_outputs inputs start Bits gnd * Cycle 2 Start counting the fibonacci number * Cyclesim cycle sim print_state_and_outputs * Cycle 3 * Cyclesim cycle sim print_state_and_outputs * Cycle 4 * Cyclesim cycle sim print_state_and_outputs * Cycle 5 notice that the wire assignment is combinational the done signal is asserted during the same cycle it is assigned in the state machine * Cyclesim cycle sim print_state_and_outputs * Cycle 6 this goes back to the initial waiting state * Cyclesim cycle sim print_state_and_outputs Cyclesim cycle sim let test let module Sim Cyclesim With_interface I O in let sim Sim create create in let waves sim Waveform create sim in fibonacci_testbench sim waves # let waves test state S_wait done_ false result 0 state S_counting done_ false result 0 state S_counting done_ false result 0 state S_counting done_ false result 0 state S_counting done_ false result 0 state S_write_result done_ true result 5 state S_wait done_ false result 0 val waves Waveform t &lt;abstr> display_rules map port_names wave_format Bit_or X X Index let display_rules let open Display_rule in let input_rules I map port_names f port_name_is wave_format Bit_or Unsigned_int |> to_list in let output_rules O map port_names f port_name_is wave_format Bit_or Unsigned_int with O state port_name_is state wave_format Index List map States all f fun t > States sexp_of_t t |> Sexp to_string |> O to_list in input_rules @ output_rules # let Waveform print waves display_width 94 display_rules SignalsWaves clock                      clear       start         n  0 4    done         result  0 5 0      state  S_wait S_counting S_writ S_wait    </text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/fft</url>
    <fullTitle>Hardcaml: 6.4 FFT,  [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text></text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/fft#fast-fourier-transform</url>
    <fullTitle>Hardcaml: 6.4 FFT, Fast Fourier Transform [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>In this example we will implement a 16 point fast Fourier transform FFT We ll not spend much time going through the theory and will focus on translating a software reference model to hardware For more background you can look up wikipedia</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/fft#software-implementation</url>
    <fullTitle>Hardcaml: 6.4 FFT, Software Implementation [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>At the heart of the loops we perform a complex multiply and a complex add subtract which is called a butterfly operation We read 2 values from at indices and In addition we look up a table of twiddle factors up at index The butterfly operation is performed and the results are written back to the array The outer most loop runs times The two innermost loops together will perform iterations To generate hardware for this we need to consider the following State machine to generate the and values and control the iterations A ROM to store the twiddle factor coefficients RAMs to store the input output and intermediate values during the outer iterations Logic to implement the butterfly operation let make_twiddle_factors len let pi 3 14159265358979 in let c 2 0 * pi Float of_int len in Array init len 2 f fun i > Complex exp re 0 im c * Float of_int i let fft x let len Array length x in let n_bits Int ceil_log2 len in let w make_twiddle_factors len in let y Array init len f fun i > x bitrev n_bits i in for nb 1 to n_bits do let n 1 lsl nb in let m 1 lsl n_bits nb in for h 0 to m 1 do let ofs n * h in for i 0 to n 2 1 do let j k ofs i ofs i n 2 in let a b y j y k in let wm w i * m in let wb Complex mul wm b in y j &lt; Complex add a wb y k &lt; Complex sub a wb done done done y y j k w wm y log 16 4 16 2 8 j k m</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/fft#hardware-implementation</url>
    <fullTitle>Hardcaml: 6.4 FFT, Hardware Implementation [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The follows shows the architecture we are aiming for We will load FFT coefficients into MEM through the write input The FFT will read and write MEM multiple times to perform the transform Then we will read the result back through the read output Controller state machine Lets look at the values we need to generate We can do that by modifying the FFT code and printing the values we need to generate As stated before the outer loop runs 4 times and the inner two loops combine to run 8 iterations We can encode this into a state machine is follows We now need a way to convert the and values into and Looking the at the addresses we need to generate when we just need to add a bit to the bottom of count Similarly when we insert a bit between bits 0 and 1 of For and we do the same thing at the next bit position up For we shift left by There is one final thing in the FFT code the first thing we do is reorganize the input array as follows We can do this by reversing the input address when we load the input FFT coefficients into the design Here s the final code Butterfly operation To compute the butterfly operation we need to decide how we are going to represent complex numbers Typically we would consider a fixed point format designed to suit our dynamic range and required precision Instead we are going to cheat and use a feature of Hardcaml that lets us represent full precision floating point numbers within hardware simulations The module provides the operators which take and return 64 bit signals and implement various floating point operations over them implements complex multiply and add using it The butterfly implementation is now as follows Twiddle factors This is straight forward we just create a ROM of values from the floating point twiddle factors computed for the software version Memory buffer For simplicity the memory is implemented with 3 read and 3 write ports The FFT algorithm needs to read and write two complex numbers per cycle so that accounts for two of the read write ports In addition we use 1 write port to load the FFT coefficients and 1 read port to get the result The memory will store 16 complex numbers in total It is also set up with asynchronous read ports yet another small simplification for this example This is not a terribly realistic memory structure for efficient implementation but it allows us to complete the design and test it Note that the write address on the first port is reversed as we said would be required Sticking it all together This instantiates the loop controller index generator twiddle factor rom butterfly and memory buffer There is a loop through the butterfly and memory buffer logic which requires us to predefine the and complex values as write input read output > MEM > | FFT # let n_bits 4 val n_bits int 4 # Stdio printf j | k | m n for nb 1 to n_bits do Stdio printf n let n 1 lsl nb in let m 1 lsl n_bits nb in for h 0 to m 1 do let ofs n * h in for i 0 to n 2 1 do let j k ofs i ofs i n 2 in let m i*m in Stdio printf %2d | %2d | %2d n j k m done done done j | k | m 0 | 1 | 0 2 | 3 | 0 4 | 5 | 0 6 | 7 | 0 8 | 9 | 0 10 | 11 | 0 12 | 13 | 0 14 | 15 | 0 0 | 2 | 0 1 | 3 | 4 4 | 6 | 0 5 | 7 | 4 8 | 10 | 0 9 | 11 | 4 12 | 14 | 0 13 | 15 | 4 0 | 4 | 0 1 | 5 | 2 2 | 6 | 4 3 | 7 | 6 8 | 12 | 0 9 | 13 | 2 10 | 14 | 4 11 | 15 | 6 0 | 8 | 0 1 | 9 | 1 2 | 10 | 2 3 | 11 | 3 4 | 12 | 4 5 | 13 | 5 6 | 14 | 6 7 | 15 | 7 unit module State struct type t | Start | Loop @@deriving sexp_of compare localize enumerate end let loop_controller i _ I t let spec Reg_spec create clock i clock clear i clear in let pass Always Variable reg spec width Int ceil_log2 4 in let count Always Variable reg spec width 3 in let sm Always State_machine create module State spec in Always compile sm switch Start pass &lt; 0 count &lt; 0 when_ i start sm set_next Loop Loop count &lt; count value 1 when_ count value 7 pass &lt; pass value 1 when_ pass value 3 sm set_next Start pass value count value sm is Start pass count j k m pass 0 # open Bits # Array init 8 f fun i > let count of_unsigned_int width 3 i in let j count @ gnd in let k count @ vdd in Bits to_unsigned_int j Bits to_unsigned_int k int * int array | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 | pass 1 count # Array init 8 f fun i > let count of_unsigned_int width 3 i in let j count 2 1 @ gnd @ count 0 in let k count 2 1 @ vdd @ count 0 in Bits to_unsigned_int j Bits to_unsigned_int k int * int array | 0 2 1 3 4 6 5 7 8 10 9 11 12 14 13 15 | pass 2 pass 3 m count 3 pass let y Array init len f fun i > x bitrev n_bits i in let index_generator pass count let jk const mux pass count @ const count 2 1 @ const @ count 0 0 count 2 2 @ const @ count 1 0 const @ count 2 0 in let j jk gnd in let k jk vdd in let m mux pass sll count by 3 sll count by 2 sll count by 1 sll count by 0 in j k m module Dcomplex struct type a t re a @bits 64 im a @bits 64 @@deriving hardcaml open Cyclesim_float_ops Double let add a b re a re b re im a im b im let sub a b re a re b re im a im b im let mul a b re a re * b re a im * b im im a re * b im a im * b re end Cyclcesim_float_ops Double Dcomplex let butterfly a b w let wb Dcomplex mul w b in Dcomplex add a wb Dcomplex sub a wb Dcomplex let bits_of_float type a module Comb Comb S with type t a f a Int64 bits_of_float f |> Comb of_int64_trunc width 64 let float_of_bits b Bits to_int64_trunc b |> Int64 float_of_bits let twiddle_factor_rom m let w make_twiddle_factors 16 in Array to_list w |> List map f fun w Complex t > Dcomplex re bits_of_float module Signal w re im bits_of_float module Signal w im |> Dcomplex Of_signal mux m let memory_buffer clock ext_write _ Write_port t int_write_a _ Write_port t int_write_b _ Write_port t int_read_a int_read_b ext_read let q multiport_memory 16 write_ports | write_clock clock write_data Dcomplex Of_signal pack ext_write data write_enable ext_write enable write_address reverse ext_write address write_clock clock write_data Dcomplex Of_signal pack int_write_a data write_enable int_write_a enable write_address int_write_a address write_clock clock write_data Dcomplex Of_signal pack int_write_b data write_enable int_write_b enable write_address int_write_b address | read_addresses | ext_read int_read_a int_read_b | in Array map q f Dcomplex Of_signal unpack let create i _ I t let scope Scope create in let%hw pass count done_ loop_controller i in let%hw j k m index_generator pass count in let%hw Dcomplex Of_signal w twiddle_factor_rom m in let%hw Dcomplex Of_signal a Dcomplex Of_signal wires in let%hw Dcomplex Of_signal b Dcomplex Of_signal wires in let%hw Dcomplex Of_signal a_next b_next butterfly a b w in let memory_buffer memory_buffer clock i clock ext_write i write int_write_a enable done_ address j data a_next int_write_b enable done_ address k data b_next int_read_a j int_read_b k ext_read i read_address in Dcomplex Of_signal assign a memory_buffer 1 Dcomplex Of_signal assign b memory_buffer 2 O done_ data_out memory_buffer 0 a b wires</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/fft#testing-the-design</url>
    <fullTitle>Hardcaml: 6.4 FFT, Testing the Design [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>To test the FFT design we will need 4 functions simple clear reset of the registers in the design load the input test data start the core and wait for it to complete read back the final results from the design Finally we create our simulator and run a simulation Note that we have provided the to so it knows how to implement the floating point operations Waveform An interesting point here is we are displaying floating point values within the waveform This is done by writing a display rule for floating point numbers clear_core load_fft_coefficients run_fft read_results let clear_core sim Sim t let inputs Cyclesim inputs sim in inputs clear vdd Cyclesim cycle sim inputs clear gnd let load_fft_coefficients sim Sim t let inputs Cyclesim inputs sim in inputs write enable Bits vdd for i 0 to 15 do inputs write address &lt; i inputs write data re bits_of_float module Bits Float of_int i 1 inputs write data im bits_of_float module Bits Float of_int 0 Cyclesim cycle sim done inputs write enable Bits gnd let run_fft sim Sim t let inputs Cyclesim inputs sim in let outputs Cyclesim outputs sim in inputs start Bits vdd Cyclesim cycle sim inputs start Bits gnd while not Bits to_bool outputs done_ do Cyclesim cycle sim done let read_results sim Sim t let inputs Cyclesim inputs sim in let outputs Cyclesim outputs sim in for i 0 to 15 do inputs read_address &lt; i Cyclesim cycle sim let result Complex re float_of_bits outputs data_out re im float_of_bits outputs data_out im in Stdio printf %d %f % fi n i result re result im done Cyclesim_float_ops Double database Cyclesim let hw_test let sim Sim create config Cyclesim Config trace_all with combinational_ops_database Cyclesim_float_ops Double database create in let waves sim Waveform create sim in clear_core sim load_fft_coefficients sim run_fft sim read_results sim Waveform expect waves wave_width 2 display_rules start_cycle 38 let%expect_test hw_test %expect | 0 136 000000 0 000000i 1 8 000000 40 218716i 2 8 000000 19 313708i 3 8 000000 11 972846i 4 8 000000 8 000000i 5 8 000000 5 345429i 6 8 000000 3 313708i 7 8 000000 1 591299i 8 8 000000 0 000000i 9 8 000000 1 591299i 10 8 000000 3 313708i 11 8 000000 5 345429i 12 8 000000 8 000000i 13 8 000000 11 972846i 14 8 000000 19 313708i 15 8 000000 40 218716i SignalsWaves clock                     clear     start     done_     i$enable       pass  2 3      count  4 5 6 7 0 1 2 3 4      j  8 9 10 11 0 1 2 3 4      k  12 13 14 15 8 9 10 11 12     m  0 2 4 6 0 1 2 3 4      i$address  15      read_address  0      i$re  16      i$im  0      o$re  64 136      o$im  0      a$re  32  8 0  8  7 9 64  8 0  8 0  8 0  8     a$im  0 8 0  8 0 19 3 8 3 31 0      b$re  40  8 0  8  7 9 72  8 0  8 0  8 0  8     b$im  0 8 0  8 0 19 3 8 3 31 0      w$re  1 0 70 1 61  0 7 1 0 92 0 70 0 38 1      w$im  0  0 7  1  0 7  0  0 3  0 7  0 9  1     a_next$re  72  8 0  8 0  8 0 136  8 0  8 0  8 0  8     a_next$im  0 19 3 8 3 31 0 40 2 19 3 11 9 8      b_next$re  8  7 9  7 9  7 9  8  7 9  7 9  7 9  7     b_next$im  0  3 3  8  19 0  1 5  3 3  5 3  8    7a788a5d3036c98ecb7da5ed09414842 | Custom let display_rules let float name Display_rule port_name_is name wave_format Custom fun b > float_of_bits b |> Float to_string in let complex name float name ^ $re float name ^ $im in let bit name Display_rule port_name_is name wave_format Bit in let uint name Display_rule port_name_is name wave_format Unsigned_int in bit clock bit clear bit start bit done_ bit i$enable uint pass uint count uint j uint k uint m uint i$address uint read_address complex i complex o complex a complex b complex w complex a_next complex b_next |> List concat</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/fft#improving-the-design</url>
    <fullTitle>Hardcaml: 6.4 FFT, Improving the Design [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>To make this design more realistic there are a few things we would need to change Switching to a fixed point representation of Complex numbers Pipelining the butterfly module and synchronizing the read write processes within the core At the moment it is entirely combinational Making the memory buffer read ports synchronous so they can be implemented efficiently Adding ping pong buffers for the input output stages to reduce the total number of ports required Making it work for generic power of 2 transform sizes</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/binary_search#binary-search</url>
    <fullTitle>Hardcaml: 6.5 Binary Search, Binary Search [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Binary search allows us to find an element in a sorted array of length in steps It starts by considering the full range of the array and testing the mid point at If the element is found we are done Otherwise if the element at the midpoint is greater than the element we are looking for we repeat with the range set to If it is less we use the range This continues until the element is found or the range becomes empty N log2 N 0 N 1 N 2 0 N 2 N 2 N</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/binary_search#designing-the-hardware-interface</url>
    <fullTitle>Hardcaml: 6.5 Binary Search, Designing the Hardware Interface [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The elements of the array we search must contain a value by which it is sorted and that the binary search algorithm can use In Ocaml we could represent each element as In Hardcaml we can take a similar approach The hardware design also needs to know the size of the array we are searching and the number of bits in the key Thus we define the following type The hardware design will be fully parameterized by by implementing it within a functor The interface to the design is specified as follows The interface consists of the following logical parts Clocking is an interface which groups together the and signals Control is used to begin the search and indicates when a search is in progress is the key we are searching for and must be provided coincident with and be held during the search operation Array access is the current index we are searching the array at and is the data at that address Output result is the address at which the element was found is the data we found The type of is which was defined as is common pattern in Hardcaml code It wraps a signal or as in this case an with an additional bit If is high the search succeeded and if it is low the search failed the element we were looking for did not exist in the input array key module type Data sig type t val key t > int end module type Data sig include Interface S val key Signal t t > Signal t end Config module type Config sig module Data Data val log_size int val key_size int end Config module Make Config Config struct * hardware implemented here * end module Data_with_valid With_valid Wrap Make Config Data module I struct type a t clocking a Clocking t * Clock and clear * start a * Pulsed to start search * d a Config Data t * Data read at `address` * find_key a @bits Config key_size * Key we are looking for * @@deriving hardcaml end module O struct type a t done_ a * Low while searching * index a @bits Config log_size * Index where key was found * q a Data_with_valid t * Data where key was found * address a @bits Config log_size * Address into search array * @@deriving hardcaml end Clocking clock clear start done_ find_key start address d index q q Data_with_valid module Data_with_valid With_valid Wrap Make Config Data With_valid Interface valid valid</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/binary_search#implementing-the-search</url>
    <fullTitle>Hardcaml: 6.5 Binary Search, Implementing the Search [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>When start is applied we set the initial range and the state machine transitions to the state The point is output as and the current element is checked if we found the key the search succeeds is set high and the index and data are output otherwise if the mid point equals the low point the search range is 0 and the search fails is set low otherwise if the search key is less than the current key search the left half otherwise if the search key is greater then the current key search the right half module State struct type t | Start | Loop @@deriving sexp_of compare localize enumerate end let create scope i _ I t let%hw Always State_machine sm Always State_machine create module State Clocking to_spec i clocking in * search range * let%hw_var low Clocking Var reg i clocking width Config log_size 1 in let%hw_var mid Clocking Var reg i clocking width Config log_size 1 in let%hw_var high Clocking Var reg i clocking width Config log_size 1 in * results * let index Clocking Var reg i clocking width Config log_size in let q Data_with_valid Of_always reg Clocking to_spec i clocking in let%hw key Config Data key i d in Always compile sm switch Start low &lt; 0 mid &lt; Int pow 2 Config log_size 2 high &lt; Int pow 2 Config log_size when_ i start q valid &lt; gnd sm set_next Loop Loop * success * if_ i find_key key q valid &lt; vdd index &lt; lsbs mid value Config Data Of_always assign q value i d sm set_next Start * failure * @@ elif mid value low value q valid &lt; gnd sm set_next Start * search left half * @@ elif i find_key &lt; key high &lt; mid value mid &lt; low value srl mid value low value by 1 @@ * search right half * low &lt; mid value mid &lt; mid value srl high value mid value by 1 O done_ sm is Start index index value q Data_with_valid Of_always value q address lsbs mid value Loop mid address q valid q valid</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/binary_search#testing</url>
    <fullTitle>Hardcaml: 6.5 Binary Search, Testing [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Adding the search array To make the testbench simpler to implement we are going to create a top level architecture which include the search array memory The interface to this design has a write port for loading the search data along with the and values The output is the same as before except we don t output and wire this directly into the memory The implementation just instantiates the search array memory and binary search module Writing the testbench Configuring the testbench Define the interface we will search over and the size of the array to search The array size will be 16 elements The key is 6 bits so ranges from 0 to 63 Test functions The testbench is implemented by the following functions clear_core clear reset the registers load_inputs load the array to search run_core start the search wait for it to complete then return the results Testbench Randomized testing We can now perform some randomized testing We create an array of random elements and sort it We then search for some random keys in the array If it doesn t raise all is well Waveform start find_key address module Make_with_memory Config Config struct module Binary_search Make Config module I struct type a t clocking a Clocking t write_enable a write_data a Config Data t write_address a @bits Config log_size start a find_key a @bits Config key_size @@deriving hardcaml end module O struct type a t done_ a index a @bits Config log_size q a Binary_search Data_with_valid t @@deriving hardcaml end let create scope i _ I t let read_address wire Config log_size in let q multiport_memory Int pow 2 Config log_size write_ports | write_clock i clocking clock write_address i write_address write_enable i write_enable write_data Config Data Of_signal pack i write_data | read_addresses | read_address | in let binary_search Binary_search create scope Binary_search I clocking i clocking start i start d Config Data Of_signal unpack q 0 find_key i find_key in read_address &lt; binary_search address O done_ binary_search done_ index binary_search index q binary_search q end Data module Data struct let key_size 6 type a t key a @bits key_size data a @bits 32 @@deriving hardcaml let key t t key end module Config struct module Data Data let key_size Data key_size let log_size 4 end let clear_core sim Sim t let inputs Cyclesim inputs sim in inputs clocking clear &lt; 1 Cyclesim cycle sim inputs clocking clear &lt; 0 let load_inputs sim Sim t input_data int Data t array let inputs Cyclesim inputs sim in inputs write_enable &lt; 1 for i 0 to Int pow 2 Config log_size 1 do inputs write_address &lt; i inputs write_data key &lt; input_data i key inputs write_data data &lt; input_data i data Cyclesim cycle sim done let run_core sim Sim t find_key let inputs Cyclesim inputs sim in let outputs Cyclesim outputs sim in * Start the search * inputs start &lt; 1 Cyclesim cycle sim inputs start &lt; 0 inputs find_key &lt; find_key * Wait for it to finish Don t let it take more than 20 cycles * let timeout ref 0 in while not Bits to_bool outputs done_ &amp;&amp; timeout &lt; 20 do Cyclesim cycle sim Int incr timeout done Cyclesim cycle sim * Collect and return results * let found Bits to_bool outputs q valid in if found then let index Bits to_unsigned_int outputs index in let data Bits to_unsigned_int outputs q value data in let key Bits to_unsigned_int outputs q value key in * Sanity check make sure the key we found was actually the key we were searching for * if key &lt;&gt; find_key then raise_s %message Found wrong key find_key int key int index int data int Some index data else None let validate input_data int Data t array find_key result let key_is_in_input_data match Array find input_data f fun key _ > key find_key with | None > false | _ > true in let raise_search_failed raise_s %message Search failed find_key int key_is_in_input_data bool result int * int option input_data int Config Data t array in match result key_is_in_input_data with | None true > * The hardware didn t find the element but it was there * raise_search_failed | Some _ false > * The hardware found an element but it wasn t there * raise_search_failed | None false > * Nothing to find * | Some index data true > * We found the element check the key and data are as expected * if input_data index key &lt;&gt; find_key || input_data index data &lt;&gt; data then raise_search_failed let test waves input_data find_key let open Hardcaml_waveterm in * Create the simulator * let scope Scope create auto_label_hierarchical_ports true flatten_design true in let sim Sim create config Cyclesim Config trace_all Binary_search create scope in let waves sim * Optionally trace a waveform * if waves then let waves sim Waveform create sim in Some waves sim else None sim in * Run the testbench * clear_core sim load_inputs sim input_data let result run_core sim find_key in * Optionally show the waveform * Option iter waves f Waveform expect_exact wave_width 3 start_cycle 16 display_rules * Check the results are valid * validate input_data find_key result Data let%expect_test random tests for _ 1 to 10 do let input_data Array init Int pow 2 Config log_size f fun _ > Config Data key random_key data random_data in Array sort input_data compare fun key _ key key1 _ > Int compare key key1 for _ 1 to 20 do let find_key random_key in test waves false input_data find_key done done %expect | | let%expect_test debug waveform let input_data Array init Int pow 2 Config log_size f fun i > Config Data key i data i in let find_key 3 in test waves true input_data find_key %expect_exact | SignalsWaves clocking$clock                     clocking$clear      write_enable         write_data$key  15        write_data$data  15        write_address  15     start           find_key  0 3     done_           index  0 3     q$valid          q$value$key  0 3        q$value$data  0 3        low  0 2        mid  8 4 2 3        high  16 8 4        sm  Start Loop Start      c55f6d1c162be347d7d0654ae22a7310 |</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/quicksort#quicksort</url>
    <fullTitle>Hardcaml: 6.6 Quicksort, Quicksort [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Quicksort is a sorting algorithm that takes operations in the average case and in the worst case It is a divide and conquer algorithm that recursively sorts the input in two halves It works as follows Pick some element from the array Call this the pivot Partition the array such into three parts All values less than or equal to the pivot are placed before the pivot and all elements greater than the pivot are placed after it Given this we can be sure pivot is now actually in the correct position in the array Recursively apply quicksort to the left and right partitions Quicksort describes a family of algorithms with some different trade offs in particular the actual partitioning algorithm and how to choose the pivot can affect its performance on different input arrays Lets start with the most basic implementation It is a very elegant implementation and indeed runs with the expected average and worst case complexities However it also allocates lots of intermediate lists and the amount of space needed will be proportional to the runtime i e in worst case it could require space We want to implement this on in hardware so we d like to get a better bound on the space requirements In place sorting Lomuto described a partitioning scheme that is both simple and can run in place i e it modifies the input array rather than allocating new arrays So we ve fixed the space problem except we haven t quite Although we no longer allocate new data arrays we still use stack space for the recursive calls The stack usage will follow the average and worst case complexity of the algorithm depending on the input data ie it could be up to Why does this happen It s because of the choice of pivot For best performance the pivot should evenly split the input array but we cannot guarantee that If the input was already sorted we hit a degenerate case where the left partition is all the elements except the pivot and the right partition is empty Thus we need to recurse times to quicksort it Sedgewick s log stack space trick Now we come to the implementation we want to use for hardware This reorganizes the recursion so it only uses stack space on the smaller partition It doesn t change the amount of computation we do it will still be but we can ensure we use only stack space O N log N O N^2 &lt; pivot pivot > pivot let rec qsort a match a with | > | x xs > let left List filter xs f fun y > y &lt; x in let right List filter xs f fun y > y > x in List concat qsort left x qsort right O N^2 let swap a i j let tmp a i in a i &lt; a j a j &lt; tmp let partition a low high let pivot a high in let i ref low in for j low to high 1 do if a j &lt; pivot then swap a i j Int incr i done swap a i high i let rec qsort a low high if not low > high || low &lt; 0 then let p partition a high low in qsort a low high p 1 qsort a low p 1 high let qsort a qsort a low 0 high Array length a 1 O N N O N^2 log N let rec qsort a low high let low high ref low ref high in while low &lt; high do let pivot partition a low low high high in if pivot low &lt; high pivot then qsort a low low high pivot 1 low pivot 1 else qsort a low pivot 1 high high high pivot 1 done let qsort a qsort a low 0 high Array length a 1</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/quicksort#hardware-design</url>
    <fullTitle>Hardcaml: 6.6 Quicksort, Hardware Design [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Top level architecture The top level design consists of a RAM and the sorting core The RAM is implementation with a Simple Dual Port RAM This means it has one read and one write port The sorting core requires read write access to the RAM as does the external interface in order to load the data and read back the result Thus the ports are multiplexed This basically means the RAM should not be accessed by the external interface while the core is running We show a little trick for designs like this where the outputs of both modules are also required as inputs to the modules You can predefine the outputs of one model as wires and then use them in the other module We can then assign the wires when we create the second module This trick extends to as many modules as needed | _______ | ______||__| |__||_____ _|| | RAM | ||_ | | |_______| | | | _______ | | | | | |_____| QSORT |_____| | | |_______| module type Config sig val log_size int val data_size int end module Make_with_memory Config Config struct open Config module Qsort Make Config module I struct type a t clocking a Types Clocking t start a write_enable a write_address a @bits log_size write_data a @bits data_size read_address a @bits log_size read_enable a @@deriving hardcaml rtlmangle false end module O struct type a t done_ a data_out a @bits data_size @@deriving hardcaml rtlmangle false end let create scope i _ I t let%hw Qsort O Of_signal qsort Qsort O Of_signal wires in let%hw ram Ram create name my_ram collision_mode Read_before_write size Int pow 2 log_size write_ports | write_clock i clocking clock write_enable i write_enable | qsort write_enable write_address mux2 i write_enable i write_address qsort write_address write_data mux2 i write_enable i write_data qsort write_data | read_ports | read_clock i clocking clock read_enable i read_enable | qsort read_enable read_address mux2 i read_enable i read_address qsort read_address | 0 in Qsort O Of_signal assign qsort Qsort create scope Qsort I clocking i clocking start i start read_data ram O done_ qsort done_ data_out ram end</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/examples/quicksort#quicksort-design</url>
    <fullTitle>Hardcaml: 6.6 Quicksort, Quicksort Design [Examples]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>There are three main things the core must implement The partitioning process Control of recursion and iterations Management of the stack In addition there is a complexity with regard to the RAM Because we are instantiating a proper synthesizable RAM the read is synchronous this means we get the read data one cycle after providing the read address We will need to account for this latency in our state machine Call stack The hardware outputs the current top most entry of the stack via This is of type and contains the low and high indices of the current range along with the pivot index We allow writes to the stack in two different ways has a valid associated with each field If the is high then we overwrite that field in the current entry Alternatively if is set then we write all fields regardless of to the next entry on the stack and increment the pointer Note when setting the of the memory which implements this If is set we decrement the pointer effectively popping the top entry of the stack Lastly we provide which indicates if the stack is empty Sorting core Interface The interface to the core is very simple Apart from and it just consists of a signal a indicator and the connections to the read and write ports of the RAM States The sorting algorithm is implemented as state machine The states and are involved with recursion and iteration control and perform the partitioning process The state machine begins in the state We ll discuss each state in detail below Where appropriate we shall refer to the Sedgewick implementation of qsort along with the Lomuto partitioning code shown again below with line numbers Start When is raised the initial search range is set at the top of the call stack and we transition to Qsort This controls the main while loop in the algorithm at line 22 If the test passes we move state and start the partitioning process Note we also set the RAM read address to the pivot point This is done so the pivot is available to be read in the next state When the test fails we end the qsort function but only at this level of the stack Hence the state machine will pop the and repeat the test If the becomes empty we are done and go back to the state Pivot In this state we simply read the pivot value we will use for partitioning It corresponds to line 8 We move directly to state We set the read address to the start of the partition so we can begin streaming through it in the following states Partition Swap and Swap_pivot The states and implement the for loop on lines 10 to 15 If the test against the pivot at line 11 passes we immediately write the value at into while setting the read address to and transition to writes the value at into completing the swap It transitions back immediately to state Note we read and write the value at address in the RAM on the same cycle This will write the new value while reading the old value which is what we require for the swap operation This behavior is due to setting the collision mode of the RAM to On line 10 we see the iteration goes up to The state machine actually goes up to The reason for this is we need to swap the values at high and as on line 16 A key point here is the test on line 11 it will never be true for the value at as it is the pivot value When we reach high we will transition to to complete the final swap operation Within we also now know the correct index of the pivot so write it into the current entry It will be used for later iterations Update_range and recurse These states implement lines 23 to 30 They find the smaller of the two partitions and recurse into it In terms of hardware we need to do two things hence the two states In we are dealing with line 27 or 30 This is effectively replacing the current entry with the larger range A small subtlety here is by updating the entry we actually change the test for the smaller partition hence we must store it in a register for use in In we push the smaller partition into the There is a little extra logic to do with setting the signal We avoid doing so if the pivot would become negative or larger than the array size This is because our register values high low pivot etc cannot represent numbers outside the range It is safe to do this if we did recurse and extended the size of the registers we would immediately fail the test on line 22 anyway Implementation Below is the complete implementation for reference Testing We will not go through the testbench in detail for this example suffice it to say it looks very similar to previous examples perform a reset load the input data start the core and wait for it to complete and then read back the results and check they are correct There is an interesting bit of code to do with debugging though While the core is running we optionally execute a function called on every clock cycle This uses a feature of that allows us to lookup internal values within a simulation In particular we look up the high low and pivot values and the complete memory contents every time the state machine enters the We then dump those values When debugging the state machine this was very useful in tracking down problems The output looks likes this This data made it much much easier to find points where things started to go awry module Partition struct type a t low a @bits log_size high a @bits log_size pivot a @bits log_size @@deriving hardcaml rtlmangle false end module Partition_with_valids With_valid Fields Make Partition module Call_stack struct module I struct type a t clocking a Clocking t partition a Partition_with_valids t push a pop a @@deriving hardcaml rtlmangle false end module O struct type a t partition a Partition t is_empty a @@deriving hardcaml rtlmangle false end let create scope i _ I t _ O t let addr_bits Int ceil_log2 log_size 1 in let%hw top wire addr_bits in let top_next top 1 in let top_prev top 1 in top &lt; Clocking reg i clocking enable i push | i pop mux2 i push top_next top_prev let create_stack With_valid valid value multiport_memory log_size 1 write_ports | write_clock i clocking clock write_enable i push | valid write_address mux2 i push top_next top write_data value | read_addresses | top | 0 in O partition Partition map i partition f create_stack is_empty top 0 end O partition _ Partition t I partition valid top I push valid top mux2 write_address I pop top O is_empty clock clear start done_ module I struct type a t clocking a Types Clocking t start a read_data a @bits data_size @@deriving hardcaml rtlmangle false end module O struct type a t done_ a write_enable a write_address a @bits log_size write_data a @bits data_size read_address a @bits log_size read_enable a @@deriving hardcaml rtlmangle false end Qsort Update_range Recurse Pivot Partition Swap Swap_pivot Start module State struct type t | Start | Qsort | Pivot | Partition | Swap | Swap_pivot | Update_range | Recurse @@deriving sexp_of compare localize enumerate end 1 let swap a i j 2 let tmp a i in 3 a i &lt; a j 4 a j &lt; tmp 5 6 7 let partition a low high 8 let pivot a high in 9 let i ref low in 10 for j low to high 1 do 11 if a j &lt; pivot 12 then 13 swap a i j 14 int incr i 15 done 16 swap a i high 17 i 18 19 20 let rec qsort a low high 21 let low high ref low ref high in 22 while low &lt; high do 23 let pivot partition a low low high high in 24 if pivot low &lt; high pivot 25 then 26 qsort a low low high pivot 1 27 low pivot 1 28 else 29 qsort a low pivot 1 high high 30 high pivot 1 31 done 32 start Qsort Pivot Call_stack Call_stack Start Partition Partition Swap j i i Swap Swap i j Partition i Read_before_write high 1 high i high Swap_pivot Swap_pivot Call_stack Update_range Call_stack Call_stack Recurse Recurse Call_stack push 0 array size 1 let create scope i _ I t let%hw Always State_machine sm Always State_machine create module State Clocking to_spec i clocking in let%hw Partition_with_valids Of_always write_partition Partition_with_valids Of_always wire zero in let%hw_var push Always Variable wire default gnd in let%hw_var pop Always Variable wire default gnd in let%hw Call_stack O Of_signal stack Call_stack create scope Call_stack I clocking i clocking partition Partition_with_valids Of_always value write_partition push push value pop pop value in let read_address Always Variable wire default zero log_size in let write_address Always Variable wire default zero log_size in let write_enable Always Variable wire default gnd in let write_data Always Variable wire default zero data_size in let%hw_var i_idx Clocking Var reg i clocking width log_size in let%hw_var j_idx Clocking Var reg i clocking width log_size in let%hw_var j_idx_prev Clocking Var reg i clocking width log_size in let%hw_var pivot_at Clocking Var reg i clocking width log_size in let%hw_var tmp Clocking Var reg i clocking width log_size in let init_j_idx Always proc j_idx &lt; stack partition low 1 j_idx_prev &lt; stack partition low in let incr_j_idx Always proc j_idx &lt; j_idx value 1 j_idx_prev &lt; j_idx value in let swap_write address data Always proc write_address &lt; address write_data &lt; data write_enable &lt; vdd in let partition_search_update raddr Always proc read_address &lt; j_idx value incr_j_idx when_ j_idx_prev value stack partition high read_address &lt; raddr swap_write i_idx value pivot_at value sm set_next Swap_pivot in let left_partition_is_smaller stack partition pivot stack partition low &lt; stack partition high stack partition pivot in let left_partition_is_smaller_reg Clocking Var reg i clocking width 1 in let read_enable Clocking Var reg i clocking width 1 in Always compile proc Partition map write_partition f fun valid value _ > valid &lt; gnd |> Partition to_list pop &lt; gnd sm switch Start when_ i start Partition_with_valids Of_always assign write_partition low valid vdd value zero log_size high valid vdd value ones log_size pivot valid vdd value zero log_size read_enable &lt; vdd sm set_next Qsort Qsort if_ stack partition low &lt; stack partition high i_idx &lt; stack partition low init_j_idx read_address &lt; stack partition high sm set_next Pivot if_ stack is_empty read_enable &lt; gnd sm set_next Start pop &lt; vdd Pivot read_address &lt; stack partition low pivot_at &lt; i read_data sm set_next Partition Partition if_ i read_data &lt; pivot_at value swap_write i_idx value i read_data read_address &lt; i_idx value i_idx &lt; i_idx value 1 sm set_next Swap partition_search_update i_idx value Swap swap_write j_idx_prev value i read_data read_address &lt; j_idx value sm set_next Partition partition_search_update i_idx value Swap_pivot swap_write stack partition high i read_data write_partition pivot value &lt; i_idx value write_partition pivot valid &lt; vdd sm set_next Update_range Update_range left_partition_is_smaller_reg &lt; left_partition_is_smaller if_ left_partition_is_smaller tmp &lt; stack partition low write_partition low value &lt; stack partition pivot 1 write_partition low valid &lt; vdd tmp &lt; stack partition high write_partition high value &lt; stack partition pivot 1 write_partition high valid &lt; vdd sm set_next Recurse Recurse if_ left_partition_is_smaller_reg value write_partition low value &lt; tmp value write_partition high value &lt; stack partition pivot 1 write_partition low value &lt; stack partition pivot 1 write_partition high value &lt; tmp value push &lt; mux2 left_partition_is_smaller_reg value stack partition pivot &lt;&gt; 0 stack partition pivot &lt;&gt; 1 sm set_next Qsort O done_ sm is Start write_enable write_enable value write_address write_address value write_data write_data value read_address read_address value read_enable read_enable value module Debug struct type t ram Cyclesim Memory t low Cyclesim Node t pivot Cyclesim Node t high Cyclesim Node t sm Cyclesim Reg t pivot_state int let create sim let ram Cyclesim lookup_mem_by_name sim my_ram |> Option value_exn in let low Cyclesim lookup_node_by_name sim stack$low |> Option value_exn in let pivot Cyclesim lookup_node_by_name sim stack$pivot |> Option value_exn in let high Cyclesim lookup_node_by_name sim stack$high |> Option value_exn in let sm Cyclesim lookup_reg_by_name sim sm |> Option value_exn in let pivot_state _ List findi_exn Qsort Qsort State all f fun _ > function | Pivot > true | _ > false in ram low pivot high sm pivot_state let update_on_cycle t if Cyclesim Reg to_int t sm t pivot_state then let ram Cyclesim Memory read_all t ram in let ram Array map ram f Bits to_unsigned_int in let low Cyclesim Node to_int t low in let pivot Cyclesim Node to_int t pivot in let high Cyclesim Node to_int t high in Stdio print_s %message _ low pivot high int * int * int ram int array end let run_qsort sim Sim t debug let inputs Cyclesim inputs sim in let outputs Cyclesim outputs sim in inputs start vdd Cyclesim cycle sim inputs start gnd let timeout ref 0 in while not Bits to_bool outputs done_ &amp;&amp; timeout &lt; 300 do Option iter debug f Debug update_on_cycle Cyclesim cycle sim Int incr timeout done Debug update_on_cycle Cyclesim Pivot state 0 0 15 ram 9 4 7 6 5 5 0 3 1 4 8 6 4 0 2 3 0 0 3 ram 0 1 0 2 3 5 9 3 4 4 8 6 4 7 6 5 0 3 2 ram 0 1 0 2 3 5 9 3 4 4 8 6 4 7 6 5 1 0 2 ram 0 1 0 2 3 5 9 3 4 4 8 6 4 7 6 5 5 4 15 ram 0 0 1 2 3 5 9 3 4 4 8 6 4 7 6 5 5 0 8 ram 0 0 1 2 3 3 4 4 4 5 8 6 9 7 6 5 7 6 8 ram 0 0 1 2 3 3 4 4 4 5 8 6 9 7 6 5 10 9 15 ram 0 0 1 2 3 3 4 4 4 5 8 6 9 7 6 5 11 10 15 ram 0 0 1 2 3 3 4 4 4 5 5 6 9 7 6 8 11 14 13 ram 0 0 1 2 3 3 4 4 4 5 5 6 7 6 8 9 12 11 13 ram 0 0 1 2 3 3 4 4 4 5 5 6 7 6 8 9</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/libraries/high_performance_simulation_backends</url>
    <fullTitle>Hardcaml: 7.1 High Performance Simulation Backends,  [Libraries]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>The default simulator shipped with Hardcaml is a cycle accurate simulator implemented in OCaml There are two other types of simulator backends shipped with Hardcaml available in the and libraries The libraries can be installed with opam hardcaml_c hardcaml_verilator opam install hardcaml_verilator opam install hardcaml_c</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/libraries/high_performance_simulation_backends#hardcaml_verilator</url>
    <fullTitle>Hardcaml: 7.1 High Performance Simulation Backends, Hardcaml_verilator [Libraries]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Verilator is a free and open source software tool which converts Verilog to a cycle accurate behavioural model in C or SystemC that runs with high performance is a simulation backend that compiles a Hardcaml circuit simulation to the Verilator backend with custom generated C bindings All these are done under the hood whilst exposing the Cyclesim API to the end user To use Verilator and g have to be installed on your system The key benefit of using the Verilator based backend is that it is much more performant than using Cyclesim or Hardcaml_c There are several known downsides with this simulation backend The Verilator simulator does not support inspecting the values of internal signals of the circuit Compiling extremely large circuits on Verilator can be slow but the trade off is worthwhile for large scale simulations After creating the Verilator based Cyclesim object the simulation works as would any Cyclesim simulator Notice the type signature of being a simple This means that we can write simulation test benches that are agnostic to the backend whether it is Hardcaml s Cyclesim Hardcaml Verilator or Hardcaml C also supports an Interface based API See Compilation options Some Verilator configuration options are exposed via In particular it is possible to split the generated C code into much smaller chunks and use many more gcc processes which can drastically improve compilation time See the config module for some presets The code supports both version 4 and 5 of Verilator set the config value verilator_version appropriately Hardcaml_verilator Hardcaml_verilator open Hardcaml open Signal * Circuit definition * let clock input clock 1 let foo input foo 32 let bar input bar 32 let baz let r_sync Reg_spec create clock in output baz reg enable vdd r_sync foo bar * Create Simulation * let circuit Circuit create_exn name adder baz # let cycle sim foo bar Cyclesim in_port sim foo Bits of_unsigned_int width 32 foo Cyclesim in_port sim bar Bits of_unsigned_int width 32 bar Cyclesim cycle sim Stdio printf %d %d %d n foo bar Bits to_unsigned_int Cyclesim out_port sim baz val cycle a b Cyclesim t > int > int > unit &lt;fun> # let sim_verilator Hardcaml_verilator create clock_names clock circuit val sim_verilator Cyclesim t_port_list &lt;abstr> # cycle sim_verilator 1 2 1 2 3 unit # cycle sim_verilator 23 34 23 34 57 unit sim_verilator Cyclesim t_port_list Hardcaml_verilator Hardcaml_verilator With_interface Hardcaml_verilator Config</text>
    </text>
  </entry>
  <entry>
    <url>/hardcaml-docs/libraries/high_performance_simulation_backends#hardcaml_c</url>
    <fullTitle>Hardcaml: 7.1 High Performance Simulation Backends, Hardcaml_c [Libraries]</fullTitle>
    <text>
      <score>STANDARD</score>
      <text>Hardcaml_c is a Hardcaml simulator that converts the design to a C based simulation model for improved performance The primary benefit of using Hardcaml_c is that it has a much more modest compilation time compared to but is still much more performant than the regular Hardcaml Cyclesim simulator To use has to be installed on your local machine The key limitation in Hardcaml C is that as of writing it does not properly support tracing outputs before clock edges Using the simulation backend is simple as demonstrated in the example below Like Hardcaml Verilator Hardcaml C supports an Interface based API See Hardcaml_verilator Hardcaml_c gcc Hardcaml_c # let sim_c Hardcaml_c Cyclesim create circuit val sim_c Cyclesim t_port_list &lt;abstr> # cycle sim_c 1 2 1 2 3 unit # cycle sim_c 23 50 23 50 73 unit Hardcaml_c Cyclesim With_interface</text>
    </text>
  </entry>
</znai>
